<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><base href=https://www.lowrisc.org><link rel=icon type=image/png sizes=32x32 href=/favicon.png><title>lowRISC project ideas for GSoC 2017 &middot; lowRISC: Collaborative open silicon engineering</title><link href=/main.21c9d.css rel=stylesheet><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-53520714-1','auto');ga('send','pageview');}</script></head><body><header><nav class="navbar navbar-expand-md navbar-light"><div class=container><a class=navbar-brand href=#><img src=/img/logo/logo-dualcolor.svg alt=lowRISC></a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarCollapse aria-controls=navbarCollapse aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarCollapse><ul class="navbar-nav ml-auto"><li class=nav-item><a href=/our-work class=nav-link>Our work</a></li><li class=nav-item><a href=/open-silicon class=nav-link>Open Silicon</a></li><li class=nav-item><a href=/community class=nav-link>Community</a></li><li class=nav-item><a href=/blog class=nav-link>Blog</a></li><li class=nav-item><a href=/jobs class=nav-link>Jobs</a></li><li class=nav-item><a href=/about class=nav-link>About us</a></li><li class=nav-item><a class="btn lr-navbar-btn-gh" href=https://github.com/lowrisc>GitHub</a></li></ul></div></div></nav></header><main role=main><div class=container><h1>lowRISC project ideas for GSoC 2017</h1><p>lowRISC is taking part in the <a href=https://developers.google.com/open-source/gsoc/>2017 Google Summer of
Code</a> as a mentoring
organisation. See the <a href=https://developers.google.com/open-source/gsoc/timeline>full program
timeline</a> for a
run-down of key dates. Student applications are due by 4pm UTC on April 3rd.</p><p>See the <a href=https://www.lowrisc.org/docs/gsoc-2015-ideas/>2015</a> and <a href=https://www.lowrisc.org/docs/gsoc-2016-ideas/>2016</a> ideas pages for more
potential projects. If you want feedback on ideas, you&rsquo;re best posting to the
<a href=http://listmaster.pepperfish.net/cgi-bin/mailman/listinfo/lowrisc-dev-lists.lowrisc.org>lowrisc-dev mailing
list</a>.</p><h1 id=project-ideas-in-no-particular-order:7a78a27f5e9eb1d48e0c46a77bf9175d>Project ideas (in no particular order)</h1><h2 id=your-project-here:7a78a27f5e9eb1d48e0c46a77bf9175d>Your project here</h2><p>If you have a project idea relevant to lowRISC, don&rsquo;t worry that it&rsquo;s not
listed here. For a good student with an interesting project we&rsquo;ll almost
definitely have an appropriate mentor. You are strongly recommended to get in
touch either on the mailing list or directly to discuss the idea though. Some
projects might be better handled under a different mentoring organisation,
e.g. a PyPy port to RISC-V would make more sense under the Python Software
Foundation.</p><h2 id=contributions-to-compiler-testing:7a78a27f5e9eb1d48e0c46a77bf9175d>Contributions to compiler testing</h2><p><strong>Summary:</strong> Improve the state of the art in RISC-V compiler testing.</p><p>LLVM compiler tests typically involve verifying certain instruction sequences
are present in the output, i.e. don&rsquo;t involve program execution. This has
advantages, but it has the disadvantage of relying on test author writing the
test correctly in the first place. A highly ambitious way of ensuring the
generated RISC-V instructions correctly implement the semantics of the LLVM IR
would be to perform an equivalence check where feasible. A more
straight-forward approach might be to test the behaviour of the function both
<a href=https://github.com/andoma/vmir>when interpreting LLVM IR</a> and when executing
the generated RISC-V code. There is also interesting work around testing ABI
conformance, with the <a href=https://github.com/lowRISC/riscv-calling-conv-model>calling convention golden
model</a> being a first step
towards this. We would be interested in extending this work.</p><p><strong>Details:</strong></p><p><strong>Skill level:</strong> intermediate/advanced</p><p><strong>Language:</strong> C++, Python</p><p><strong>Mentor:</strong> Alex Bradbury <a href=mailto:asb@lowrisc.org>asb@lowrisc.org</a></p><h2 id=lowrisc-risc-v-in-education:7a78a27f5e9eb1d48e0c46a77bf9175d>lowRISC/RISC-V in education</h2><p><strong>Summary:</strong> Produce a simulator tool with output useful for those learning
computer architecture.</p><p>Tools like the <a href=http://courses.missouristate.edu/KenVollmar/MARS/>MARS MIPS
simulator</a> are very popular
for university-level education, giving the ability to experiment with simple
assembly programs, single step, view register values and so on. This project
would look at providing something with similar functionality for the RISC-V
ecosystem. A potential extension would be to support features unique to
lowRISC such as tagged memory. The RISC-V support in
<a href=https://github.com/s-macke/jor1k>jor1k</a> could be a starting point for a
Javascript implementation of this idea.</p><p><strong>Details:</strong></p><p><strong>Skill level:</strong> intermediate/advanced</p><p><strong>Language:</strong> Javascript, language of your choice</p><p><strong>Mentor:</strong> Alex Bradbury <a href=mailto:asb@lowrisc.org>asb@lowrisc.org</a></p><h2 id=simulated-memory-controller:7a78a27f5e9eb1d48e0c46a77bf9175d>&ldquo;Simulated&rdquo; memory controller</h2><p><strong>Summary:</strong> Provide a way to produce realistic performance numbers from FPGA.</p><p>It is a common pitfall to misinterpret or incorrectly scale performance
numbers derived from benchmarks run on an FPGA-based SoC design. The problem
is that your external memory interface is running at a very high speed
compared to the core CPU (e.g. a 25MHz core clock speed but external memory
running a several hundred MHz). This can be misleading when trying to consider
what the performance would be on an ASIC, as the CPU clock speed could be many
times higher but the memory frequency be the same or increase by a much
smaller amount. The solution is to have a simulation-ready memory controller
that will produce delays much closer to a system where the memory interface is
running at a much slower speed.</p><p><strong>Details:</strong></p><p><strong>Skill level:</strong> advanced</p><p><strong>Language:</strong> SystemVerilog or Chisel</p><h2 id=programmable-dma-engine:7a78a27f5e9eb1d48e0c46a77bf9175d>Programmable DMA engine</h2><p><strong>Summary:</strong> Implement a DMA engine using a small RISC-V core.</p><p>This project would involve looking at the feasibility of implementing a DMA
engine that executes the RISC-V instruction set. What instruction set
extensions would increase its efficiency and reduce overhead?</p><p><strong>Details:</strong></p><p><strong>Skill level:</strong> advanced</p><p><strong>Language:</strong> SystemVerilog or Chisel</p><h2 id=integrate-more-open-source-ip-for-lowrisc-on-fpgas:7a78a27f5e9eb1d48e0c46a77bf9175d>Integrate more open-source IP for lowRISC on FPGAs</h2><p><strong>Summary:</strong> Introduce open-source IP for components such as UART, SPI, and
the memory controller.</p><p>The current <a href=https://www.lowrisc.org/docs/untether-v0.2/>untethered lowRISC release</a> makes use of Xilinx IP for its memory controller, SPI controller, and
UART. Replacing these with open-source IP from OpenCores or elsewhere would
allow customisation of the whole system, and may be a useful step towards
supporting the untethered lowRISC design on Altera FPGAs. A useful starting
point would likely be to study what IP is currently available and to assess
its quality.</p><p><strong>Links:</strong></p><ul><li><a href=http://opencores.org/>OpenCores</a></li></ul><p><strong>Details:</strong></p><p><strong>Skill level:</strong> intermediate/advanced</p><p><strong>Language:</strong> Verilog/VHDL and Chisel</p><p><strong>Mentor:</strong></p><h2 id=building-a-basic-embedded-security-module:7a78a27f5e9eb1d48e0c46a77bf9175d>Building a Basic Embedded Security Module</h2><p><strong>Summary:</strong> Extend a basic microcontroller subsystems with security
extensions.</p><p>We want to explore the applicability of a secure subsystem inside the
lowRISC system-on-chip for security related tasks. The basic idea is
to have a flexible playground for security research. For example this
subsystem can be used to securely boot the system, remote attestation,
or even to provide a Trusted Execution Environment (TEE) to the user
software.</p><p>For that subsystem we start with a simple 32-bit microcontroller with
(at least) two privilege levels. The goal of this idea is to add one
of the following:</p><ul><li><p>A model for non-volatile memory and one-time programmable memory</p></li><li><p>The interfaces to other system resources: Secure communication
channel and system control interface</p></li><li><p>Integration and drivers for cryptographic accelerators</p></li><li><p>An interface that transparently encrypts bus access data</p></li></ul><p>Those are just the apparent ideas for a secure subsystem, we are open
to your own ideas!</p><p><strong>Details:</strong></p><p><strong>Skill level:</strong> intermediate/advanced</p><p><strong>Language:</strong> (System) Verilog or Chisel, C</p><p><strong>Mentor:</strong> Stefan Wallentowitz <a href=mailto:stefan@wallentowitz.de>stefan@wallentowitz.de</a></p><h2 id=implement-a-spir-v-front-end-for-nyuzi:7a78a27f5e9eb1d48e0c46a77bf9175d>Implement a SPIR-V front end for Nyuzi</h2><p><strong>Summary:</strong> Support the new SPIR-V intermediate language for the Nyuzi GPGPU.</p><p><a href=https://www.khronos.org/spir>SPIR-V</a> is an intermediate language for
parallel computation. Supporting SPIR-V on Nyuzi would allow a variety of
parallel languages to target it. There is already an LLVM back-end for Nyuzi,
so this task would consist of writing a front end that parses SPIR-V and
converts it to the LLVM intermediate code form, using Nyuzi specific
intrinsics for handling branch divergence.</p><p><strong>Links:</strong></p><ul><li><a href=https://github.com/jbush001/NyuziProcessor>Nyuzi GPGPU</a></li><li><a href=latchup.blogspot.com/2014/12/branch-divergence-in-parallel-kernels.html>A description of handling branch divergence using the Nyuzi LLVM
backend</a></li><li><a href=https://github.com/jbush001/NyuziToolchain/tree/master/tools/spmd-compile>Sample code for a parallel language front-end on
Nyuzi</a></li><li><a href=https://github.com/KhronosGroup/SPIRV-Tools>Source code for SPIR-V tools</a></li></ul><p><strong>Details:</strong></p><p><strong>Skill level:</strong> advanced</p><p><strong>Language:</strong> C++</p><h2 id=cmsis-dsp-on-pulpino:7a78a27f5e9eb1d48e0c46a77bf9175d>CMSIS-DSP on PULPino</h2><p><strong>Summary:</strong> Implement a subset of the ARM CMSIS DSP library on the Pulpino
platform</p><p>Pulpino is an open-source design containing a 32-bit RISC-V implementation
enhanced with DSP extensions. The ARM CMSIS DSP library is a set of common
signal processing functions. The implementation will consist in selecting a
reasonable subset of the library, implementing it on Pulpino, finely optimizing
it to take advantage of PULP&rsquo;s DSP extensions, and benchmarking it against
an ARM implementation on a Cortex M4. This will help measuring the impact of
the existing extensions and drive future extensions. The work could also be
extended to the parallelization of this subset on the Pulp platform.</p><p><strong>Links:</strong></p><ul><li><a href=http://www.pulp-platform.org>PULP</a></li><li><a href=http://www.keil.com/pack/doc/CMSIS/DSP/html/index.html>CMSIS-DSP</a></li></ul><p><strong>Details:</strong></p><p><strong>Skill level:</strong> intermediate</p><p><strong>Language:</strong> C</p><h3 id=open-soc-debug-nexus-trace-format:7a78a27f5e9eb1d48e0c46a77bf9175d>Open SoC Debug: Nexus Trace Format</h3><p>Trace debugging is the method to observe the execution of a
system-on-chip. lowRISC is based on the
<a href=http://opensocdebug.org>Open SoC Debug</a> project that creates open
source building blocks for a debug infrastructure, with a strong focus
on efficient trace debugging.</p><p>One of the main challenges is the transfer of trace events to the
host. On the one for efficiency and on the other hand for
compatibility.</p><p>The goal of this project is to adopt the Open SoC Debug infrastructure
to packatize traces in the popular
<a href=http://nexus5001.org/>Nexus (IEEE 5001)</a> format.</p><p><em>Skill Level</em>: Intermediate</p><p><em>Language/Tools:</em> SystemVerilog</p><p><em>Mentor:</em> <a href=mailto:stefan@wallentowitz.de>Stefan Wallentowitz</a></p><h3 id=open-soc-debug-trace-visualization-and-configuration:7a78a27f5e9eb1d48e0c46a77bf9175d>Open SoC Debug: Trace Visualization and Configuration</h3><p>The <a href=http://opensocdebug.org>Open SoC Debug</a> project creates open
source building blocks for a debug infrastructure, with a strong focus
on efficient trace debugging. The lowRISC debug infrastructure builds
on those. Currently we focus on the target (hardware) side of the
infrastructure, but want to improve the host software, especially
visualization of traces and configuration of the debug hardware.</p><p>In this project you should not reinvent the wheel, but build around
existing infrastructure. For example the
<a href=https://silc.zih.tu-dresden.de/otf2-current/html/>Open Trace Format 2</a>
and the
<a href=http://www.vi-hps.org/projects/score-p/>SCORE-P infrastructure</a> are
good starting points. For the visualization and interface building we
suggest having a look at state of the visualization tools like
<a href=https://github.com/LLNL/ravel>ravel</a> to integrate with or build a
new framework for example on <a href=http://electron.atom.io/>electron</a>.</p><p><em>Skill Level</em>: Beginner, Intermediate</p><p><em>Language/Tools</em>: C++/Java/JS</p><p><em>Mentor:</em> <a href=mailto:mail@philipp-wagner.com>Philipp Wagner</a>,
<a href=mailto:stefan@wallentowitz.de>Stefan Wallentowitz</a></p><h3 id=open-soc-debug-trace-logging-to-memory:7a78a27f5e9eb1d48e0c46a77bf9175d>Open SoC Debug: Trace Logging to Memory</h3><p>In the lowRISC (which use <a href=http://opensocdebug.org>Open SoC Debug</a>)
we currently transfer traces from the debug target to the host for
on-line visualization or offline processing. But low level traces may
be interesting even while the system-on-chip is in the field, similar
to system traces, e.g. from Linux. The idea is to write the traces to
a reserved space in the system memory and read them from the running
software.</p><p>Basically this idea involves two hardware tasks: A configuration
interface for trace logging and the interface between the debug
interconnect and the system memory. Ideally your proof-of-concept
includes a simple software. This setup can be optimized for example
with trace compression and circular buffering.</p><p><em>Skill Level</em>: Intermediate</p><p><em>Language/Tools</em>: System Verilog</p><p><em>Mentor:</em> <a href=mailto:stefan@wallentowitz.de>Stefan Wallentowitz</a></p><h3 id=port-lowrisc-to-limesdr:7a78a27f5e9eb1d48e0c46a77bf9175d>Port lowRISC to LimeSDR</h3><p><a href=https://myriadrf.org/projects/limesdr/>LimeSDR</a> is a flexible
software-defined radio platform that integrates an FPGA and a Lime
Microsystems LMS7002 field-programmable RF frontend.</p><p>The idea of this project is to port lowRISC to the FPGA of the LimeSDR
board. The major challenges are porting the most important I/O and
memory interfaces and bringing up the communication to the signal
processing blocks. If time permits, a simple wireless algorithm may be
implemented on the lowRISC-limeSDR platform.</p><p><em>Skill level</em>: Intermediate</p><p><em>Language/Tools</em>: HDL, FPGA synthesis</p><p><em>Mentor:</em> <a href=andrew@abopen.com>Andrew Back</a>,
<a href=mailto:stefan@wallentowitz.de>Stefan Wallentowitz</a></p></div></main><footer class=lr-footer><div class=container><div class=row><div class="col-lg-2 d-none d-lg-block"><img src=/img/logo/logo-dualcolor.svg width=150px></div><div class=col><p><small>The text content on this website is licensed under a <a href=https://creativecommons.org/licenses/by/4.0/>Creative Commons Attribution 4.0 International License</a>, except where otherwise noted. No license is granted for logos or other trademarks. Other content &copy; lowRISC Contributors.</small></p><p><small><a href=/privacy-policy>Privacy and cookies policy</a>
&middot; <a href=/usage-licence>Usage licence</a></small></p></div><div class=col-lg-2><p><a href=#>Back to top</a></p></div></div></div></footer><script src=/main.21c9d.js></script></body></html>