<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>lowRISC</title>
    <link>http://www.lowrisc.org/</link>
    <description>Recent content on lowRISC</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 30 Nov 2016 17:00:00 +0000</lastBuildDate>
    <atom:link href="http://www.lowrisc.org/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Fifth RISC-V Workshop: Day Two</title>
      <link>http://www.lowrisc.org/blog/2016/11/fifth-risc-v-workshop-day-two</link>
      <pubDate>Wed, 30 Nov 2016 17:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/11/fifth-risc-v-workshop-day-two</guid>
      <description>

&lt;p&gt;Today is the second day of the &lt;a href=&#34;https://riscv.org/2016/10/5th-risc-v-workshop-agenda/&#34;&gt;fifth RISC-V
workshop&lt;/a&gt;. I&amp;rsquo;ll be
keeping a semi-live blog of talks and announcements throughout the day.&lt;/p&gt;

&lt;h2 id=&#34;opensoc-system-architect-farzad-fatollahi-fard:529e3037a37627249629f6513082618e&#34;&gt;OpenSoC System Architect: Farzad Fatollahi-Fard&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Current architectures are wasteful. Only a small fraction of chip area goes
to computation.&lt;/li&gt;
&lt;li&gt;For both GoblinCore and OpenHPC, ended up doing a lot of similar work to
achieve only a point design. Why not make a generator to avoid repeating the
same steps?&lt;/li&gt;
&lt;li&gt;OpenSoC System Architect is a combination of multiple tools to form a
well-defined development flow for complex RISC-V SoCs&lt;/li&gt;
&lt;li&gt;Supports standard RISC-V modules and custom extensions&lt;/li&gt;
&lt;li&gt;It outputs pre-verified Chisel for the SoC, synthesisable Verilog, and an
LLVM compiler for the SoC&lt;/li&gt;
&lt;li&gt;OpenSoC Fabric is an open-source, flexible, parameterised NoC generator. It
integrates with a wide variety of existing processors, as well as IO devices.&lt;/li&gt;
&lt;li&gt;Created a &amp;lsquo;CoreGen&amp;rsquo; IR. It allows automatic generation of HDL
representations of the SoC and build LLVM compiler backend implementations of
the SoC and any extensions.&lt;/li&gt;
&lt;li&gt;The IR is stored on disk in well-formed XML&lt;/li&gt;
&lt;li&gt;What&amp;rsquo;s next? Better support for Chisel3, more integration with existing
RISC-V tools and environment, frontend support to import existing
Chisel/Verilog/SystemVerilog. Also want CoreGen as a standalone IR&lt;/li&gt;
&lt;li&gt;See the website at &lt;a href=&#34;http://www.opensoc.community/&#34;&gt;http://www.opensoc.community/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;v-vector-extension-proposal-krste-asanovic:529e3037a37627249629f6513082618e&#34;&gt;V Vector Extension Proposal: Krste Asanovic&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The vector extension intends to scale to all reasonable design points
(low-cost microcontroller or high-performance supercomputer). Support both
implicit auto-vectorisation and explicit SPMD&lt;/li&gt;
&lt;li&gt;Fit into the 32-bit encoding space, but be a base for future vector
extensions (e.g. crypto algorithms)&lt;/li&gt;
&lt;li&gt;The goal is to ratify a proposal 12 months from now, at the 7th workshop&lt;/li&gt;
&lt;li&gt;Cray-style vectors. &amp;ldquo;The right way&amp;rdquo; to exploit SIMD parallelism (as opposed
to the wrong way: GPUs or packed SIMD)&lt;/li&gt;
&lt;li&gt;V has an implementation-dependent vector length, meaning the same code runs
across different hardware without recompiling&lt;/li&gt;
&lt;li&gt;Each vector data register is configured with a width and type, or disabled.
There are also a configurable number of predicate registers. The maximum
vector length is a function of configuration, physical register storage, and
microarchitecture&lt;/li&gt;
&lt;li&gt;There are a number of mandatory supported types. e.g. an RV32IF system must
support X8, X16, X32, F16, F32. This means that scalar and vector half
precision floating point is a requirement if you are supporting floating
point.&lt;/li&gt;
&lt;li&gt;Each vector data register has a 4-bit field in a CSR (or multiple CSRs)
indicating its width, and another for its type.&lt;/li&gt;
&lt;li&gt;A vcfgd CSR alias is defined to allow faster writes of common vector data
configurations.&lt;/li&gt;
&lt;li&gt;Most user code would use the setvl instruction (which is actually setting a
CSR).&lt;/li&gt;
&lt;li&gt;A 16-bit+32-bit vector addition is pleasingly straight forward to specify in
assembly&lt;/li&gt;
&lt;li&gt;The architecture guarantees a minimum vector length of four regardless of
configuration. This means 1KB SRAM is required as a minimum&lt;/li&gt;
&lt;li&gt;A polymorphic instruction encoding is used. A single signed integer ADD
opcode works on different size inputs and outputs, depending on the
configuration of its inputs.&lt;/li&gt;
&lt;li&gt;There is support for vector atomics (e.g. vector fetch-and-add).&lt;/li&gt;
&lt;li&gt;For vector function calls (e.g. in auto-vectorised code) you want to make
vector calls to a function library with separate vector calling convention.
The caller has to allocate registers for the callee to use. It sets the
maximum width, allowing the callee to change the vctype as needed.&lt;/li&gt;
&lt;li&gt;For OpenCL/CUDA/SPMD, the configuration must be set at kernel launch to the
maximum width used anywhere in the call tree. It needs a general vector
function call capability with standard callee/caller save protocol&lt;/li&gt;
&lt;li&gt;Krste argues autovectorisation is much preferable to OpenCL or CUDA.&lt;/li&gt;
&lt;li&gt;Question: are you interested in smaller types (e.g. 4-bit). Answer: yes,
also interested in non-power-of-two types&lt;/li&gt;
&lt;li&gt;Question about the calling convention: the vector configuration state is
assumed to be caller-saved (including the vector register file), meaning the
scalar ABI is unmodified&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;towards-thousand-core-risc-v-shared-memory-systems-quan-nguyen:529e3037a37627249629f6513082618e&#34;&gt;Towards Thousand-Core RISC-V Shared Memory Systems: Quan Nguyen&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Tardis is a new cache coherency protocol with greater scalability than
traditional directory coherence protocols.&lt;/li&gt;
&lt;li&gt;Tardis enforces consistency through timestamps, using logical leases&lt;/li&gt;
&lt;li&gt;It only tracks the exclusive owner of any particular cache line, requiring
only O(log N) storage. No broadcast invalidations, and timestamps aren&amp;rsquo;t tied
to the core count. There is no need for synchronised real-time clocks&lt;/li&gt;
&lt;li&gt;They are building a thousand-core prototype. Fit as many cores as possible
on a ZC706 FPGA, the connect in a 3D mesh to demonstrate at scale.&lt;/li&gt;
&lt;li&gt;Want to adapt Tardis for release consistency (rather than sequential
consistency), and Quan introduces how they have started to do this by
introducing new timestamps&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;scrx-a-family-of-state-of-the-art-risc-v-synthesizable-cores-alexander-redkin:529e3037a37627249629f6513082618e&#34;&gt;SCRx: a family of state-of-the art RISC-V synthesizable cores: Alexander Redkin&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Syntacore develops and licenses energy-efficient programmable cores
implementing the RISC-V ISA&lt;/li&gt;
&lt;li&gt;SCRx is the family of RISC-V implementations, now available for evaluation.
Each core can be extended and customised&lt;/li&gt;
&lt;li&gt;The smallest core, SCR1 is less than 20kgates in a basic untethered
configuration.&lt;/li&gt;
&lt;li&gt;SCR3 is a high-performance MCU core with up to 1.7DMIPS/MHz,
3.16CoreMark/MHz.&lt;/li&gt;
&lt;li&gt;SCR4 is an MCU core with a high-performance FPU.&lt;/li&gt;
&lt;li&gt;SCR5 is an efficient mid-range embedded core. Full MMU with Linux support.
1GHz+ at 28nm, and 1.5+DMIPS/MHz per core.&lt;/li&gt;
&lt;li&gt;In the near term, want to support the latest privileged spec, adding trace
debug&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;enabling-hardware-software-co-design-with-risc-v-and-llvm-alex-bradbury:529e3037a37627249629f6513082618e&#34;&gt;Enabling hardware/software co-design with RISC-V and LLVM: Alex Bradbury&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;I&amp;rsquo;ll try and write something up for the blog later, but for now see my
slides
&lt;a href=&#34;https://speakerdeck.com/asb/software-co-design-with-risc-v-and-llvm&#34;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vm-threads-an-alternative-model-for-virtual-machines-on-risc-vm-ron-minnich:529e3037a37627249629f6513082618e&#34;&gt;VM threads: an alternative model for virtual machines on RISC-VM: Ron Minnich&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Akaros is a research kernel originally from UC Berkeley.&lt;/li&gt;
&lt;li&gt;One core idea is the &amp;lsquo;multi core process&amp;rsquo;. This can be thought of as a set
of cores assigned an entity to a program.&lt;/li&gt;
&lt;li&gt;How do VMs fit into the Akaros model. A VM could be kind of a process.&lt;/li&gt;
&lt;li&gt;Look back at how we start a process. With the introduction of fork(), it
became easy and clean. But its introduction was controversial.&lt;/li&gt;
&lt;li&gt;Virtualisation on Linux/BSD/Unix requires a device (e.g. /dev/kvm). This
typically requires daemons who are used to interact with the device. In
Akaros, they did not want to recreate this.&lt;/li&gt;
&lt;li&gt;Can we just run a virtual machine like we do a thread? Introduce
&lt;code&gt;vthread_create&lt;/code&gt;. In Akaros, they have extended the thread model to include
virtual machine threads.&lt;/li&gt;
&lt;li&gt;Virtual machine threads (vthreads) can run Linux 4.8 (with 12 lines of
patches) and any code that shares the host ring 3 address space.&lt;/li&gt;
&lt;li&gt;Ring 3 and Ring V share and address space. Ring V is limited to 2^46 bytes,
while ring 3 is in a 2^47 byte address space.&lt;/li&gt;
&lt;li&gt;VM threads are integrated tightly into the kernel.&lt;/li&gt;
&lt;li&gt;On x86, Akaros pairs page table roots and page table pages. Page table pages
are 2x4k pages, with the process PTP in the lower 4K and the VM PTP in the
upper 4K. This makes it trivial to convert the two.&lt;/li&gt;
&lt;li&gt;It is significantly easier to write virtual machine managers in Akaros than
with the Linux model&lt;/li&gt;
&lt;li&gt;Akaros VMS are unlike any other VMs - threads can easily switch from being a
VM to being a host thread&lt;/li&gt;
&lt;li&gt;Kernels also look like threads, and spinning up a core looks like CPU
hotplug, accomplished by spinning up a vthread with IP at the 64-bit entry
point.&lt;/li&gt;
&lt;li&gt;There are a variety of implications and questions for RISC-V. How will
RISC-V handle nested paging? Can we avoid massive shadow state. How about
injecting interrupts without a vmexit?&lt;/li&gt;
&lt;li&gt;RISC-V is a chance to enable software innovation. We shouldn&amp;rsquo;t get locked
into &amp;ldquo;but we&amp;rsquo;ve always done it this way&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;enabling-low-power-smartphone-like-graphical-uis-for-risc-v-socs-michael-gielda:529e3037a37627249629f6513082618e&#34;&gt;Enabling low-power, smartphone-like graphical UIs for RISC-V SoCs: Michael Gielda&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Industrial/embedded UIs mostly look bad, but also have terribly user
experience&lt;/li&gt;
&lt;li&gt;For better UIs you mostly have to jump to Android or Linux - there&amp;rsquo;s a lack
of a middle ground&lt;/li&gt;
&lt;li&gt;For a previous project, produced a mobile-like GUI experience targeting an
MCU (STM32F4).&lt;/li&gt;
&lt;li&gt;With the right approach and tools, embedded GUIs can be beautiful too&lt;/li&gt;
&lt;li&gt;Their library was written in C++, with support for layers+formats. It has
its own font engine for kerning, anti-aliasing etc.&lt;/li&gt;
&lt;li&gt;The GUI is specified in XML and has its own minimal CSS&lt;/li&gt;
&lt;li&gt;Initially developed for eCos RTOS, and has an initial port for FreeRTOS. Can
also run on Linux.&lt;/li&gt;
&lt;li&gt;To prototype on a Zynq, implemented &amp;lsquo;micro blender&amp;rsquo; for blending, filling,
scaling etc. This was written in Chisel.&lt;/li&gt;
&lt;li&gt;Software-driven IP (silicon) is possible (and advisable!)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-fast-instruction-set-simulator-for-risc-v-maxim-maslov:529e3037a37627249629f6513082618e&#34;&gt;A Fast Instruction Set Simulator for RISC-V: Maxim Maslov&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Esperanto is a stealth mode startup designing chips with RISC-V&lt;/li&gt;
&lt;li&gt;Wanted a fast RISC-V ISA simulator capable of running large applications
with minimal slowdown&lt;/li&gt;
&lt;li&gt;[Sorry folks, I had to duck out for a quick discussion - see the
&lt;a href=&#34;https://riscv.org/wp-content/uploads/2016/11/Wed1330-Fast-ISA-Simulator-for-RISC-V-Maslov-Esperanto.pdf&#34;&gt;slides&lt;/a&gt;]&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-on-rv64g-benjamin-barenblat-and-michael-pratt:529e3037a37627249629f6513082618e&#34;&gt;Go on RV64G: Benjamin Barenblat and Michael Pratt&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why RISC-V? Better architecture, lower power, faster processing, easier
accelerator development. RISC-V is not going away&lt;/li&gt;
&lt;li&gt;The Go toolchain is complex. It has its own compiler, assembler (and
assembly language), and linker&lt;/li&gt;
&lt;li&gt;Getting close, but the runtime doesn&amp;rsquo;t quite compile. Hope to get it working
in the next few months.&lt;/li&gt;
&lt;li&gt;In the mean time, relatively simple go programs will compile and run&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s been mostly good. One pain-point has been that other Go ports don&amp;rsquo;t
target architectures with good conditional branches so had to emulate a flag
register. Another gripe is that loading 64-bit constants is a pain.&lt;/li&gt;
&lt;li&gt;Within a couple of months you should be able to compile real Go programs and
have them run on RISC-V&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-java-virtual-machine-for-risc-v-porting-the-jikes-rvm-martin-maas:529e3037a37627249629f6513082618e&#34;&gt;A Java Virtual Machine for RISC-V: Porting the Jikes RVM: Martin Maas&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why do a JVM port? Both to run interesting applications, and for research
(e.g. hardware support for GCed languages)&lt;/li&gt;
&lt;li&gt;Porting OpenJDK/Hotspot for high performance, and the Jikes research VM for
academic work. This talk will focus on Jikes&lt;/li&gt;
&lt;li&gt;Jikes is itself written in Java&lt;/li&gt;
&lt;li&gt;JVMs have a large number of dependencies, so use the riscv-poky Linux
distribution generator to build a cross-compiled SDK and Linux image.&lt;/li&gt;
&lt;li&gt;While developing, add assertions everywhere to fail as early as possible&lt;/li&gt;
&lt;li&gt;Allowed the JIT to selectively emit instructions that dump trace output&lt;/li&gt;
&lt;li&gt;Booting JikesRVM is no easy task (there a &lt;em&gt;lot&lt;/em&gt; to do in order to get to
hello world)&lt;/li&gt;
&lt;li&gt;The non-optimising JIT compiler is mostly feature-complete. Passes &lt;sup&gt;65&lt;/sup&gt;&amp;frasl;&lt;sub&gt;68&lt;/sub&gt;
core tests. Targets RV64G&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Fifth RISC-V Workshop: Day One</title>
      <link>http://www.lowrisc.org/blog/2016/11/fifth-risc-v-workshop-day-one</link>
      <pubDate>Tue, 29 Nov 2016 15:10:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/11/fifth-risc-v-workshop-day-one</guid>
      <description>

&lt;p&gt;The &lt;a href=&#34;https://riscv.org/2016/10/5th-risc-v-workshop-agenda/&#34;&gt;fifth RISC-V
workshop&lt;/a&gt; is going
on today and tomorrow at the Google&amp;rsquo;s Quad Campus in Mountain View. I&amp;rsquo;ll be
keeping a semi-live blog of talks and announcements throughout the day.&lt;/p&gt;

&lt;h2 id=&#34;introduction-rick-o-connor-and-dom-rizzo:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Introduction: Rick O&amp;rsquo;Connor and Dom Rizzo&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This workshop is yet again bigger than the last. 350+ attendees, 107 companies, 29 universities.&lt;/li&gt;
&lt;li&gt;The next workshop will be May 9th-10 in Shanghai, China.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-at-uc-san-diego-michael-taylor:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;RISC-V at UC San Diego: Michael Taylor&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Startup software stacks today look a light like an iceberg. A small amount
of &amp;lsquo;value-add&amp;rsquo; at the top, and a huge stack of open source underneath.&lt;/li&gt;
&lt;li&gt;How do we build the equivalent for hardware, the fully open source ASIC
stack?&lt;/li&gt;
&lt;li&gt;Need core IP, IO pads, standard cells, PLLs, high speed I/O, tools, BGA
packages, PCB design, firmware etc&lt;/li&gt;
&lt;li&gt;basejump aims to provide a &amp;lsquo;base class&amp;rsquo; for cheap hardware development. It
includes a standard library of components, an open source package design, and
an open source motherboard&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bsg_ip_cores&lt;/code&gt; aims to be like C++ STL, but for SystemVerilog&lt;/li&gt;
&lt;li&gt;BSG Ten is a recent design featuring 10 RISC-V cores that will be taping out
before the end of the year on a TSMC shuttle run.&lt;/li&gt;
&lt;li&gt;Aim for 100% of the design will be open, including design files for the
chip, PCB, BGA package, firmware.&lt;/li&gt;
&lt;li&gt;BSG Ten has its own 5-stage RV32IM pipeline&lt;/li&gt;
&lt;li&gt;Also working on &amp;lsquo;Certus&amp;rsquo;, a 16nm TSMC design featuring Rocket cores, a
neural network accelerator, and the BSG I/O infrastructure.&lt;/li&gt;
&lt;li&gt;Suggestion: RoCC interface should be wired to the toplevel of the Rocket
hierarchy&lt;/li&gt;
&lt;li&gt;Suggestion: The RISC-V community should have at least yearly stable
end-to-end releases of full RISC-V stacks (Linux to Verilog)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;updates-on-pulpino-florian-zaruba:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Updates on PULPino: Florian Zaruba&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Imperio is the first ASIC implementation of PULPino, done in UMC 65nm.&lt;br /&gt;
Speed: 500MHz.&lt;/li&gt;
&lt;li&gt;Area is 700kGE for the SoC and 40kGE for the core (1kGE = 1.44um2).&lt;/li&gt;
&lt;li&gt;What is PULP? Parallel Ultra Low Power (platform).&lt;/li&gt;
&lt;li&gt;PULPino is a much simplified version of PULP, featuring just 1 core, reduced
interconnect and simplified cache design.&lt;/li&gt;
&lt;li&gt;Have hardware loops, post-incrementing loads and stores and SIMD instruction
extensions.&lt;/li&gt;
&lt;li&gt;Over 20 companies and research institutes are using PULPino&lt;/li&gt;
&lt;li&gt;PULPinov2 is targeted for Q12017. This features support for Verilator
simulation, IP-XACT description, new peripherals (uDMA), new streamlined event
unit, SDK, updated compiler, and improved documentation and tutorials&lt;/li&gt;
&lt;li&gt;In the future, want to work on a secure PULPino capable of running SeL4&lt;/li&gt;
&lt;li&gt;Working on a 10kGE or less RISC-V core. Evaluating 1 and 3-stage pipeline
designs.&lt;/li&gt;
&lt;li&gt;Want to explore heterogeneous configurations, featuring FPU and
accelerators.&lt;/li&gt;
&lt;li&gt;Find out more at the &lt;a href=&#34;http://www.pulp-platform.org&#34;&gt;PULP website&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sifive-fe310-and-low-cost-hifive1-development-board-jack-kang:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;SiFive FE310 and low-cost HiFive1 development board: Jack Kang&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SiFive is a fabless semiconductor company. Their business model is to build
custom SoC designs for their customers. Customers give specs and/or IP and
SiFive deliver packaged, tested chips.&lt;/li&gt;
&lt;li&gt;Although a commercial company who may offer commercial licenses, they are
committed to updating the open source rocket-chip implementation.&lt;/li&gt;
&lt;li&gt;RISC-V chips are here: the Freedom E310. This features an RV32IMAC core.&lt;br /&gt;
320MHz+ on TSMC180G. 1.61DMIPS/MHz, 16K L1 I$, 16K data scratchpad, multiple
power domains (supports low power standby). Comes in a 6x6 48-pin QFN&lt;/li&gt;
&lt;li&gt;Claim to be 9x more power efficient than Intel Quark and 2x more power
efficient than the ARM Cortex M0+.&lt;/li&gt;
&lt;li&gt;The HiFive 1 is an Arduino compatible board for this chip. The board design
and SDK is/will be open source. It&amp;rsquo;s now up on
&lt;a href=&#34;https://www.crowdsupply.com/sifive/hifive1&#34;&gt;CrowdSupply&lt;/a&gt;. $59 will get you
one board.&lt;/li&gt;
&lt;li&gt;The RTL for their implementations presented at the last RISC-V workshop are
now open source and &lt;a href=&#34;https://github.com/sifive/freedom&#34;&gt;up at GitHub&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Question: how much (ballpark) might it cost to get 100 prototype chips? For
Freedom Everywhere (microcontroller), looking at less than $100k depending on
the level of customisation needed.&lt;/li&gt;
&lt;li&gt;Question: what is the plan for getting the SiFive chips to be competitive
with the Cortex-M4 and other designs from ARM? Answer: this will come in time
with custom instructions, custom accelerators etc. The ability to customise
will result in better performance/watt than any off the shelf solution.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;rapid-silicon-prototyping-and-production-for-risc-v-socs-neil-hand:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Rapid silicon prototyping and production for RISC-V SoCs: Neil Hand&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Need to support rapid evolution of IoT designs.&lt;/li&gt;
&lt;li&gt;IoT class designs can be achieved in tens of k$.&lt;/li&gt;
&lt;li&gt;All standards based, but not open source&lt;/li&gt;
&lt;li&gt;A standard cell ASIC is typically 52-78 weeks, compared to 10 weeks for a
Baysand Metal configurable standard cell.&lt;/li&gt;
&lt;li&gt;Codasip have 3-stage and 5-stage implementations RISC-V implementations. The
slide compares gate count and frequency vs Rocket and ZScale (watch out for
the slides to be posted, I didn&amp;rsquo;t get a chance to jot down the numbers)&lt;/li&gt;
&lt;li&gt;Have a story for easy extensibility, adding new instructions and having a
new SDK etc generated.&lt;/li&gt;
&lt;li&gt;UltraSoC provides debug&lt;/li&gt;
&lt;li&gt;LLVM is the glue that holds the solution together. They generate an LLVM
compiler based on their processor model and any customer-defined extensions.&lt;/li&gt;
&lt;li&gt;A test chip will be taping out very soon. Also exploring general
availability for a dev-board&lt;/li&gt;
&lt;li&gt;They are developing their own alternative to QEMU for their customers with a
non-copyleft license.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;extending-risc-v-for-application-specific-requirements-steve-cox:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Extending RISC-V for application-specific requirements: Steve Cox&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Sometimes a pre-defined ISA is insufficient. May require an
application-optimised ISA. e.g. the Google TPU&lt;/li&gt;
&lt;li&gt;ASIP designer is a tool for automating ASIP design. The process can start
with a pre-existing example model, e..g RISC-V&lt;/li&gt;
&lt;li&gt;ASIP designer has been used in more than 250 unique SoC products&lt;/li&gt;
&lt;li&gt;The speaker gives an example of a header compression accelerator. Start with
a simple 3-stage RV32IM core. This is 24.5k gates on TSMC 28HPM at 500MHz and
32GPRs.&lt;/li&gt;
&lt;li&gt;First, consider instruction level parallelism. e.g. switching to a 2-slot
VLIW. This reduced cycle could by 21% and increased gate count by 31%.&lt;/li&gt;
&lt;li&gt;Next, try adding application-specific instructions. This reduced the code
size by 56%, cycle count by 67%, and added 9% to the gate count (compared to
the original baseline).&lt;/li&gt;
&lt;li&gt;Next, try adding a compare immediate and branch instruction. This reduces
code size by 8% and cycle count by 18% vs the previous result.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-memory-model-for-risc-v-muralidaran-vijayaraghavan:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;A memory model for RISC-V: Muralidaran Vijayaraghavan&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why not SC/TSO? Simple implementations have low performance.&lt;/li&gt;
&lt;li&gt;Why not the POWER/ARM models? Expose too many microarchitectural details and
their axiomatic models are too complex&lt;/li&gt;
&lt;li&gt;Why not RMO? The dependency requirements are too strict&lt;/li&gt;
&lt;li&gt;Want a simple specification with the inclusion of sufficient fences to force
sequential consistency behaviour when necessary&lt;/li&gt;
&lt;li&gt;Which is why they&amp;rsquo;ve introduced WMM: which has a simple operational
specification like SC, TSO.&lt;/li&gt;
&lt;li&gt;WMM introduces the conceptual device of an invalidation buffer. This holds
stale values that may be read by a future load.&lt;/li&gt;
&lt;li&gt;WMM has reconcile fences (clears the invalidation buffer) and commit fences
(flushes the store buffer).&lt;/li&gt;
&lt;li&gt;All instructions are committed in order, so stores cannot overtake loads.
This prevents &amp;lsquo;out of thin air&amp;rsquo; generation of values&lt;/li&gt;
&lt;li&gt;A write -back coherent cache hierarchy is typically global store atomic. SMT
cores with L1 write-through caches aren&amp;rsquo;t, so don&amp;rsquo;t do it.&lt;/li&gt;
&lt;li&gt;Mapping C++11 atomic operations to WMM is straight forward&lt;/li&gt;
&lt;li&gt;Question: what is the difference to the programmer vs TSO? Answer: you would
have to put a reconcile fence whenever you require load/load ordering&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-memory-consistency-model-for-risc-v-caroline-trippel:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;A Memory Consistency Model for RISC-V: Caroline Trippel&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Princeton have been working on memory consistency model verification. This
resulted in PipeCheck and CCICheck. Then implemented ArMOR, which worked to
more precisely define memory models. COATCheck looks at how e.g. instructions
that are executed as a result of page table walks interact with the memory
model. Finally, TriCheck helps to verify the lowering of e.g. C++11 atomic
constructs to the ISA level, as well as checking the ISA memory model and
hardware memory model.&lt;/li&gt;
&lt;li&gt;Have identified and characterised flaws in the current RISC-V memory model
specification (ASPLOS&amp;rsquo;17).&lt;/li&gt;
&lt;li&gt;Two broad categories of memory model relaxation. Preserved program order
(defines program orderings that hardware must preserve by default) and store
atomicity (defines the order in which stores become visible to cores).&lt;/li&gt;
&lt;li&gt;Propose tighter preserved program order and non-multi-copy store atomicity.&lt;/li&gt;
&lt;li&gt;Why allow non-multiple-copy atomic stores? Commercial ISAs e.g. ARM, Power
allow this, and RISC-V is intended to be integrated with other vendor ISAs on
a shared memory system.&lt;/li&gt;
&lt;li&gt;Want preserved program order to require same address read-read ordering&lt;/li&gt;
&lt;li&gt;Want PPO to maintain order between dependent instructions&lt;/li&gt;
&lt;li&gt;TriCheck compares high level language outcomes to ISA-level outcomes for a
spectrum of legal ISA microarchitectures&lt;/li&gt;
&lt;li&gt;The currently document RISC-V memory model lacks cumulative fences, which
are needed for C/C++ acquire/release synchronisation&lt;/li&gt;
&lt;li&gt;They have formulated an english language diff of the current spec with
proposed changes, but are also working on a formal model.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;trust-transparency-and-simplicity-eric-grosse:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Trust, transparency and simplicity: Eric Grosse&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Know your adversary. Many of them might sometimes be your partner as well as
your adversary (e.g. state actors). Notably, seems to be fairly little in the
way of advanced corporate espionage from other companies.&lt;/li&gt;
&lt;li&gt;Fix 1: secure communications. SSL, PGP etc&lt;/li&gt;
&lt;li&gt;Fix 2: authentication. e.g. two-step authentication, hardware security
devices&lt;/li&gt;
&lt;li&gt;Fix 3: stay up to date with patches&lt;/li&gt;
&lt;li&gt;The disclosure process in the hardware community is dramatically different
than software. e.g. rowhammer was known to some hardware vendors well before
the public disclosure.&lt;/li&gt;
&lt;li&gt;Long standing practitioners&amp;rsquo; wisdom: &amp;ldquo;Complexity is the enemy of security&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Modern systems aren&amp;rsquo;t just incredibly complex, they&amp;rsquo;re also largely
undocumented.&lt;/li&gt;
&lt;li&gt;A paranoid&amp;rsquo;s choice of CPU? x86 with Qubes-OS on a NUC kit. Or Coreboot,
u-root on Asus KGPE-D16 motherboard&lt;/li&gt;
&lt;li&gt;For RISC-V, you have the critical advantage of openness - be sure to keep
it. Please resist adding features lightly, or else consider removing others in
compensation. Also consider a CHERI security extension, or tagged memory&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-foundation-update-rick-o-connor:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;RISC-V Foundation update: Rick O&amp;rsquo;Connor&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Rick gives another overview of the RISC-V Foundation, and reiterates that
RISC-V is not an open source processor core but an open ISA specification. The
Foundation will encourage both open source and proprietary implementations&lt;/li&gt;
&lt;li&gt;Every year at least two RISC-V Foundation board seats will be up for
election.&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s likely the end of year workshop each year will be in Silicon Valley,
and the Spring/Summer workshop will move locations around the year&lt;/li&gt;
&lt;li&gt;The board of directors was formed in Q2 2016, and the technical and
marketing committees were formed in Q3 2016.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-marketing-committee-update-arun-thomas:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;RISC-V Marketing Committee update: Arun Thomas&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The marketing committee mission: grow RISC-V mindshare and grow the RISC-V
community&lt;/li&gt;
&lt;li&gt;Activities include organising RISC-V workshops and tutorials, and RISC-V
participation at industry events&lt;/li&gt;
&lt;li&gt;Want to help create RISC-V educational materials for industry practitioners,
researchers, and university students&lt;/li&gt;
&lt;li&gt;The marketing committee has several task groups: RISC-V workshops, outreach,
RISC-V content (creating riscv.org content and educational and marketing
materials), and member content (promoting content from RISC-V Foundation
members)&lt;/li&gt;
&lt;li&gt;David Patterson announces both of his textbooks will have RISC-V editions&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-technical-committee-update-yunsup-lee:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;RISC-V Technical Committee update: Yunsup Lee&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Immediate goals:

&lt;ul&gt;
&lt;li&gt;Maintain a roadmap of the RISC-V ISA&lt;/li&gt;
&lt;li&gt;Provide and maintain a golden simulator for the RISC-V ISA&lt;/li&gt;
&lt;li&gt;Provide and maintain a set of verification/validation tests to ensure
conformance&lt;/li&gt;
&lt;li&gt;To upstream software development tools (compiler, debugger etc)&lt;/li&gt;
&lt;li&gt;To maintain and update a list of hardware implementations of the
architecture&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Longer term goals

&lt;ul&gt;
&lt;li&gt;Establish processes to define and standardise future ISA extensions&lt;/li&gt;
&lt;li&gt;Provide guidelines for platform integration&lt;/li&gt;
&lt;li&gt;Set up program committees for future RISC-V workshops&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Task groups: opcode space management, privileged ISA specification, formal
specification, debug specification, security, vector extensions, software
toolchain&lt;/li&gt;
&lt;li&gt;By Feb, debug spec will be ratified by the foundation, calling convention
fixed and documented, ELF format fixed and documented, priv-1.10.0&lt;/li&gt;
&lt;li&gt;By November, ratify vector extension&lt;/li&gt;
&lt;li&gt;Formal specification task group: Formal models written in L3, BSV and in Coq&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;free-chips-project-yunsup-lee:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Free Chips Project: Yunsup Lee&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;A plan to launch a not-for-profit for hosting open-source RISC-V
implementations, tools, and code&lt;/li&gt;
&lt;li&gt;SiFive loves open source, believes it is essential to their mission.&lt;/li&gt;
&lt;li&gt;The rocket-chip generator has had almost 4000 commits. 40% of all commits so
far come from SiFive&lt;/li&gt;
&lt;li&gt;SiFive contributions to the rocket-chip repository are made under the Apache
v2 license.&lt;/li&gt;
&lt;li&gt;SiFive added RV32I+M/A/F support, compressed support, blocking data cache,
and data SRAM options&lt;/li&gt;
&lt;li&gt;SiFive will publish a TileLink specification&lt;/li&gt;
&lt;li&gt;SiFive recently implemented a library &amp;lsquo;Diplomacy&amp;rsquo; for parameter negotiation.
Also added multi-clock support, clock crossings, and asynchronous reset flops&lt;/li&gt;
&lt;li&gt;The SiFive blocks repository contains low-speed peripherals like SPI, UART,
PWM, GPIO, PMU. These are written in Chisel with TileLink interfaces. It also
includes wrappers for high-speed Xilinx FPGA peripherals&lt;/li&gt;
&lt;li&gt;The SiFive Freedom repository has submodules for rocket-chip and
sifive-blocks and top-level SoC integration glue code&lt;/li&gt;
&lt;li&gt;The Free Chips project has a mission to be a home for open-source codebases
to enable faster, better, cheaper chips. It will sustain and evolve
open-source software tools and HDL code for SoC design. It will ensure free
and open contributions are available to all of the SoC design community. It
will manage publicly accessible, online repositories of source code,
documentation and issues&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;128-bit-addressing-in-risc-v-and-security-steve-wallach:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;128-bit addressing in RISC-V and security: Steve Wallach&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Aim for programming generality. Might have to recompile, but don&amp;rsquo;t want to
have to restructure your software.&lt;/li&gt;
&lt;li&gt;Computer virtual addresses span to local disk only, while other identifiers
such as MACs, URLs, IPv6 are globally unique. What if one unified name
structure could be developed?&lt;/li&gt;
&lt;li&gt;RV128I strawman. 64-bits are used for an object ID, and the other 64 bits
used for a byte offset.&lt;/li&gt;
&lt;li&gt;The object ID is a software or hardware structure considered to be worthy of
a distinct name&lt;/li&gt;
&lt;li&gt;Protection and memory management are independent&lt;/li&gt;
&lt;li&gt;The machine that is simplest to program wins. User cycles are more important
than CPU cycles&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-challenges-of-securing-and-authenticating-embedded-devices-derek-atkins:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;The challenges of securing and authenticating embedded devices: Derek Atkins&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why not just use symmetric encryption e.g. AES to secure your devices? It&amp;rsquo;s
hard to deploy and it doesn&amp;rsquo;t scale (either have one key for many devices or a
database of a huge number of keys)&lt;/li&gt;
&lt;li&gt;Why do people think public key won&amp;rsquo;t work? They think it&amp;rsquo;s too big, too
slow, or too power hungry.&lt;/li&gt;
&lt;li&gt;Many of these beliefs are true, e.g. ECC execution time on Cortex-M ARM
cores is 233-1089ms. Implementations range in 8-30KB of ROM and require
800-3000B of RAM. Hardware implementations are faster, but take a lot of
gates. RSA and Diffie-Hellman are larger and take longer&lt;/li&gt;
&lt;li&gt;Fundamentally these overheads are there because a large number of 4086 bit
numbers are multiplied&lt;/li&gt;
&lt;li&gt;Group theoretic cryptography (GTC) offers a potential answer. Complexity
scales linearly with security instead of quadratically like RSA, ECC etc&lt;/li&gt;
&lt;li&gt;GTC can work with just 6-8 bit math&lt;/li&gt;
&lt;li&gt;The Ironwood Key Agreement Protocol enables two endpoints to generated a
shared secret over an open channel. The Walnut digital signature algorithm
allows one device to generate a document that is verified by another.&lt;/li&gt;
&lt;li&gt;When comparing WalnutDSA on a Rocket core, it compared very favourable to
microECC. 4.9ms run-time vs 2110ms (458ms with multiply/divide).&lt;/li&gt;
&lt;li&gt;WaltnutDSA written in RISC-V assembly achieved a 3.0ms run time&lt;/li&gt;
&lt;li&gt;The C implementation currently runs faster on the ARM Cortex-M3&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-with-sanctum-enclaves-ilia-lebedev:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;RISC-V with Sanctum Enclaves: Ilia Lebedev&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Today privilege implies trust (e.g. a hypervisor is privileged and so must
be trusted). Sanctum decouples hardware protection from trust&lt;/li&gt;
&lt;li&gt;Sanctum uses hardware-assisted isolation, offering strong privacy and
integrity with low overhead&lt;/li&gt;
&lt;li&gt;In remote software attestation, a trusted remote piece of hardware might
measure (hash) and sign the software that is running. The remote user can then
decides where to trust the certificate or not. Claim that prior work included
too much software in their attestation&lt;/li&gt;
&lt;li&gt;Intel recently introduced SGX, which allowed a process to be placed in an
enclave. It aims to protect privacy and integrity of an enclave against a
privileged software adversary. It also protects against some physical attacks,
or instance by encrypting DRAM contents&lt;/li&gt;
&lt;li&gt;There have been a number of side channel attacks demonstrated against SGX.&lt;br /&gt;
e.g. dirty bits on page tables, or cache timing attacks&lt;/li&gt;
&lt;li&gt;Sanctum aims to protect against indirect tacks (such as cache timing
attacks) as well as the direct attacks covered by SGX. It does not protect
against physical access or fault injection&lt;/li&gt;
&lt;li&gt;With Sanctum, the device manufacturer acts as a certificate authority&lt;/li&gt;
&lt;li&gt;Sanctum has a small software TCB, a ~5KLoC machine-mode security monitor&lt;/li&gt;
&lt;li&gt;The reference Sanctum implementation was built on the Rocket RISC-V
implementation&lt;/li&gt;
&lt;li&gt;Enclaves execute on private cores. i.e. it will never share L1 caches,
register, branch target buffer, TLB&lt;/li&gt;
&lt;li&gt;Sanctum also isolates physical memory. DRAM regions are defined, which are
non-overlapping regions of memory assigned to certain enclaves&lt;/li&gt;
&lt;li&gt;To isolate enclaves in the last level cache, allocate exclusively at a
region granularity (see the slides and/or the Sanctum paper for a description
of exactly how this works)&lt;/li&gt;
&lt;li&gt;To provide hardware-assisted isolation, always maintain the invariant that
entries in the TLB are safe and necessary invariants were checked while
performing the page walk&lt;/li&gt;
&lt;li&gt;Very small hardware overhead (50 gates for LLC address rotation, 600 gates
for DMA whitelist). Roughly 2% area increase in total. Roughly 6% performance
overhead in measurements&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;joined-up-debugging-and-analysis-in-the-risc-v-world-gajinder-panesar:c4d57dfb69fe6b8ac7fe4d23269f06fb&#34;&gt;Joined up debugging and analysis in the RISC-V world: Gajinder Panesar&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Need a vendor-neutral debug infrastructure, enabling access to different
proprietary debug schemes used today by various cores&lt;/li&gt;
&lt;li&gt;Need monitors into interconnects, interfaces, and custom logic which are
run-time configurable with support for cross-triggering&lt;/li&gt;
&lt;li&gt;UltraSoC provides silicon IP and tools for on-chip debug&lt;/li&gt;
&lt;li&gt;As an example, consider a software-defined radio chip. Might want to track
CPU cycles spent on compute vs cache stalls. Or you might track utilised DDR
bandwidth over time.&lt;/li&gt;
&lt;li&gt;UltraSoC monitors are non-intrusive by default&lt;/li&gt;
&lt;li&gt;Has a portfolio of 30 modules. e.g. bus monitors, communications&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generating a Gantt chart from HJSON input</title>
      <link>http://www.lowrisc.org/blog/2016/10/generating-a-gantt-chart-from-hjson-input</link>
      <pubDate>Sat, 15 Oct 2016 10:00:00 +0100</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/10/generating-a-gantt-chart-from-hjson-input</guid>
      <description>&lt;p&gt;This blog post is a slight departure from the normal topics here. Worry not,
we&amp;rsquo;ll return to discussing Verilog, Chisel, and low-level software work soon.
I wrote a quick script to help serve a need (producing a Gantt chart) and
thought perhaps others would find it useful.&lt;/p&gt;

&lt;p&gt;There are a wide range of online services to help produce and maintain Gantt
charts, but none quite offered what I was looking for. I want something open
source, easy to use, and where the underlying data is human readable and can
be version controlled. The
&lt;a href=&#34;http://xael.org/pages/python-gantt-en.html&#34;&gt;python-gantt&lt;/a&gt; library formed an
excellent starting point for generating a Gantt chart in SVG, but I thought it
was worth trying to support a slightly less verbose input format.&lt;/p&gt;

&lt;p&gt;Enter &lt;a href=&#34;http://hjson.org/&#34;&gt;hjson&lt;/a&gt;, which aims to be a superset of json with
much more forgiving syntax. This has its disadvantages, but it does seem to
work well as a concise and easy to edit data format. A quick python script to
parse an hjson input to produce a Gantt chart and we&amp;rsquo;re away. One feature I do
like is the use of &lt;a href=&#34;https://github.com/amjith/fuzzyfinder&#34;&gt;fuzzy matching&lt;/a&gt; for
project references and dependencies. Again, this makes it easy to hack on by
hand. In the example below, I&amp;rsquo;m able to use &amp;ldquo;mftr widgets&amp;rdquo; to refer to the
&amp;ldquo;Manufacture widgets&amp;rdquo; task.&lt;/p&gt;

&lt;p&gt;Example input:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
        projects: [
            {
                name: Project Alpha
                color: green
            }
        ]

        tasks: [
            {
                name: Design widget
                begin: 2016-10-14
                duration: 7,
                people: Farquaad
                project: alpha
            }
            {
                name: Set up widget production line
                begin: 2016-10-19
                duration: 6
                people: Zack
                project: alpha
            }
            {
                name: Manufacture widgets
                duration: 7
                people: Carrie
                deps: [&amp;quot;design widget&amp;quot;, &amp;quot;widget prod line&amp;quot;]
                project: alpha
            }
        ]

        milestones: [
            {
                name: Widgets start shipping
                start: 2016-10-30
                deps: [&amp;quot;mftr widgets&amp;quot;]
                project: alpha
            }
        ]
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example output (&lt;code&gt;./hjson_to_gantt --begin-date 2016-10-10 --end-date 2016-11-13 example.hjson --name example&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.lowrisc.org/blog/2016/gantt_example_weekly.png&#34; alt=&#34;Example Gantt chart&#34; style=&#34;width: 900px&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lowRISC/hjson_to_gantt&#34;&gt;hjson_to_gantt is available on Github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lowRISC&#43;IMC internship: second update</title>
      <link>http://www.lowrisc.org/blog/2016/07/lowriscimc-internship-second-update</link>
      <pubDate>Wed, 27 Jul 2016 14:23:34 +0100</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/07/lowriscimc-internship-second-update</guid>
      <description>&lt;p&gt;&lt;em&gt;This is the second update from our team of interns, comprised of four
University of Cambridge undergrads. Their work is kindly sponsored by &lt;a href=&#34;http://www.imc.nl/&#34;&gt;IMC
Financial Markets&lt;/a&gt; who are also helping to advise this
summer project.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;At the time of our &lt;a href=&#34;http://www.lowrisc.org/blog/2016/07/lowrisc-/-imc-internship-week-one---vga-output&#34;&gt;last blog post&lt;/a&gt;, we had just finished VGA and
were working on implementing the frame buffer. Over the last 2 weeks, we have
made significant progress, completing the frame buffer and starting video decode.&lt;/p&gt;

&lt;p&gt;The frame buffer was developed iteratively. Initially, it was a small Block RAM
attached to the SoC&amp;rsquo;s AXI-Lite bus. This was useful for creating a prototype,
but its limited size lead to it being replaced with an in-memory frame buffer,
supplemented with a BRAM line buffer. The end result is shown below, the
component is connected to the TileLink bus.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.lowrisc.org/blog/2016/imc_2ndupd_framebuffer.png&#34; alt=&#34;Framebuffer diagram&#34; style=&#34;width: 300px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;This component builds on the VGA controller, for which documentation will be
added shortly. We have added a data mover (a unidirectional DMA), to move data
from the in memory frame buffer into the local video memory. The video memory
acts as a line buffer, the data mover (DM) moves one line from the in-memory frame
buffer at a time. Meanwhile the VGA controller flushes the new lines to the
screen, displaying the image from memory.  The DM obeys the state machine shown
in the diagram below. The DM Controller is memory mapped, allowing the CPU to
communicate with it. Currently, it can only accept one request at a time,
further requests are ignored until the component moves back to the IDLE step.
Requests consist of source and destination addresses, and a length. A planned
extension is adding a FIFO queue to the controller to allow multiple requests
to be supported.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.lowrisc.org/blog/2016/imc_2ndupd_dm_states.png&#34; alt=&#34;Data mover state diagram&#34; style=&#34;width: 400px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;The decision was made to implement a unidirectional data mover over a more
complex and capable bidirectional DMA component as only unidirectional movement
was needed for now. Later on, we will need bidirectional access as the
video accelerator will need to write back to memory. We hope to enable
bidirectionality by simply duplicating the existing unidirectional design.&lt;/p&gt;

&lt;p&gt;Our next tasks relate to video decoding. We will be adapting a reference
MPEG-2 codec to decode video on the FPGA and adding extra components to the
SoC design to improve the performance of the codec, such as DCT and iDCT
accelerators.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Notes from the fourth RISC-V workshop</title>
      <link>http://www.lowrisc.org/blog/2016/07/notes-from-the-fourth-risc-v-workshop</link>
      <pubDate>Thu, 14 Jul 2016 16:08:07 +0100</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/07/notes-from-the-fourth-risc-v-workshop</guid>
      <description>

&lt;p&gt;Many of the lowRISC team (Robert Mullins, Wei Song, and Alex Bradbury) have
been in Boston this week for the fourth RISC-V workshop. By any measure, this
has been a massive success with over 250 attendees representing 63 companies
and 42 Universities. Wei presented our most recent work on integrating trace
debug, which you&amp;rsquo;ll soon be able to read much more about here (it&amp;rsquo;s worth
signing up to our &lt;a href=&#34;http://www.lowrisc.org/about/&#34;&gt;announcement list&lt;/a&gt; if you want to
be informed of each of our releases).&lt;/p&gt;

&lt;h2 id=&#34;risc-v-foundation-update-rick-o-connor:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;RISC-V Foundation update: Rick O&amp;rsquo;Connor&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Next RISC-V Workshop will be Nov 29th-30th at Google&amp;rsquo;s Mountain View, CA&lt;/li&gt;
&lt;li&gt;The RISC-V ISA and related standards shall remain open and license-free to
all parties, and the member agreement with RISC-V Foundation will include a
license for the trademark&lt;/li&gt;
&lt;li&gt;Trademark license for commercial use is part of being a silver, gold, or
platinum member&lt;/li&gt;
&lt;li&gt;Founding member status has now finished.&lt;/li&gt;
&lt;li&gt;You don&amp;rsquo;t have to be a member to participate in specifications - each task
group must include at least one round of public consultation.&lt;/li&gt;
&lt;li&gt;Question: any plans for workshops outside of the USA? Answer: yes, we would
like to do that&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-interrupts-krste-asanović:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;RISC-V interrupts: Krste Asanović&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Want a standard that is useful in high performance Unix-like systems (fast
cores, smart devices), low/mid embedded systems (slow cores, dumb devices),
and high-performance realtime systems (can&amp;rsquo;t waste time on interrupt overhead)&lt;/li&gt;
&lt;li&gt;Design goals: simplicity, support all kinds of platforms, allow tradeoffs
between performance and implementation cost, be flexible to support
specialised needs&lt;/li&gt;
&lt;li&gt;Interrupts are either local or global.

&lt;ul&gt;
&lt;li&gt;Local interrupts are directly connected to one hardware thread (hart) with
no arbitration. On RISC-V, there is currently only two of these: software
and timer.&lt;/li&gt;
&lt;li&gt;For global (external) interrupts, they are routed via the memory-mapped
Platform-Level Interrupt Controller (PLIC)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A new CSR, the Machine Interrupt Pending (mip) register is added. It has
separate interrupts for each supported privilege level.&lt;/li&gt;
&lt;li&gt;User-level interrupt handling is an optional feature. This may be used in
secure embedded systems.&lt;/li&gt;
&lt;li&gt;Software interrupts

&lt;ul&gt;
&lt;li&gt;MSIP (machine software interrupt) can only be written in machine mode via
a memory-mapped control register. This is used for inter-hart interrupts.
Also have HSIP, SSIP, USIP. A hart can only write its own HSIP, SSIP, USIP.&lt;/li&gt;
&lt;li&gt;The App/OS/Hypervisor can only perform inter-hart interrupts via
ABI/SBI/HBI calls&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Timer interrupts: MTIP is a single 64-bit real-time hardware timer and
comparator in M-mode. You want this because due to frequency scaling etc, just
going by cycle count is not useful. HTIP, STIP, UTIP are set up by M-mode
software.&lt;/li&gt;
&lt;li&gt;When running at a given privilege level, all interrupts for lower levels are
disabled.&lt;/li&gt;
&lt;li&gt;All interrupts trap to M-mode by default, and M-mode software can redirect
to the other privilege level as necessary. mideleg can be used to
automatically delegate interrupts to the next privilege level.&lt;/li&gt;
&lt;li&gt;Conceptually, when interrupts come in to the PLIC they are handled by the
gateway. This abstracts away differences between different interrupt sources.
e.g. level-triggered, edge-triggered etc. A new request isn&amp;rsquo;t forwarded to the
PLIC core unless the previous request&amp;rsquo;s handler has signaled completion.&lt;/li&gt;
&lt;li&gt;Each interrupt has an ID and priority. These priorities can be fixed or
variable. The PLIC stores per-target information&lt;/li&gt;
&lt;li&gt;An interrupted hart will try to claim an interrupt from the PLIC with a read
of the memory-mapped register. It could have been claimed by someone else, and
the PLIC core is responsible for ensuring the interrupts it received by only
one hart.&lt;/li&gt;
&lt;li&gt;If you want to add more levels of nested interrupt handling, add more harts
to your system.&lt;/li&gt;
&lt;li&gt;The position of the PLIC in the memory map isn&amp;rsquo;t defined by the
specification because many people will have existing memory maps.&lt;/li&gt;
&lt;li&gt;Question: would you have multiple PLICs on a multi-core system? Answer:
conceptually, there is only one PLIC though it could be implemented in a
distributed fashion.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;formal-specification-of-risc-v-uniprocessor-consistency-arvind:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;Formal specification of RISC-V uniprocessor consistency: Arvind&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Joint project with Adam Chlipala. The slogan is &amp;ldquo;chips with proofs&amp;rdquo;. These
are multicore chips that satisfy the RISC-V ISA specifications and are capable
of booting Linux.&lt;/li&gt;
&lt;li&gt;Both the design and the proofs must be modular and amenable to modular
refinement.&lt;/li&gt;
&lt;li&gt;Mostly concerned about microarchitecture and memory system correctness.&lt;/li&gt;
&lt;li&gt;Specs and designs are expressed in Bluespec.&lt;/li&gt;
&lt;li&gt;See also &lt;a href=&#34;http://plv.csail.mit.edu/kami/&#34;&gt;Kami&lt;/a&gt;, a framework for Coq for
performing proofs about Bluespec programs.&lt;/li&gt;
&lt;li&gt;A specification should avoid using concepts such as partially executed
instructions or &amp;ldquo;a store was been performed with respect to&amp;hellip;&amp;rdquo;.
Non-determinism is necessary, but unspecified behaviour should be avoided.&lt;/li&gt;
&lt;li&gt;Semantics are defined in terms of &amp;lsquo;I2E&amp;rsquo;, the Instantaneous Instruction
Execution framework. Simply, an instruction executes instantaneously ensuring
the processor state is always up to date. Data moves between processors and
memory asynchronously according to some background rules. Memory
model-specific buffers are placed between the processor state and memory.&lt;/li&gt;
&lt;li&gt;WMM is a possible memory model for RISC-V, where both loads and stores can
be re-ordered. Conceptually, invalidation buffers are added alongside the
store buffer in order to make stale values visible. Whenever a stale value is
removed from the invalidation buffer, any values that are older (more stale)
must also be removed.&lt;/li&gt;
&lt;li&gt;Memory issues arise even within a uniprocessor, due to self-modifying code
and page table access and the TLB. The fundamental issue is with multiple
paths to the same memory.&lt;/li&gt;
&lt;li&gt;Arvind is concerned that when defining formal semantics, a very weak memory
model may become very (too?) complex.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;heterogeneous-multicore-risc-v-processors-in-fd-soi-silicon-thomas-peyret:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;Heterogeneous Multicore RISC-V Processors in FD-SOI Silicon: Thomas Peyret&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Want to build a large ecosystem around FD-SOI in Europe, including IP and
chipset libraries.&lt;/li&gt;
&lt;li&gt;PULSAR is a RISC-V big.LITTLE-style heterogeneous multicore. Two small cores
(rocket without FPU, 8KB L1 caches) and two big cores (3-way super-scalar BOOM
and 32KB L1 caches). It features an AMBA interconnect generated by Synopsys
CoreAssembler and has multiple body-bias zones.&lt;/li&gt;
&lt;li&gt;Currently looking to use it in the context of a pedestrian navigation
system.&lt;/li&gt;
&lt;li&gt;128-bit link to DDR5 controller, plus 4+4GTX SERDES to a separate FPGA.&lt;/li&gt;
&lt;li&gt;Also features the AntX processor, which is a very small 32-bit RISC Harvard
design from CEA Tech.&lt;/li&gt;
&lt;li&gt;Used hardware emulation with ZeBu (Synopsys)&lt;/li&gt;
&lt;li&gt;Also used SESAM for virtual prototyping (based on SystemC/TLM 2.0). This is
up to 90% accurate compared to RTL. Have also developed SCale, a new parallel
SystemC kernel.&lt;/li&gt;
&lt;li&gt;Synthesis results show 2.64mm2, 0.6W, 700MHz.&lt;/li&gt;
&lt;li&gt;Question: will the work be open-sourced? Answer: Don&amp;rsquo;t know yet.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;nvidia-risc-v-evaluation-story-joe-xie:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;NVidia RISC-V evaluation story: Joe Xie&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Want to reproduce the existing NVIDIA falcon CPU with a new ISA&lt;/li&gt;
&lt;li&gt;Falcon - FAst Logic CONtroller. Introduced over 10 years ago and used in
more than 15 different hardware engines today. Low area, secure, flexible. 6
stage pipeline, variable length instructions (proprietary NVIDIA ISA).&lt;/li&gt;
&lt;li&gt;The next generation for Falcon is needed for higher performance and rich OS
support. Old Falcon is 0.67 DMIPS/MHz, 1.4 Coremark/Mhz&lt;/li&gt;
&lt;li&gt;Options were to buy access to a current architecture (MIPS, ARM, others) or
build (move to RISC-V or improve Falcon). Obviously, they elected to move to
RISC-V. The fact the ISA is extensible is a key advantage. Want an area of
less than 0.1mm2 at 16FF.&lt;/li&gt;
&lt;li&gt;NV-RISCV is 5 stage in-order issue, out-of-order execution. It has a
in-order write buffer. No FPU. Makes use of an MPU with base and bound
protection. It will initially be added to the Falcon as a 2nd core to provide
easy backwards compatibility.&lt;/li&gt;
&lt;li&gt;Area for 16FF: Falcon 0.03mm2 vs Rocket 0.055mm2 vs NV-RISC-V 0.05-0.06mm2.&lt;/li&gt;
&lt;li&gt;Did a lot of cache optimisations to tolerate large latency. Store buffer,
write merging, line-fill buffer, victim buffer, stream buffer.&lt;/li&gt;
&lt;li&gt;Areas of interest include toolchain (for automotive, debug, performance
tuning, flexibility, ilp32/ilp64). Also security (crypto instructions and
extensions), and adding cache manipulation instructions.&lt;/li&gt;
&lt;li&gt;Question: why design your own core rather than use an existing one? Answer:
after evaluating the options, it made the most sense. The motivation to go to
RISC-V was technical as well as influenced by cost.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;isa-shootout-a-comparison-of-risc-v-arm-and-x86-chris-celio:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;ISA Shootout – a Comparison of RISC-V, ARM, and x86: Chris Celio&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Recently released a new tech report &lt;a href=&#34;http://arxiv.org/abs/1607.02318&#34;&gt;The renewed case for the Reduced
Instruction Set Computer&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The conventional wisdom is that CISC ISAs are more expressive and dense than
RISC ISAs, while RISC ISAs map well to high-performance pipelines. Of course,
a number of designs have CISC instructions translating to RISC-like micro-ops.&lt;/li&gt;
&lt;li&gt;Chris&amp;rsquo; contention is that a well designed RISC ISA can be very competitive
with CISC ISAs. It can be denser and higher performance.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ldmiaeq sp!, {r4-r7, PC}&lt;/code&gt; is an ARMv7 instruction (load
multiple-increment-address) which will write to 7 registers and perform 6
loads. This is a common idiom for stack pop and return from a function call.&lt;/li&gt;
&lt;li&gt;Goal is to get a baseline to measure the current code generation quality of
the RISC-V gcc port. Given a fixed ISA, what can the compiler do to improve
performance? What can the programmer do? What can the micro-architect do? A
specific non-goal is to lobby for more instructions (CISC or otherwise).&lt;/li&gt;
&lt;li&gt;Dynamic instruction count can be very misleading due to the possibility it
decodes to many micro-ops. Conversely, macro-op fusion may take multiple
instructions and fuse them on the fly.&lt;/li&gt;
&lt;li&gt;Looking at 6 ISAs, using 12 benchmarks from SpecINT 2006.&lt;/li&gt;
&lt;li&gt;Average 16% more instructions for RISC-V vs x86-64, though roughly even in
terms of micro-ops. With the compressed instruction set extension, RISC-V wins
in terms of instruction bytes fetched on many of the benchmarks. Overall, 28%
fewer instruction bytes than ARMv7 and 8% fewer than x86-64.&lt;/li&gt;
&lt;li&gt;Adding array indices is the most common idiom, so why not add an indexed
load instruction to match x86? But with the compressed ISA, a pair of
compressed instructions can be treated as an indexed load by the decoder.&lt;/li&gt;
&lt;li&gt;Proposed macro-op fusion pairs: load effective address, indexed load, clear
upper word. These idioms provide 5.4% fewer &amp;ldquo;effective&amp;rdquo; instructions for RV64.&lt;/li&gt;
&lt;li&gt;Fusion isn&amp;rsquo;t just for superscalar out-of-order cores. Chris believes it
should be used by all RISC-V cores. For instance, Rocket (single issue) can be
modified to perform this.&lt;/li&gt;
&lt;li&gt;Better code generation is possible if the compiler knows fusion is
available.&lt;/li&gt;
&lt;li&gt;RISC can be denser, faster, and stay simple!&lt;/li&gt;
&lt;li&gt;Question: will compressed become standard? Answer: it may become part of the
de-facto standard or even Linux ABI standard. Still more to be done to fully
understand the complexity for processor implementations.&lt;/li&gt;
&lt;li&gt;Question: how does macro-op fusion interact with things like faults and
precise exceptions? Answer: it does add extra complexity. One solution is if
you get a fault, then re-fetch and execute without fusion.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;trace-debugging-in-lowrisc-wei-song:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;Trace debugging in lowRISC: Wei Song&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Watch this blog for much more on our trace debug work very soon.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-i-o-scale-out-architecture-for-distributed-data-analytics-mohammad-akhter:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;RISC-V I/O Scale Out Architecture for Distributed Data Analytics: Mohammad Akhter&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;For analytics, need a deep net with many nodes. This demands balanced
low-latency computing I/O, memory, and storage processing.&lt;/li&gt;
&lt;li&gt;Wireless network evolution is driven by real-time data with better QoS. Very
rapid growth rate in bandwidth and reduction in round-trip time latency for
LTE, LTE-A, 5G, &amp;hellip;&lt;/li&gt;
&lt;li&gt;Built a deep learning micro-cluster. Uses RapidIO, NVidia GPUs. No RISC-V
though. They&amp;rsquo;ve then looked at how this might look with RISC-V cores instead.&lt;/li&gt;
&lt;li&gt;Want to support AXI rand RapidIO.&lt;/li&gt;
&lt;li&gt;Produced a hardware simulation model with TileLink packet generators
producing data that is transferred over a RapidIO transport.&lt;/li&gt;
&lt;li&gt;A RISC-V CPU generator model with port for RapidIO available (where?)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;coherent-storage-the-brave-new-world-of-non-volatile-main-memory-dejan-vucinic:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;Coherent storage. The brave new world of non-volatile main memory: Dejan Vucinić&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;There are two emerging resistive non-volatile memories. ReRAM and PCM. Read
latency is orders of magnitude lower than NAND, somewhere between that of DRAM
and NAND.&lt;/li&gt;
&lt;li&gt;Should non-volatile memories be treated like memory, or like storage?&lt;/li&gt;
&lt;li&gt;For now, it seems to make sense to have the digital logic for the NVM
controller off-chip (including coherence state).&lt;/li&gt;
&lt;li&gt;Wear levelling, data protection at rest further motivate the controller
being placed along with non-volatile media.&lt;/li&gt;
&lt;li&gt;One potential approach is a coherent storage controller in reconfigurable
logic.&lt;/li&gt;
&lt;li&gt;RISC-V shopping list: Hardware coherence, fast+wide ports for peripherals to
join the coherence domain, relinquish the non-volatile memory controller for
now, and get used to high variability in main memory response time.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-as-a-basis-for-asip-design-drake-smith:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;RISC-V as a basis for ASIP design: Drake Smith&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Every design is different, so why is every embedded processor the same?&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Using RISC-V as a basis for ASIP can avoid many concerns. SecureRF produces
quantum-resistant security for low resource devices using group theoretic
cryptography.&lt;/li&gt;
&lt;li&gt;Using the Microsemi Smartfusion2+ board as the test platform.&lt;/li&gt;
&lt;li&gt;With a software-only port, their WalnutDSA was 63x faster than Micro-ECC.&lt;/li&gt;
&lt;li&gt;Adding a custom instruction to accelerate it only added 2% area on the FPGA
and gave another 3x increase in speed.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;an-updated-on-building-the-risc-v-software-ecosystem-arun-thomas:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;An updated on building the RISC-V software ecosystem: Arun Thomas&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2016 wishlist: Upstream GNU toolchain, Clang//LLVM and QEMU. Also Linux
kernel, Yocto, Gentoo, and BSD. Plus Debian/RISC-V port.&lt;/li&gt;
&lt;li&gt;Now people are getting ready to send patches for review for toolchains and
QEMU.&lt;/li&gt;
&lt;li&gt;FreeBSD 11 will officially support RISC-V. For the Debian/RISC-V port, see
Manuel&amp;rsquo;s talk tomorrow.&lt;/li&gt;
&lt;li&gt;Arun argues the Foundation should fund developers to build core software
infrastructure. Additionally, we should also decide on a process for proposing
ISA enhancements.&lt;/li&gt;
&lt;li&gt;What might funded developers do? Upstreaming and maintainership, porting
software, performance optimisation/analysis, enhancing test suites and
methodologies, continuous integration and release management.&lt;/li&gt;
&lt;li&gt;How should proposals be be handled? Various groups have approaches for this
already. e.g. Rust, Python, IEEE, IETF. Arun has put together a &lt;a href=&#34;https://github.com/arunthomas/riscv-rfcs&#34;&gt;straw-man
proposal on specification
development&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Arun would like to see the next iteration for the privileged spec to go
through a comment period.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;orca-lve-embedded-risc-v-with-lightweight-vector-extensions-guy-lemieux:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;ORCA-LVE, embedded RISC-V with lightweight vector extensions: Guy Lemieux&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Using 900LUTs for a speedup of 12x. Proposed and added a standardised vector
engine to their processor.&lt;/li&gt;
&lt;li&gt;Smallest version of the ORCA implementation can fit in 2k LUTS on the
Lattice iCE40 and runs at about 20MHz.&lt;/li&gt;
&lt;li&gt;Their approach for lightweight vector extensions is to add a dedicated
vector data scratchpad and to re-use the RISC-V ALU.&lt;/li&gt;
&lt;li&gt;Vector operands are just RISC-V scalar registers containing pointers into
the vector scratchpad.&lt;/li&gt;
&lt;li&gt;To encode vector operations, they use two 32-bit instruction bundles.&lt;/li&gt;
&lt;li&gt;To allocate vector data, just use an alternative malloc function. Intrinsics
are available to manipulate vectors.&lt;/li&gt;
&lt;li&gt;In the future, want to add 2D and 3D operations as well as subword SIMD.&lt;/li&gt;
&lt;li&gt;Why not using the proposed RISC-V vector extensions? Because the detailed
proposal isn&amp;rsquo;t yet released, and LVE intends to be more lightweight and lower
overhead.&lt;/li&gt;
&lt;li&gt;Question: can these instructions raise exceptions? Answer: that hasn&amp;rsquo;t been
properly defined yet.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;fpgarduino-a-cross-platform-risc-v-ide-for-the-masses-marko-zec:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;FPGArduino. A cross-platform RISC-V IDE for the masses: Marko Zec&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The main attraction of the Arduino IDE is simplicity and quick results&lt;/li&gt;
&lt;li&gt;Provide pre-compiled toolchains for OSX, Windows, and Linux. For C
libraries, took mainly from FreeBSD.&lt;/li&gt;
&lt;li&gt;boards.txt defines IDE menu entries and options. Also support pre-build FPGA
bitstreams and support for upload from IDE.&lt;/li&gt;
&lt;li&gt;Have produced f32c, a retargetable scalar RISC-V core written (mostly) in
VHDL.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sifive-s-risc-v-computer-jack-kang:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;SiFive&amp;rsquo;s RISC-V computer: Jack Kang&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SiFive is a fabless semiconductor company building customisable SoCs&lt;/li&gt;
&lt;li&gt;They produce a free and open platform spec for their platforms&lt;/li&gt;
&lt;li&gt;This week announced &amp;ldquo;Freedom Unleashed&amp;rdquo; (Linux application cores, high speed
peripherals), and &amp;ldquo;Freedom Everywhere&amp;rdquo; (targeted at embedded and IoT).&lt;/li&gt;
&lt;li&gt;The Freedom Unleashed demo will be shown today, running on an FPGA connected
to PCIe.&lt;/li&gt;
&lt;li&gt;Question: why 180nm for the Freedom Everywhere, isn&amp;rsquo;t it rather old now?
Answer: it is low cost and fast time to market so will make sense for some.&lt;/li&gt;
&lt;li&gt;Question: will peripherals etc be open sourced? Answer: things we do
ourselves e.g. SPI will be.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mit-s-riscy-expedition-andy-wright:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;MIT&amp;rsquo;s RISCy expedition: Andy Wright&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Build proofs from small components, build them up to complete, real
processors.&lt;/li&gt;
&lt;li&gt;They are now releasing their work, the Riscy processor library, Riscy BSV
utility library, and reference processor implementations. Currently
multi-cycle and in-order pipelined. Soon, out-of-order execution.&lt;/li&gt;
&lt;li&gt;Have infrastructure for tandem verification.&lt;/li&gt;
&lt;li&gt;How is modular design possible? RTL modules are not modularly refinable
under composition, i.e. implementation details of one module may put
additional constraints on another. But BSV language features do support
composability.&lt;/li&gt;
&lt;li&gt;The processor design flow involves taking the Riscy blocks, forming the
initial connections, performing modular refinement, and then scheduling
optimisation to reduce overheads due to BSV scheduling logic.&lt;/li&gt;
&lt;li&gt;Connectal implements the connections from FPGA to a host computer through
PCIe. This also works on Zynq FPGAs with an AXI transport.&lt;/li&gt;
&lt;li&gt;Tandem verification: run the same program on two RISC-V implementations at
once. Generated verification packets at commit stage, use non-deterministic
information from the implementation under test for synchronisation, and then
compare the results.&lt;/li&gt;
&lt;li&gt;Check out the code &lt;a href=&#34;https://github.com/csail-csg/riscy&#34;&gt;on Github&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Planned work involves formal specifications, proofs for modules, and proof
for processors.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-software-programmable-fpga-iot-platform-andrew-canis:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;A software-programmable FPGA IoT platform: Andrew Canis&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Lattice&amp;rsquo;s vision for an FPGA IoT platform is that it has high ease of use
(use C/C++ as design entry), and flexibility for a range of sensors,
actuators, communication devices.&lt;/li&gt;
&lt;li&gt;A hybrid computing solution: the RISC-V processor with FPGA hardware. RISC-V
processor plus LegUp-generated hardware acclerators to handle the processing
part of the IoT platform.&lt;/li&gt;
&lt;li&gt;The Lattice RISC-V processor has a 4 stage pipeline, and can be configured
for RV32I, RV32IM, and RV32IC. It compares favourably to the LM32, e.g. RV32IC
takes 1.6K LUTs vs 2K LUTs for the LM32 while also achieving higher DMIPS and
code density.&lt;/li&gt;
&lt;li&gt;LegUp is a high level synthesis tool.&lt;/li&gt;
&lt;li&gt;For a sum of squares of speech samples example, the LegUp synthesized
accelerator gives a 5.4x speedup vs the RISC-V software implementation.&lt;/li&gt;
&lt;li&gt;LegUp has plans to support LegUp-synthesized custom instruction
implementations&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;apache-mynewt-james-pace:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;Apache mynewt: James Pace&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mynewt.apache.org&#34;&gt;Mynewt&lt;/a&gt; is an open source OS for constrained IOT.
Supports ARM, AVR, Mips (and now RISC-V?).&lt;/li&gt;
&lt;li&gt;Apache Mynewt is &amp;ldquo;Linux&amp;rdquo; for devices that cannot run Linux.&lt;/li&gt;
&lt;li&gt;It is a community effort, run through the Apache Software Foundation.
Currently ~280k lines of code.&lt;/li&gt;
&lt;li&gt;Plans for Bluetooth 5 support in the future, deployments for industrial
wireless sensor networks.&lt;/li&gt;
&lt;li&gt;The Mynewt kernel is a pre-emptive, multi-tasking RTOS with a tickless
kernel.&lt;/li&gt;
&lt;li&gt;Question: does Mynewt support SMP? Answer: not currently.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;dsp-isa-extensions-for-an-open-source-risc-v-implementation-pulp-pasquale-davide-schiavone:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;DSP ISA extensions for an open-source RISC-V implementation (PULP): Pasquale Davide Schiavone&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;RI5CYv2 is an evolution of their RISC-V implementation. It is an RV32IMC
implementation with some PULP-specific ISA extensions to target energy
efficiency.&lt;/li&gt;
&lt;li&gt;Includes support for profiling and core execution trace.&lt;/li&gt;
&lt;li&gt;Coremark/Mhz is competitive with the ARM Cortex M4.&lt;/li&gt;
&lt;li&gt;Hardware loop instructions benefit control-intensive applications&lt;/li&gt;
&lt;li&gt;Add DSP extensions to improve energy efficiency for signal processing
algorithms. Want to execute more quickly so the core can enter a low-power
mode.&lt;/li&gt;
&lt;li&gt;RI5CYv2 adds dot product between vectors, saturation instructions, small
vector instructions, &amp;hellip; GCC support is present for these.&lt;/li&gt;
&lt;li&gt;These additional instructions give a performance increase of up to 9.5x,
6.4x on average for data-intensive kernels.&lt;/li&gt;
&lt;li&gt;The fan-out 4 of the critical path is 31. When laying out at 65nm, area is
67 kilo-gate equivalents.&lt;/li&gt;
&lt;li&gt;Released so far just 10% of what they will release in the future, so there&amp;rsquo;s
much more to come. The full PULP will be released in December, an in the
meantime you can use the PULPino core.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-dover-edge-a-metadata-enhanced-risc-v-architecture-andré-dehon:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;The DOVER Edge: A Metadata-Enhanced RISC-V Architecture: André DeHon&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;How do we handle the &amp;lsquo;edge&amp;rsquo; of a metadata tagged system? e.g. I/O to the
untagged world, legacy devices, DMA.&lt;/li&gt;
&lt;li&gt;PUMP is a metadata processing engine that checks tags upon every instruction
and memory access.&lt;/li&gt;
&lt;li&gt;For slave devices, tags can be associated with memory mapped devices. These
are used to write rules to control access. This allows giving configuration
control to particular drivers, without giving the driver control to all
devices or other privileges.&lt;/li&gt;
&lt;li&gt;DMA I/O policies might target: containment (who&amp;rsquo;s allowed to read/write a
buffer), integrity (mark incoming data as untrusted), secrecy, and
data presence/synchronisation.&lt;/li&gt;
&lt;li&gt;Add new supported opcodes as input to the PUMP representing DMA load and DMA
store. Modify PC tag and Instr tag to represent the state of the DMA and the
DMA source.&lt;/li&gt;
&lt;li&gt;If a DMA is deemed to be misbehaving, it can be totally disabled by the PUMP
or the particular operation could be discarded.&lt;/li&gt;
&lt;li&gt;In this design, there is both an IO pump and a processor PUMP. The IO pump
is pipelined so it will not reduce system throughput.&lt;/li&gt;
&lt;li&gt;The IO pump generates an interrupt on a rule miss. The miss handler uses the
same rule function as for the processor PUMP.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;improving-the-performance-per-area-factor-of-risc-v-based-multi-core-systems-tobias-strauch:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;Improving the performance-per-area factor of RISC-V based multi-core systems: Tobias Strauch&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The speaker has spent many years working on C-slow retiming&lt;/li&gt;
&lt;li&gt;System hyper pipelining is based on C-slow retiming. It replaces original
registers with memories, and adds thread stalling and bypassing features.&lt;/li&gt;
&lt;li&gt;In &amp;lsquo;deep pipelining&amp;rsquo;, run one thread in &amp;lsquo;beast mode&amp;rsquo;. Switch to another
thread if an instruction dependency is detected.&lt;/li&gt;
&lt;li&gt;Created the microRISC project, working on the V-scale design. With SHP was
able to move from 80MHz to 250MHz.&lt;/li&gt;
&lt;li&gt;miniRISC (based on lowRISC). Want to perform SHP on the Rocket core. The
speaker proposes that instead of having multiple minions you have a
hyper-pipelined core.&lt;/li&gt;
&lt;li&gt;The source code of the projects will be released in PDVL, a new language
&amp;ldquo;way better than Chisel and Bluespec Verilog(!)&amp;rdquo; that produces VHDL and
Verilog.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;working-towards-a-debian-risc-v-port-manuel-a-fernandez-montecelo:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;Working towards a Debian RISC-V port: Manuel A. Fernandez Montecelo&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Debian is a community of volunteers who care about free and open-source
software.&lt;/li&gt;
&lt;li&gt;Debian contains more than 22k source packages&lt;/li&gt;
&lt;li&gt;Debian contains a mix of officially supported ports, unofficial releases (on
Debian infrastructure but not part of the stable release process), and others
are outside of Debian infrastructure (e.g. Raspbian).&lt;/li&gt;
&lt;li&gt;Why a Debian port for RISC-V? Interested as Manuel feels affinity with the
goals of the project, previously enjoyed working with the OpenRISC port.&lt;/li&gt;
&lt;li&gt;Goal is to have a complete, fully supported, continuously updated Debian
port. The initial step is to bootstrap a viable, basic OS disk image.&lt;/li&gt;
&lt;li&gt;The chosen RISC-V target is 64-bit little endian. This is the recommended
default and what is planned for the lowRISC board.&lt;/li&gt;
&lt;li&gt;Been working on and off since November 2014. Upstreaming of toolchains etc
would be very helpful. Have now built 300-400 &amp;ldquo;essential&amp;rdquo; packages.&lt;/li&gt;
&lt;li&gt;Packages where mostly cross-compiled, with some compiled &amp;lsquo;natively&amp;rsquo; inside
emulators. Some require building multiple times to e.g. break circular
dependencies.&lt;/li&gt;
&lt;li&gt;ABI changes mean work has to restart from scratch.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;kami-a-framework-for-hardware-verification-murali-vijayaraghavan:d6abfe74eb81763dfd1b1ef050360823&#34;&gt;Kami. A framework for hardware verification: Murali Vijayaraghavan&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This work is part of the &amp;ldquo;Riscy Expedition&amp;rdquo; by MIT. Want to build chips with
proofs.&lt;/li&gt;
&lt;li&gt;Must to able to verify an optimisation is correct independent of contexts,
to enable modular verification of a full system.&lt;/li&gt;
&lt;li&gt;Kami is a DSL inside the Coq proof assistant for verifying Bluespec-style
hardware.&lt;/li&gt;
&lt;li&gt;Have finished building required theory and proof automation infrastructure.&lt;br /&gt;
Are currently working on proving a cluster of multi-cycle cores connected to a
coherent cache hierarchy implements sequential consistency.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>lowRISC / IMC internship week one - VGA output</title>
      <link>http://www.lowrisc.org/blog/2016/07/lowrisc-/-imc-internship-week-one---vga-output</link>
      <pubDate>Thu, 07 Jul 2016 14:23:34 +0100</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/07/lowrisc-/-imc-internship-week-one---vga-output</guid>
      <description>&lt;p&gt;&lt;em&gt;Begnning on Monday, June 27th, we had a team of four University of
Cambridge undergrads begin a 10 week
internship working on the lowRISC project at the Computer Laboratory,
kindly sponsored by &lt;a href=&#34;http://www.imc.nl/&#34;&gt;IMC Financial Markets&lt;/a&gt; (who are also
helping to advise this project). The team will be blogging regularly over the
course of the summer - I&amp;rsquo;ll pass over to them to introduce
themselves.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;After some initial brainstorming, we decided to aim to extend the
current lowRISC SoC design to enable video output, with the final goal of
playing video smoothly at a resolution of 640x480 on FPGA. The photo below
shows the four of us (left to right: Gary Guo, Profir-Petru Pârțachi, Alistair Fisher,
Nathanael Davison).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.lowrisc.org/blog/2016/imc_lowrisc_interns_potatocam.jpg&#34; alt=&#34;2016 lowRISC/IMC 
internship team&#34; style=&#34;width: 450px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;The final goal has been decomposed into several milestones: adding VGA
functionality to lowRISC, adding an in-memory framebuffer, implementing a
video codec for RISC-V and designing and creating a 2D accelerator to speed
up video decoding. Our plan for the augmented SoC architecture is
shown the in the diagram below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.lowrisc.org/blog/2016/imc_lowrisc_vga_diagram_week1.png&#34; alt=&#34;Drawing&#34; style=&#34;width: 650px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;In our first week, we&amp;rsquo;ve succeeded in adding VGA output to lowRISC, a
demonstration of this is shown in the video below. The demo shows lowRISC
instantiated on a Nexys4 DDR board (Artix-7) displaying a static image
that has been loaded into its BRAM. This image is read from SD card by a
bare-metal program on the RISC-V application core, which then loads it in to
the memory-mapped BRAM we hooked up to the AXI-Lite bus. The on-chip BRAM
is obviously a very limited resource, so our next step is to use the
board&amp;rsquo;s DRAM to hold the framebuffer and make use of the BRAM for a
line-buffer.&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/256wh1QOuH0&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;We aim to publish something every week, either in the form of a blog post
like this or as a more detailed guide showing how to repeat our work. Next
week we&amp;rsquo;ll share a guide on how to enable VGA in lowRISC. By the end
of the summer, as well as a working technical demo, we will also have
produced detailed documentation on the whole process of adding a
customised accelerator to lowRISC.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Announcing the LibreCores design contest and ORConf 2016</title>
      <link>http://www.lowrisc.org/blog/2016/06/announcing-the-librecores-design-contest-and-orconf-2016</link>
      <pubDate>Tue, 28 Jun 2016 15:39:34 +0100</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/06/announcing-the-librecores-design-contest-and-orconf-2016</guid>
      <description>&lt;p&gt;Our friends and collaborators at the &lt;a href=&#34;http://fossi-foundation.org/&#34;&gt;Free and Open Source Silicon
Foundation&lt;/a&gt; have launched the &lt;a href=&#34;http://librecores.org/designcontest&#34;&gt;LibreCores design
contest&lt;/a&gt;. This is a student design
contest which aims to recognise and reward contributions to the open source
hardware ecosystem. The main evaluation criteria are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Openness. Your work must be published under an established Open Source
license.&lt;/li&gt;
&lt;li&gt;Reusability. How easily can your work be used and modified by someone else?
Is it well documented? Do you plan to continue to work on your project and help
others to get started?&lt;/li&gt;
&lt;li&gt;Usefulness. Is your work filling a much-needed gap in the world of Open
Source hardware design? Something that was not there before?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;See the &lt;a href=&#34;http://librecores.org/designcontest&#34;&gt;design contest site&lt;/a&gt; for full
details. The deadline for submission is August 31st, 2016. Entrants will have
the opportunity to present their work at &lt;a href=&#34;http://openrisc.io/orconf/&#34;&gt;ORConf&lt;/a&gt;,
with some travel funding available thanks to the sponsors.&lt;/p&gt;

&lt;p&gt;This neatly leads me to the next activity I wanted to highlight in this post.
Again, thanks to the hard work of our friends at FOSSi, registration is &lt;a href=&#34;http://openrisc.io/orconf/&#34;&gt;now
open for ORConf 2016&lt;/a&gt;. To quote that page: &amp;ldquo;ORCONF
is an open source digital design and embedded systems conference, covering
areas of electronics from the transistor level up to Linux user space and
beyond.  Expect presentations and discussion on free and open source IP
projects, implementations on FPGA and in silicon, verification, EDA tools,
licensing and embedded software&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://openrisc.io/orconf/2015/&#34;&gt;Last year&amp;rsquo;s ORConf&lt;/a&gt; was the biggest and most
enthusiastic event focused on open source digital design I&amp;rsquo;ve ever been to,
and saw the birth of the FOSSi Foundation. Please do register to attend and
submit talks. With the growing interest in open source hardware and open
source digital logic design, I expect it will be even bigger and better than
last year. ORConf 2016 will be held at the University of Bologna in Italy
between October 7th and October 9th. &lt;a href=&#34;http://openrisc.io/orconf/&#34;&gt;Register
now&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lowRISC&#39;s 2016 Google Summer of Code Students</title>
      <link>http://www.lowrisc.org/blog/2016/06/lowriscs-2016-google-summer-of-code-students</link>
      <pubDate>Fri, 03 Jun 2016 12:12:49 +0100</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/06/lowriscs-2016-google-summer-of-code-students</guid>
      <description>&lt;p&gt;The 2016 Google Summer of Code is now
&lt;a href=&#34;https://developers.google.com/open-source/gsoc/timeline&#34;&gt;underway&lt;/a&gt; and we&amp;rsquo;re
delighted to be working with five students, covering a variety of interesting
projects. They have all introduced themselves over the past few weeks on &lt;a href=&#34;https://listmaster.pepperfish.net/cgi-bin/mailman/listinfo/lowrisc-dev-lists.lowrisc.org&#34;&gt;our
project mailing
list&lt;/a&gt;.
Many thanks to everyone who applied, to the mentors who volunteered, and to
Google for sponsoring this programme. If your application was unsuccessful, I
hope you&amp;rsquo;ll try again next year.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://summerofcode.withgoogle.com/organizations/6271463900315648/&#34;&gt;projects for lowRISC in the 2016
GSoC&lt;/a&gt;
are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Porting the Arduino library to RISC-V (PULPino). Mahmoud Elmohr, mentored by
Andreas Traber&lt;/li&gt;
&lt;li&gt;Implementing an open-source DDRx controller. Bittu N, mentored by Wei Song&lt;/li&gt;
&lt;li&gt;Porting Musl libc to RISC-V. Masanori Ogino, mentored by Rich Felker. See
Masanori&amp;rsquo;s &lt;a href=&#34;http://article.gmane.org/gmane.comp.hardware.lowrisc.devel/377&#34;&gt;first status
update&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Porting the OP-TEE Trusted Execution Environment to the lowRISC
platform.Rahul S Mahadev, mentored by Stefan Wallentowitz. See &lt;a href=&#34;http://mahadevrahul.blogspot.co.uk/2016/05/trusted-execution-environment-on-sel4.html&#34;&gt;Rahul&amp;rsquo;s blog
post&lt;/a&gt;
on starting this project.&lt;/li&gt;
&lt;li&gt;Porting the xv6 teaching operating system to the lowRISC platform. Jeff
Rogers, mentored by Alex Bradbury&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Apply now to work with lowRISC in Google Summer of Code</title>
      <link>http://www.lowrisc.org/blog/2016/03/apply-now-to-work-with-lowrisc-in-google-summer-of-code</link>
      <pubDate>Sun, 20 Mar 2016 20:35:57 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/03/apply-now-to-work-with-lowrisc-in-google-summer-of-code</guid>
      <description>&lt;p&gt;We are very grateful to have been selected to take part as a mentoring
organisation in the &lt;a href=&#34;https://summerofcode.withgoogle.com/&#34;&gt;Google Summer of
Code&lt;/a&gt; for the second year running. As
with last year, we&amp;rsquo;re working with a number of friends from across the wider
open source hardware community to act as an umbrella for a range of
hardware-related projects. If you are a student who would like to be paid to
work on open source during the summer, then take a look at &lt;a href=&#34;http://www.lowrisc.org/docs/gsoc-2016-ideas/&#34;&gt;the lowRISC ideas
list&lt;/a&gt; and
&lt;a href=&#34;https://summerofcode.withgoogle.com/organizations/6271463900315648/&#34;&gt;apply&lt;/a&gt;.
As was pointed out on the Google Open Source Program&amp;rsquo;s blog, there is a &lt;a href=&#34;http://google-opensource.blogspot.co.uk/2016/03/something-different-code-up-hardware-in.html&#34;&gt;good
showing from hardware-related projects in GSoC this
year&lt;/a&gt;.
The deadline for applications is this coming Friday, 25th March at 7pm GMT.&lt;/p&gt;

&lt;p&gt;We welcome ideas of your own creation, but the &lt;a href=&#34;http://www.lowrisc.org/docs/gsoc-2016-ideas/&#34;&gt;ideas we&amp;rsquo;ve suggested this
year&lt;/a&gt; include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A trace debug analysis tool (ideally using TypeScript and Electron)&lt;/li&gt;
&lt;li&gt;Improving device-tree support for the Linux RISC-V port&lt;/li&gt;
&lt;li&gt;Various ideas related to the &lt;a href=&#34;http://www.clifford.at/yosys/&#34;&gt;Yosys&lt;/a&gt;
open-source synthesis tool.&lt;/li&gt;
&lt;li&gt;Porting a teaching OS such as xv6 or XINU to the lowRISC platform&lt;/li&gt;
&lt;li&gt;Porting CMSIS-DSP to PULPino&lt;/li&gt;
&lt;li&gt;Doom on PULPino&lt;/li&gt;
&lt;li&gt;Porting the Arduino libraries to PULPino&lt;/li&gt;
&lt;li&gt;Integrating additional open-source IP for lowRISC on FPGA&lt;/li&gt;
&lt;li&gt;Implementing a Trusted Execution Environment&lt;/li&gt;
&lt;li&gt;Porting musl libc to RISC-V&lt;/li&gt;
&lt;li&gt;A Generic hardware/software interface for software-defined radio&lt;/li&gt;
&lt;li&gt;A SPIR-V frontend for Nyuzi&lt;/li&gt;
&lt;li&gt;Porting an OS kernel to Nyuzi&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Third RISC-V Workshop: Day Two</title>
      <link>http://www.lowrisc.org/blog/2016/01/third-risc-v-workshop-day-two</link>
      <pubDate>Wed, 06 Jan 2016 17:05:57 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/01/third-risc-v-workshop-day-two</guid>
      <description>

&lt;p&gt;Today is the second day of the &lt;a href=&#34;https://riscv.org/2015/12/prelim-agenda-3rd-risc-v-workshop/&#34;&gt;third RISC-V
workshop&lt;/a&gt;. Again, I&amp;rsquo;ll be keeping a
semi-live blog of talks and announcements throughout the day. See
&lt;a href=&#34;http://www.lowrisc.org/blog/2016/01/third-risc-v-workshop-day-one&#34;&gt;here&lt;/a&gt; for
notes from the first day.&lt;/p&gt;

&lt;h2 id=&#34;risc-v-asic-and-fpga-implementations-richard-herveille:541250aa31d27f4326ef7f42e9e3ae89&#34;&gt;RISC-V ASIC and FPGA implementations: Richard Herveille&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Look for freedom of design. Want to free migrate between FPGAs, structured
ASICs, standard cell ASICs&lt;/li&gt;
&lt;li&gt;Want to make it easier to migrate FPGAs to ASICs for advantages in price,
performance, power, IP protection.&lt;/li&gt;
&lt;li&gt;Roa Logic&amp;rsquo;s RV32I/64 implementations are called RV11 and RV22. RV11 is
in-order, single-issue, single thread. RV22 is in-order, dual-issue and dual
thread.&lt;/li&gt;
&lt;li&gt;Implement a &amp;lsquo;folded&amp;rsquo; optimizing 5-stage pipeline, where some classic RISC
stages are folded together for performance improvement. e.g. the instruction
decode stage decides if the instruction sequence can be optimized.&lt;/li&gt;
&lt;li&gt;Ported a debug unit for or1k from OpenCores&lt;/li&gt;
&lt;li&gt;Mostly target the eASIC nextreme platform. Start with an existing FPGA
design, then transfer.&lt;/li&gt;
&lt;li&gt;Achieved Fmax of 649MHz (32-bit core) on a nextreme-3, vs 114MHz on the customer&amp;rsquo;s
current CYCLONE-V. Achieved a 70% power reduction.&lt;/li&gt;
&lt;li&gt;Next steps are to improve resource utilization, increase offering of
extensions, and add multi-threading and multi-issue.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lowrisc-plans-for-risc-v-in-2016-alex-bradbury:541250aa31d27f4326ef7f42e9e3ae89&#34;&gt;lowRISC: plans for RISC-V in 2016: Alex Bradbury&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Find my slides
&lt;a href=&#34;https://speakerdeck.com/asb/lowrisc-plans-for-risc-v-in-2016&#34;&gt;here&lt;/a&gt;.
Apologies for not live-blogging my own talk.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-32-bit-100mhz-risc-v-microcontroller-with-10-bit-sar-adc-in-130nm-gp-elkim-roa:541250aa31d27f4326ef7f42e9e3ae89&#34;&gt;A 32-bit 100MHz RISC-V microcontroller with 10-bit SAR ADC in 130nm GP: Elkim Roa&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Current goal: a low-footprint RISC-V microcontroller like EFM32 or SAMD11
with USB low-speed PHY on-chip.&lt;/li&gt;
&lt;li&gt;Looked at picorv32 and vscale, but ultimately implemented their own
implementation. Also adding in a 10-bit SAR ADC, DAC, PLL, GPIO.&lt;/li&gt;
&lt;li&gt;Implement RV32IM using a 3-stage pipeline. IRQ handling is adapted from the
picorv32 timer.&lt;/li&gt;
&lt;li&gt;Provides AXI-4 lite and an APB bridge.&lt;/li&gt;
&lt;li&gt;SAR ADC intends to be fully synthesizable, 10-bit 10MHz.&lt;/li&gt;
&lt;li&gt;The chip was taped out in October 2015 on 130nm TSMC GP. The core+interfaces
area was 800um x 480um.&lt;/li&gt;
&lt;li&gt;Undertook a large effort on verification, implemented verification
testbenches for AXI-4 and APB peripheral functionality. Would like to partner
to get access to proven VIP.&lt;/li&gt;
&lt;li&gt;Future work to be done on a USB PHY low-speed interface, DMA channels,
watchdog timer, eNVM 1-poly ROM&lt;/li&gt;
&lt;li&gt;Question: where and when can I download it? Soon! Still cleaning it up.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;soc-for-satelline-navigation-unit-based-on-the-risc-v-single-core-rocket-chip-sergei-khabarov:541250aa31d27f4326ef7f42e9e3ae89&#34;&gt;SoC for satelline navigation unit based on the RISC-V single-core Rocket chip: Sergei Khabarov&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Currently have an RF-mezzanine card for FPGA prototypes, and
silicon-verified GNSS IP and ASIC development board with a LEON3 CPU inside.&lt;/li&gt;
&lt;li&gt;On the software, have universal receive firmware and plug-and-play support
for different targets. Plus a host application for data analysis. See
gnss-snsor.com.&lt;/li&gt;
&lt;li&gt;Now transitioning from the previous 180nm ASIC to a new 90nm chip with a
RISC-V core. The target frequency is 300MHz.&lt;/li&gt;
&lt;li&gt;The new SoC design aims to take the best ideas of the GPL-licensed grlib
library (Gaisler Research) and will be written in VHDL.&lt;/li&gt;
&lt;li&gt;Current code can be found &lt;a href=&#34;https://github.com/sergeykhbr/riscv_vhdl&#34;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Plug and play approach taken from grlib to help quickly assemble a complex
SoC design. Device ID, vendor ID, address and interrupt configuration,
cacheability etc etc routed in sideband signals accessible via a dedicated
slave device on a system bus.&lt;/li&gt;
&lt;li&gt;Some memory access optimizations have been implemented to allow access to
AXI peripherals in one clock cycle.&lt;/li&gt;
&lt;li&gt;Implemented (or implementing?) the multi-core debug protocol, potentially
supported by Trace32 (Lauterbach).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-photonic-processor-chen-sun:541250aa31d27f4326ef7f42e9e3ae89&#34;&gt;RISC-V photonic processor: Chen Sun&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Process scaling has helped massively for data transfer within a chip, but
we&amp;rsquo;ve had little improvement for moving data off-chip.&lt;/li&gt;
&lt;li&gt;The I/O wall involves being both power and pin limited. Silicon photonics
may help overcome this.&lt;/li&gt;
&lt;li&gt;Started by tring to provide DRAM connected by photonics (as part of the
DARPA POEM project).&lt;/li&gt;
&lt;li&gt;What about the foundry? Do it without a foundry. How to connect electronics
and photonics? Put them on the same chip. Where are you going to get a
processor? RISC-V!&lt;/li&gt;
&lt;li&gt;They produced it and it was published in Nature last month. Dual-core
1.65GHz RISC-V. Manufactured in a commercial SOI process.&lt;/li&gt;
&lt;li&gt;Build a waveguide with planar silicon processing. Silicon is the high-index
core. Oxides form the low-index cladding.&lt;/li&gt;
&lt;li&gt;Transmitter is driven by a CMOS logic inverter. 5Gb/s data rate at 30fj/b.&lt;/li&gt;
&lt;li&gt;Issue with ring resonators is massive variation based on process and
temperature variation. Need to stabilise this some-how. Add thermal tuning.&lt;/li&gt;
&lt;li&gt;To demonstrate the optical memory system, had a second chip emulating a DRAM
controller.&lt;/li&gt;
&lt;li&gt;We proposed an architecture, built it, and got performance competitive to
our predictions!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;untethering-the-risc-v-rocket-chip-wei-song:541250aa31d27f4326ef7f42e9e3ae89&#34;&gt;Untethering the RISC-V Rocket Chip: Wei Song&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Rocket is an open-source SoC generator from Berkeley. The base Rocket core
is a &lt;sup&gt;5&lt;/sup&gt;&amp;frasl;&lt;sub&gt;6&lt;/sub&gt; stage single-issue in-order processor.&lt;/li&gt;
&lt;li&gt;Previously an host-target interface was connected to the L2 bus which
communicates with an ARM core on the Zynq to provide peripherals.&lt;/li&gt;
&lt;li&gt;The untethered Rocket chip adds a separate I/O bus. Currently uses Xilinx IP
for peripherals. First stage bootloader is on FPGA block RAM, second stage
bootloader is loaded from SD. I/O read and write are totally uncached.&lt;/li&gt;
&lt;li&gt;The top-level (including I/O devices) is all in System Verilog. There is a
separate &amp;lsquo;Chisel island&amp;rsquo; containing the Rocket interface.&lt;/li&gt;
&lt;li&gt;The I/O and memory maps can be configured by CSRs.&lt;/li&gt;
&lt;li&gt;The first-stage bootloader copies the second stage to DRAM, performing an
uncached copy. It then remaps the DRAM to memory address 0, resets Rocket and
starts the second stage. The second stage uses a version of the Berkeley
bootloader. It starts multi-core, VM support, then loads and boots RISC-V
Linux in a virtual address space.&lt;/li&gt;
&lt;li&gt;Currently the second stage bootloader stays resident to handle HTIF
requests.&lt;/li&gt;
&lt;li&gt;Our code release contains a very detailed tutorial. Key features include
support for the Nexys4 as well as the more expensive KC705. You can also use
Verilator for simulation and a free WebPACK Vivado license.&lt;/li&gt;
&lt;li&gt;The code release includes a rewritten TileLink/NASTI interface, DDR2/3
controller, SD, UART.&lt;/li&gt;
&lt;li&gt;Future work: re-integrate tagged memory, remove HTIF from Linux kernel (help
wanted), interrupt controller, trace debugger (Stefan Wallentowitz),
run-control debug (SiFive), platform spec.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mit-s-riscy-expedition-andy-wright:541250aa31d27f4326ef7f42e9e3ae89&#34;&gt;MIT&amp;rsquo;s RISCY expedition: Andy Wright&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;MIT implemented an IMAFD 64-bit RISC-V processor in Bluespec System Verilog.
It supports machine, supervisor, and user modes, boots Linux, and has been
tandem-verified with Spike.&lt;/li&gt;
&lt;li&gt;Want to work on formal specification of the ISA, formally verified processor
implementations, memory consistency models, accelerators, microarchitecture
exploration, VLSI implementations using a standard ASIC flow.&lt;/li&gt;
&lt;li&gt;Philosophy: get a working processor first, figure out why it&amp;rsquo;s slow, and
make it faster without breaking it.&lt;/li&gt;
&lt;li&gt;Moving to work on formal verification, which requests a formal specification
for RISC-V. Lots of questions to be answered, e.g. whether referenced bits in
page table entries should be set for speculatively accessed pages.&lt;/li&gt;
&lt;li&gt;A single instruction can result in up to 13 effective memory accesses - how
do these interact with each other, and how do they influence the memory model?&lt;/li&gt;
&lt;li&gt;Want simple operational definitions where legal behaviours can be observable
on a simple abstract machine consisting of cores and a shared monolithic
memory.&lt;/li&gt;
&lt;li&gt;Looked at defining WMM, a new easy-to-specify weak consistency model.&lt;/li&gt;
&lt;li&gt;Propose there should be a new instruction similar to sfence.vm, but going in
the opposite direction.&lt;/li&gt;
&lt;li&gt;See also &lt;a href=&#34;http://csg.csail.mit.edu/riscy-e/&#34;&gt;their website&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Question: will it be open source? Concerned currently because some aspects
of the design are used as challenges for student projects and releasing it
could compromise the projects.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;pydgin-for-risc-v-a-fast-and-productive-instruction-set-simulator-berkin-ilbeyi:541250aa31d27f4326ef7f42e9e3ae89&#34;&gt;Pydgin for RISC-V, a fast and productive instruction-set simulator: Berkin Ilbeyi&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Simple interpreted instruction set simulators get 1-10MIPS of performance.
Typical dynamic binary translation may achieve 100s of MIPS, with QEMU
achieving up to 1000 MIPS.&lt;/li&gt;
&lt;li&gt;Another aspect worthy of consideration is productivity when working with the
simulator, for instance when looking to extend it to explore new hardware
features. Can you achieve high developer productivity and runtime performance?&lt;/li&gt;
&lt;li&gt;Observe there are similar productivity-performance challenges for building
high performance language runtimes as for simulators. e.g. the PyPy project.&lt;/li&gt;
&lt;li&gt;Pydgin uses PyPy&amp;rsquo;s RPython framework.&lt;/li&gt;
&lt;li&gt;Pydgin describes its own architectural description language (really a Python
DSL).&lt;/li&gt;
&lt;li&gt;Pydgin running on a standard Python interpreter gives ~100KIPS. But when
going through RPython this gives 10MIPS. When targeting the RPython JIT,
adding extra RPython JIT hints are added achieved up to a 23x performance
improvement over no annotations.&lt;/li&gt;
&lt;li&gt;Performs 2-3x better than Spike for many workloads. Spike caches decoded
instructions and uses PC-indexed dispatch to improve performance.&lt;/li&gt;
&lt;li&gt;Achieved a 100MIPS+ RISC-V port after 9 days of development.&lt;/li&gt;
&lt;li&gt;Pydgin is used in the Cornell research group to gain statistics for
software-defined regions, experimentations with data-structure specialisation,
control and memory divergence for SIMD, and more.&lt;/li&gt;
&lt;li&gt;Pydgin is &lt;a href=&#34;https://github.com/cornell-brg/pydgin&#34;&gt;online at Github&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;orca-fpga-optimized-risc-v-soft-processors-guy-lemieux:541250aa31d27f4326ef7f42e9e3ae89&#34;&gt;ORCA, FPGA-optimized RISC-V soft processors: Guy Lemieux&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ORCA is completely open-source. See it &lt;a href=&#34;https://github.com/cornell-brg/pydgin&#34;&gt;at
Github&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Initially targeted the Lattice iCE40 (3.5kLUTs, under $5 in low quantities).&lt;/li&gt;
&lt;li&gt;RV32M implemented in 2kLUTs at around 20MHz on the iCE40.&lt;/li&gt;
&lt;li&gt;ORCA is highly parameterized, ideally suitable for FPGAs, portable across
FPGA vendors, and BSD-licensed.&lt;/li&gt;
&lt;li&gt;Achieved 244MHz, 212MIPS on an Altera Stratix-V. Lots of room for further
improvements.&lt;/li&gt;
&lt;li&gt;Clock speed is close to matching the picorv32 clock speed, but with higher
DMIPS/MHz.&lt;/li&gt;
&lt;li&gt;Found 64-bit vs 32-bit counters added a lot of area.&lt;/li&gt;
&lt;li&gt;A good FPGA implementation often leads to a good ASIC implementation, but a
good ASIC implementation often leads to a poor FPGA implementation.&lt;/li&gt;
&lt;li&gt;Use dual-ported block RAMS on the FPGA for the register file.&lt;/li&gt;
&lt;li&gt;Observe that reduced register count in RV32E makes no difference for FPGAs.
Divide is very expensive.&lt;/li&gt;
&lt;li&gt;Beware when writing software, a shift could be as slow as 1b/cycle.&lt;/li&gt;
&lt;li&gt;The privileged architecture spec contains too many CSRs and the 64bit
counters are too big, putting pressure on multiplexers. For FPGAs, perhaps
defined small/med/full versions.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;pulpino-a-small-single-core-risc-v-soc-andreas-traber:541250aa31d27f4326ef7f42e9e3ae89&#34;&gt;PULPino, a small single-core RISC-V SoC: Andreas Traber&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;PULP and PULPino developed at ETH Zurich and University of Bologna with many
partners.&lt;/li&gt;
&lt;li&gt;Develop an ultra low power processor for computing IoT. Explot parallelism
using multiple small simple cores organised in clusters.&lt;/li&gt;
&lt;li&gt;Share memory within the cluster.&lt;/li&gt;
&lt;li&gt;Support near-threshold operation for very low power.&lt;/li&gt;
&lt;li&gt;PULP has been taped out over a dozen times across multiple process
technologies, down to 28nm.&lt;/li&gt;
&lt;li&gt;PULP has a large number of IPs. To start with, open source PULPino as a
starting point.&lt;/li&gt;
&lt;li&gt;PULPino is a microcontroller-style platform. No caches, no memory hierarchy,
no DMA. It re-uses IP from the PULP project and will be taped out in 65nm UMC.&lt;/li&gt;
&lt;li&gt;The boot ROM loads a program from SPI flash.&lt;/li&gt;
&lt;li&gt;Motivated to switch to RISC-V due to more modern design (no set flags, no
delay slot), compressed instructions, easily extensible.&lt;/li&gt;
&lt;li&gt;Looking to extend RISC-V with non-standard extensions for hardware loops,
post-increment load+store, multiply-accumulate, ALU extensions (min, max
absolute value).&lt;/li&gt;
&lt;li&gt;RI5CY core has full support for RV32I, implements just the mul from RV32M.
It has a 4 stage pipeline.&lt;/li&gt;
&lt;li&gt;Performed a comparison based on published Cortex M4 numbers. RI5CY is a
little faster and a little smaller.&lt;/li&gt;
&lt;li&gt;The RI5CY core itself is just 7% of the area of a PULPino SoC (assuming
32KiB instruction and data RAM).&lt;/li&gt;
&lt;li&gt;Open source release will follow shortly, including a FreeRTOS port. Using
the Solderpad license. Just awaiting final approval from the University
(expected by the end of the month).&lt;/li&gt;
&lt;li&gt;Want to port PULPino to IP-XACT. Also want to add floating point support,
branch prediction, and evaluate further non-standard ISA extensions.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-berkeley-out-of-order-machine-boom-christopher-celio:541250aa31d27f4326ef7f42e9e3ae89&#34;&gt;The Berkeley Out-of-Order Machine (BOOM): Christopher Celio&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;An out-of-order core. It&amp;rsquo;s synthesizable, parameterizable, and open-source.&lt;/li&gt;
&lt;li&gt;Out-of-order is great for tolerating variable latencies, finding
instruction-level parallelism, and working with poor compilers or lazily
written code.&lt;/li&gt;
&lt;li&gt;Downsides are it&amp;rsquo;s more complex and potentially expensive in area and power.&lt;/li&gt;
&lt;li&gt;Should work as an interesting baseline for micro-architecture research. Also
enables research that need and out of order core (e.g. on memory systems,
accelerators, VLSI methodologies).&lt;/li&gt;
&lt;li&gt;BOOM implements IMAFD and the RV64G+ privileged spec.&lt;/li&gt;
&lt;li&gt;The RISC-V ISA is easy to implement. Relaxed memory model, accrued FP
exception flags, no integer side-effects (e.g. condition codes), no cmov or
predication, no implicit register specifiers, rs1+rs2+rs3+rd are always in the
same space allowing decode and rename to proceed in parallel.&lt;/li&gt;
&lt;li&gt;As Rocket-chip gets better, so does BOOM.&lt;/li&gt;
&lt;li&gt;The host-target interface is being removed from rocket-chip to provide an
untethered system.&lt;/li&gt;
&lt;li&gt;BOOM has a unified physical register file (floating point and integer).&lt;/li&gt;
&lt;li&gt;Masses of parameters can be tweaked.&lt;/li&gt;
&lt;li&gt;2-wide BOOM with 16KiB L1 caches 1.2mm2 in TSMC 45nm. Can clock at 1.5GHz
for two-wide.&lt;/li&gt;
&lt;li&gt;Currently designed for single-cycle SRAM access as the critical path.&lt;/li&gt;
&lt;li&gt;Planning on a tapeout later this year.&lt;/li&gt;
&lt;li&gt;Achieve 50MHz on an FPGA where the bottleneck is the FPGA tools can&amp;rsquo;t
register-rename the FPU.&lt;/li&gt;
&lt;li&gt;BOOM is 9kloc, plus 11kloc from Rocket.&lt;/li&gt;
&lt;li&gt;9% CoreMarks/MHz for ARM Cortex-A9 with similar architectural parameters and
smaller (but lacking the NEON unit). Power is also similar based on public
numbers.&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t yet have a SPEC score. Need more DRAM on the FPGA and DRAM emulation.
With a cluster of FPGAs, this should only take about a day to run.&lt;/li&gt;
&lt;li&gt;BOOM-chip is currently a branch of rocket-chip. See the slides for how to
get going.&lt;/li&gt;
&lt;li&gt;Currently test/verify using riscv-tests, coremark, spec, and the
riscv-torture tool.&lt;/li&gt;
&lt;li&gt;riscv-torture, a randomised test generator was open-sourced yesterday. If it
finds a bug, it will minimise the program for you.&lt;/li&gt;
&lt;li&gt;A design document is a work in progress up on github.com/ccelio (doesn&amp;rsquo;t
seem to be published yet?)&lt;/li&gt;
&lt;li&gt;Want to grow a community of &amp;ldquo;baby BOOMers&amp;rdquo; :)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;bluespec-s-risc-v-factory-rishiyur-nikhil:541250aa31d27f4326ef7f42e9e3ae89&#34;&gt;Bluespec&amp;rsquo;s &amp;ldquo;RISC-V Factory&amp;rdquo;: Rishiyur Nikhil&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Bluespec&amp;rsquo;s &amp;lsquo;RISC-V Factory&amp;rsquo; is aimed at organisations who want to create
their own RISC-V based CPUs or SoCs without the usual learning curve, startup
costs, and ownership costs.&lt;/li&gt;
&lt;li&gt;Currently working with Draper on the DOVER project we&amp;rsquo;ll be hearing about in
the next talk.&lt;/li&gt;
&lt;li&gt;The Flute RISC-V CPU has interfaces for direct GDB control, an elastic
(latency-insensitive) pipeline, hooks for optional tagged data.&lt;/li&gt;
&lt;li&gt;Have components such as interconnect, memory controller, DMA engine,
devices. Working on flash for booting and Ethernet.&lt;/li&gt;
&lt;li&gt;Provide a complete development and verification environment.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;dover-a-metadata-extended-risc-v-andre-dehon:541250aa31d27f4326ef7f42e9e3ae89&#34;&gt;DOVER, a metadata-extended RISC-V: Andre DeHon&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Current computer systems are insecure, and the processor architecture
contributes by blinding running code and making the secure and safe thing
expensive.&lt;/li&gt;
&lt;li&gt;Add software defined metadata processing as implemented in PUMP.&lt;/li&gt;
&lt;li&gt;Give each word a programmable tag. This is indivisible from a word and its
interpretation is programmable.&lt;/li&gt;
&lt;li&gt;PUMP is a function from (Opcode, PCtag, Instrtag, RS1tag, RS2tag, MRtag) to
(Allowed?, PCtag, Resulttag).&lt;/li&gt;
&lt;li&gt;Possible policies include access control, types, fine-grained instruction
permissions, memory safety, control flow integrity, taint tracking and
information flow control.&lt;/li&gt;
&lt;li&gt;Rules are installed by software on PUMP misses. This demands metadata
structures be immutable.&lt;/li&gt;
&lt;li&gt;A metadata tag can be a pointer, meaning it can point to a data structure of
arbitrary size.&lt;/li&gt;
&lt;li&gt;Can support composite policies. i.e. no limit of only one policy at once.&lt;/li&gt;
&lt;li&gt;There are no instructions to read or write metadata, i.e. no set-tag or read
tag. All tag manipulation is done through the PUMP.&lt;/li&gt;
&lt;li&gt;In RISC-V use PUMP CSRs for rule inputs and outputs.&lt;/li&gt;
&lt;li&gt;Compared to lowRISC: lowRISC has a limited number of tag bits, tags are
accessible to user code. Good for self-protection safety but argue it&amp;rsquo;s not
adequate to enforce policies against malicious code (i.e. code actively trying
to circumvent protection).&lt;/li&gt;
&lt;li&gt;Compare to Oracle M7. M7 has a limited number of colors and a fixed policy.&lt;/li&gt;
&lt;li&gt;Have some global tags and rules so they have the same meaning across
different processes.&lt;/li&gt;
&lt;li&gt;Idiosyncrasies about RISC-V: one instruction uses RS3, sparse opcode space
increases table size, multiple instructions per machine word (policies want
tagged instructions)&lt;/li&gt;
&lt;li&gt;Draper plans to make available Bluespec RISC-V and metadata changes, PUMP,
set of basic micropolicies, runtime support and tools all under open source
licenses.&lt;/li&gt;
&lt;li&gt;Building a consortium around Dover, an &amp;ldquo;Inherently Secure Processing Hive&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Question: what is the overhead? Don&amp;rsquo;t have figures yet for RISC-V. From
previous work, have 10% area overhead and twice the area, 60% energy overhead.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Third RISC-V Workshop: Day One</title>
      <link>http://www.lowrisc.org/blog/2016/01/third-risc-v-workshop-day-one</link>
      <pubDate>Tue, 05 Jan 2016 17:35:57 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/01/third-risc-v-workshop-day-one</guid>
      <description>

&lt;p&gt;The &lt;a href=&#34;https://riscv.org/2015/12/prelim-agenda-3rd-risc-v-workshop/&#34;&gt;third RISC-V workshop&lt;/a&gt; is going
on today and tomorrow at the Oracle Conference Center, California. I&amp;rsquo;ll be
keeping a semi-live blog of talks and announcements throughout the day. See
&lt;a href=&#34;http://www.lowrisc.org/blog/2016/01/third-risc-v-workshop-day-two&#34;&gt;here&lt;/a&gt; for
notes from the second day.&lt;/p&gt;

&lt;h2 id=&#34;introductions-and-risc-v-foundation-overview-rick-o-connor:404bdd89395af7de00a88d5e9af98f5d&#34;&gt;Introductions and RISC-V Foundation Overview: Rick O&amp;rsquo;Connor&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Save the date, the 4th RISC-V workshop will be July 12th-13th at the MIT
CSAIL/Stata Center.&lt;/li&gt;
&lt;li&gt;In August 2015, articles of incorporation were filed to create a non-profit
RISC-V Foundation to govern the ISA.&lt;/li&gt;
&lt;li&gt;RISC-V Foundation mission statement: The RISC-V Foundation is a non-profit
consortium chartered to standardize, protect, and promote the free and open
RISC-V instruction set architecture together with its hardware and software
ecosystem for use in all computing devices.&lt;/li&gt;
&lt;li&gt;The RISC-V ISA and related standards shall remain open and license-free to
all parties.&lt;/li&gt;
&lt;li&gt;The compatibility test suites shall always be publicly available as a source
code download.&lt;/li&gt;
&lt;li&gt;To protect the standard, only members (with commercial RISC-V products) of
the Foundation in good standing can use &amp;ldquo;RISC-V&amp;rdquo; and associated trademarks,
and only for devices that pass the tests in the open-source compatibility
suites maintained by the Foundation.&lt;/li&gt;
&lt;li&gt;Drafting a new license for the ISA &amp;lsquo;combining the best of BSD, GPL and so
on&amp;rsquo;.&lt;/li&gt;
&lt;li&gt;The Foundation will have a board of 7 directors elected by the members. All
members of committees must be members of the RISC-V Foundation.&lt;/li&gt;
&lt;li&gt;All details of the foundation are a work in progress. Feedback is welcome!&lt;/li&gt;
&lt;li&gt;16 member companies so far. Bluespec, Draper, Google, Hewlett Packard Labs,
Microsemi, Oracle, SiFive, antmicro, codasip, Gray Research, Lattice
Semiconductor, lowRISC, ROA logic, Rumble Development, Syntacore, Technolution&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-updates-krste-asanovic:404bdd89395af7de00a88d5e9af98f5d&#34;&gt;RISC-V Updates: Krste Asanovic&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The 1.9 version of the compressed extension is on track to become frozen and
become blessed as v2.0. Now is the time to speak up if you have any feedback
or concerns!&lt;/li&gt;
&lt;li&gt;Privileged architecture 1.7 was released in May 2015 and has received a lot
of feedback. Hope to release an updated draft addressing feedback in the next
month or two. Doubt it will really settle down before the summer, as it needs
more OS and driver development against it.&lt;/li&gt;
&lt;li&gt;&amp;lsquo;V&amp;rsquo; Vector Extension: not yet ready to release a draft for this workshop,
but the RTL of the HWacha vector coprocessor has been open-sourced along with
3 tech-reports.&lt;/li&gt;
&lt;li&gt;Hwacha is NOT the V extensions. It&amp;rsquo;s a research project designed to push the
limits of in-order decoupled data-parallel accelerators (e.g. GPUs). The
microarchitecture does demonstrate some of the ideas that will appear in V.&lt;/li&gt;
&lt;li&gt;Ongoing ISA research at UCB: virtual local store (VLS, Henry Cook&amp;rsquo;s 2009
master&amp;rsquo;s thesis) and user-level DMA (copying data between DRAM and VLS
directly).&lt;/li&gt;
&lt;li&gt;New Berkeley open-source cores: BOOM out-of-order implementation and V-Scale
(verilog implementation of Z-Scale).&lt;/li&gt;
&lt;li&gt;RISC-V is being transitioned out of Berkeley. This involves upstreaming of
tools and the RISC-V Foundation taking over the standards process.&lt;/li&gt;
&lt;li&gt;SiFive has been founded by some of the lead RISC-V developers (Krste
Asanovic, Yunsup Lee, Andrew Waterman). Sutter Hill Ventures have invested.&lt;/li&gt;
&lt;li&gt;Most urgent outstanding issues: holes and ambiguities in the specification
and the platform specification.&lt;/li&gt;
&lt;li&gt;Holes in the spec: floating-point NaNs (resolved and updated), CSR
read/write semantics (resolved, updated spec), memory model (far from
resolved), Hypervisor support (no proposal). A formal spec of the whole ISA
and memory model is desired.&lt;/li&gt;
&lt;li&gt;Although RISC-V was designed in reusable layers, some concrete standards for
hardware platforms are desirable e.g. memory maps, interrupt controller, power
management. To what extent can platform specs be shared across
microcontroller-class, application cores, and rack-scale designs?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-external-debug-aka-jtag-debugging-tim-newsome:404bdd89395af7de00a88d5e9af98f5d&#34;&gt;RISC-V External Debug (aka JTAG debugging): Tim Newsome&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Goals: a debug system that works for everybody with a working system done by
July 1st 2016.&lt;/li&gt;
&lt;li&gt;The specification will be submitted to the RISC-V Foundation and there are
plans for an open source release of the debugger and implementations for
Rocket and Z-Scale.&lt;/li&gt;
&lt;li&gt;Status: the specification is mostly complete.&lt;/li&gt;
&lt;li&gt;Features: (many, see the slides). Interested in tracing core execution to on
or off-chip RAM and providing a framework to debug any component on the
system, not just the RISC-V cores.&lt;/li&gt;
&lt;li&gt;The debug transport module provides access to the system bus. It implements
a message queue and optional authentication.&lt;/li&gt;
&lt;li&gt;New CSRs will be added and exposed on the system bus.&lt;/li&gt;
&lt;li&gt;The spec describes a small amount of debug memory (1KiB ROM) and 8-16 bytes
of RAM. This memory is not cached and is shared between all cores.&lt;/li&gt;
&lt;li&gt;Up to 4095 hardware breakpoints supported (but 4 is more typical). Each may
support exact address match, address range match, exact data match, data range
match, &amp;hellip;&lt;/li&gt;
&lt;li&gt;The work-in-progress spec will be posted to the hw-dev RISC-V mailing list
later today. Comments very welcome.&lt;/li&gt;
&lt;li&gt;Question: how does this map to gdb&amp;rsquo;s capabilities? Are there things it can
do but gdb can&amp;rsquo;t or vice-versa? It&amp;rsquo;s not a 1:1 match but should be a superset
of what gdb can do.&lt;/li&gt;
&lt;li&gt;Question: how does the tracing scale? Hasn&amp;rsquo;t be investigated yet.&lt;/li&gt;
&lt;li&gt;Question: will support be integrated into the BOOM codebase? Answer: not
currently planned.&lt;/li&gt;
&lt;li&gt;Question: there&amp;rsquo;s a wide spectrum of functionality that different
implementations could implement. Is there a discovery mechanism for the
functionality that is supported? Yes.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-in-axiom-michael-gielda:404bdd89395af7de00a88d5e9af98f5d&#34;&gt;RISC-V in Axiom: Michael Gielda&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Axiom is a fully open source 4K film camera design. It is an EU Horizon 2020
project with multiple partners.&lt;/li&gt;
&lt;li&gt;Aim of Axiom is to create an extensible open source platform that is also a
desirable project in itself. The aim is to open up what is currently a fairly
closed industry and lower barriers of entry to new players. There is an
obvious parallel to the RISC-V and lowRISC projects.&lt;/li&gt;
&lt;li&gt;Chose the largest Zynq FPGA that had zero-cost tool support to maximise the
number of people who can hack on the design.&lt;/li&gt;
&lt;li&gt;Using the Z-Scale as a soft-core for communication between the FPGA
pre-processing board (Kintex-7) and the FPGA SoC main board with a dual-core
Cortex-A9 (Zynq 7030).&lt;/li&gt;
&lt;li&gt;Long-term goals are to ensure the design can be reused through
parameterisation, and look at broadening adoption of the Chisel design
methodology.&lt;/li&gt;
&lt;li&gt;The Axiom Gamma project is almost half-way done. There will be an EU
technical review in March at which point it should be working.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;emulating-future-hpc-soc-architectures-using-risc-v-farzad-fatollahi-fard:404bdd89395af7de00a88d5e9af98f5d&#34;&gt;Emulating future HPC SoC architectures using RISC-V: Farzad Fatollahi-Fard&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Should HPC take inspiration from the embedded market?&lt;/li&gt;
&lt;li&gt;Is building an SoC for HPC a good idea? HPC is power limited
(performance/Watt) which arguably means HPC and embedded requirements are
aligned.&lt;/li&gt;
&lt;li&gt;From a previous project case study (Green Wave), they found an embedded SoC
design was performance/power competitive with Fermi. This had a 12x12 2D
on-chip torus network with 676 compute cores, 33 supervisor cores, 1 PCI
express interface, 8 Hybrid Memory Cube interfaces, &amp;hellip;&lt;/li&gt;
&lt;li&gt;Proposed an FPGA-implemented SoC for HPC. This contains 4 Z-scale processors
with a 2x2 concentrated mesh with 2 virtual channels. The Z-Scale was chosen
for area-efficiency on FPGA.&lt;/li&gt;
&lt;li&gt;The network is implemented using the &lt;a href=&#34;https://github.com/LBL-CoDEx/OpenSoCFabric&#34;&gt;OpenSoC
fabric&lt;/a&gt; (open source and in
chisel). AHB endpoints have now beed added and AXI is in-development.&lt;/li&gt;
&lt;li&gt;A 96-core system was constructed using multiple FPGAs.&lt;/li&gt;
&lt;li&gt;For more info, see &lt;a href=&#34;http://www.codexhpc.org/&#34;&gt;CoDEx HPC&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;grvi-phalanx-a-massively-parallel-risc-v-fpga-accelerator-jan-gray:404bdd89395af7de00a88d5e9af98f5d&#34;&gt;GRVI Phalanx. A massively parallel RISC-V FPGA accelerator: Jan Gray&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;GRVI is pronounced &amp;lsquo;groovy&amp;rsquo;.&lt;/li&gt;
&lt;li&gt;There&amp;rsquo;s lots of interest in FPGA accelerators right now (Altera acquisition,
MSR&amp;rsquo;s catapult).&lt;/li&gt;
&lt;li&gt;FPGAs are an interesting platform. Massively parallel. Specialized.
Connected. High throughput. Low latency. The big barrier is of course porting
your software. Jan argues OpenCL for FPGAs is a major breakthrough for this
problem, if you&amp;rsquo;re lucky enough to have an application that can be expressed
in OpenCL.&lt;/li&gt;
&lt;li&gt;Phalanx is an accelerator accelerator - an infrastructure making it easier
to run you application on an FPGA and connect everything together. It is
composed of processor+accelerator clusters+NoC.&lt;/li&gt;
&lt;li&gt;Jan&amp;rsquo;s Razor: &amp;ldquo;In a CMP, cut inessential resources from each CPU, to maximize
CPUs per die.&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Jan has achieved an RV32I datapath in about 250 LUTs. This core can achieve
300-375MHz, 1.3-1.6CPI. The &amp;lsquo;GRVI&amp;rsquo; core is ~320 6-LUTs so &amp;ldquo;1 MIPS/LUT&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;How many can you fit on a modern FPGA? The limiting resource is really the
block RAMs. In a cluster, two processing elements can share an instruction
BRAM, and all PEs can share a cluster memory.&lt;/li&gt;
&lt;li&gt;How should the clusters be interconnected? A 5-port virtual channel router
might be a sensible choice in an ASIC, but does not map well to an FPGA.
Instead use a &lt;a href=&#34;http://fpga.org/2015/09/03/introducing-hoplite/&#34;&gt;Hoplite&lt;/a&gt; 2D
router. This is only 1% of the area x delay product of FPGA-optimized VC
routers. Each cluster has a 300 bit connection to the Hoplite router (with a
256bit payload).&lt;/li&gt;
&lt;li&gt;400 of the GRVI Phalanx PEs can fit on a Xilinx KU040. The amortized cost of
the router per processor is only 40 LUTs.&lt;/li&gt;
&lt;li&gt;Can fit 32 GRVI Phalanx PEs on an Artix-7-35T.&lt;/li&gt;
&lt;li&gt;Want to support different accelerated parallel programming models: SPMD,
MIMD, MP. All potentially accelerated by custom GRVI And cluster function
units, custom memory or interconnects, custom accelerators on the NOC.&lt;/li&gt;
&lt;li&gt;Next steps: debug/trace over NoC, Hoplite/AXI4 bridges, OpenCL stack,
potential bridge to Chisel RISC-V infrastructure?&lt;/li&gt;
&lt;li&gt;Question: how do I get this? Not available yet, and not yet sure on the
licensing model.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;coreboot-on-risc-v-ron-minnich:404bdd89395af7de00a88d5e9af98f5d&#34;&gt;Coreboot on RISC-V: Ron Minnich&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Initializing the stuff outside the main CPU on a chromebook takes about 1
billion instructions before it can start Linux.&lt;/li&gt;
&lt;li&gt;Firmware, 1990-2005 &amp;ldquo;fire and forget&amp;rdquo;. Set al lthe stff kernels can&amp;rsquo;t do
(e.g. LinuxBIOS), then get out of the way. But now there&amp;rsquo;s a push for the
firmware to hang around after boot.&lt;/li&gt;
&lt;li&gt;Ron argues this sucks. It&amp;rsquo;s slow, there&amp;rsquo;s no easy bugfix path, and it&amp;rsquo;s not
SMP capable on x86.&lt;/li&gt;
&lt;li&gt;Why doesn&amp;rsquo;t Ron like persistent firmware? It&amp;rsquo;s another attack vector,
indistinguishable from a persistent embedded threat. Ron&amp;rsquo;s preference is the
platform management code run as a kernel thread. Minion cores are ideal for
this (Ron&amp;rsquo;s words rather than mine - I of course agree whole-heartedly).&lt;/li&gt;
&lt;li&gt;coreboot is a GPLv2 BIOS replacement (not a bootloader). It has multiple
possible payloads including SeaBIOS and depthcharge (used for verified boot on
Chromebooks).&lt;/li&gt;
&lt;li&gt;Port was started in October 2014 as a side project. The effort resumed in
July 2015 with the privileged spec, and as-of September is up and running
again. The most recent port runs on Spike but not QEMU (due to lack of support
for the privileged spec).&lt;/li&gt;
&lt;li&gt;RISC-V is a first class citizen in coreboot, all commits must pass tests for
the RISC-V buildbot.&lt;/li&gt;
&lt;li&gt;src/arch/riscv is 2685 LoC.&lt;/li&gt;
&lt;li&gt;The Federal Office for Information Security in Germany runs a hardware test
station for coreboot. As soon as real hardware is running, they&amp;rsquo;ve offered to
integrate it into their system.&lt;/li&gt;
&lt;li&gt;Lessons learned

&lt;ul&gt;
&lt;li&gt;provide a boot time SRAM (make sure the address is fixed and not aliased
by DRAM once DRAM is up).&lt;/li&gt;
&lt;li&gt;Provide a serial port.&lt;/li&gt;
&lt;li&gt;Ron reiterates that runtime functions belong in the kernel, not persistent
firmware.&lt;/li&gt;
&lt;li&gt;Firmware tables always need translation by kernel, so make them text not
binary.&lt;/li&gt;
&lt;li&gt;Keep the mask ROM as simple as possible.&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t cheap out on SPI or flash part size. Just plan a 64MiB part.&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t reset the chipset on IE device not present.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-and-uefi-dong-wei-and-abner-chang:404bdd89395af7de00a88d5e9af98f5d&#34;&gt;RISC-V and UEFI: Dong Wei and Abner Chang&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;There is a UEFI Forum consistent of a board of 12 directors, 12 promoters,
42 contributors, 213 adopters.&lt;/li&gt;
&lt;li&gt;UEFI and ACPI are both now handled by the UEFI Forum.&lt;/li&gt;
&lt;li&gt;A RISC-V UEFI port is taking place using EDKII (EFI Development Kit II) and
OVMF (Open Virtual Machine Firmware).&lt;/li&gt;
&lt;li&gt;The speakers are giving a very thorough description of the UEFI boot
mechanism which I&amp;rsquo;m not able to do justice. You&amp;rsquo;re best waiting for the
slides+video I&amp;rsquo;m afraid.&lt;/li&gt;
&lt;li&gt;The project was started a few months ago, and can now boot to a UEFI shell.&lt;/li&gt;
&lt;li&gt;They have created a new RISC-V QEMU target with some PC peripherals (CMOS,
PM, PCI and other devices), and also implemented RISC-V machine mode.&lt;/li&gt;
&lt;li&gt;Requests for new RISC-V spec additions: a periodic timer CSR, RTC with alarm
CSR, PI management mode support, &amp;hellip; (sorry, missed some).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;freebsd-and-risc-v-ruslan-bukin:404bdd89395af7de00a88d5e9af98f5d&#34;&gt;FreeBSD and RISC-V: Ruslan Bukin&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;FreeBSD will support RV64I in release 11.0.&lt;/li&gt;
&lt;li&gt;Why use FreeBSD? Among other reasons, it gives a full-stack BSD license
(RISC-V, FreeBSD, LLVM/Clang).&lt;/li&gt;
&lt;li&gt;FreeBSD has been brought up on Spike.&lt;/li&gt;
&lt;li&gt;The early boot assembly code will put the hardware in a known state, build a
ring buffer for interrupts, initialise the page tables, enable the MMU, then
finally branch to a virtual address and call into C code.&lt;/li&gt;
&lt;li&gt;Userspace porting required modifications to jemalloc, csu (crt1.S, crtn.S,
crti.S), libc, msun (libm), rtld-elf (the runtime linker).&lt;/li&gt;
&lt;li&gt;The FreeBSD port is based on the ARMv8 port. It has a 25k line diff and took
6 months from scratch.&lt;/li&gt;
&lt;li&gt;Userland started working in December. Support will now be committed to
FreeBSD SVN.&lt;/li&gt;
&lt;li&gt;Next plans include multicore, FPU, increasing the virtual address space,
DTrace, performance monitoring counters, QEMU, &amp;hellip;&lt;/li&gt;
&lt;li&gt;Proposed changes: split sptbr to sptrbr0 and sptbr1 for the user VA and the
kernel VA. This means there is no need to change SPTBR when changing the
privilege level, and should reduce code size.&lt;/li&gt;
&lt;li&gt;For more on the project, see the relevant &lt;a href=&#34;https://wiki.freebsd.org/riscv&#34;&gt;FreeBSD wiki
page&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;building-the-risc-v-software-ecosystem-arun-thomas:404bdd89395af7de00a88d5e9af98f5d&#34;&gt;Building the RISC-V software ecosystem: Arun Thomas&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;2016 is the year of RISC-V&amp;rdquo;. Or at least, the year of RISC-V software. We
have a great opportunity to push the software stack forwards.&lt;/li&gt;
&lt;li&gt;What can we achieve by the end of the year? Hopefully upstereamed GNU
toolchain and QEMU. More mature Clang/LLVM support, upstreamed OS support,
Debian/RISC-V port, start thinking about Android and a real-time OS.&lt;/li&gt;
&lt;li&gt;How do we get there? We need to recruit more RISC-V developers and make it
easier for people to get started by producing more docs and specifications.&lt;/li&gt;
&lt;li&gt;Right now, the RISC-V Github has had 48 contributors from a wide range of
Universities, companies and OSS projects.&lt;/li&gt;
&lt;li&gt;We should present talks and tutorials at developer conferences and local
user group meetings.&lt;/li&gt;
&lt;li&gt;If you have local patches, upstream them!&lt;/li&gt;
&lt;li&gt;How to attract developers? Could fund developers/projects via the
Foundation, apply to be a Google Summer of Code mentoring organization, update
the list of open bugs and future requests on github and track contribution
statistics.&lt;/li&gt;
&lt;li&gt;We can make it much easier for people to get started by building Debian
packages, upstreaming, and providing regular binary snapshots.&lt;/li&gt;
&lt;li&gt;Spike is great for prototyping hardware features, but QEMU is a better tool
for software development and a critical part of the RISC-V software story.&lt;/li&gt;
&lt;li&gt;There&amp;rsquo;s more to specify. e.g. a platform specification (e.g. ARMv8 Server
Base System Architecture), boot architecture (look at the ARMv8 Server Base
Boot Requirements), RISC-V ABI, hypervisor, security.&lt;/li&gt;
&lt;li&gt;Useful documents include a RISC-V Assembly Guide, some equivalent of the ARM
Cortex-A Programmer&amp;rsquo;s Guide, and a New Contributor&amp;rsquo;s Guide.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Untethered lowRISC release</title>
      <link>http://www.lowrisc.org/blog/2015/12/untethered-lowrisc-release</link>
      <pubDate>Fri, 18 Dec 2015 10:30:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2015/12/untethered-lowrisc-release</guid>
      <description>&lt;p&gt;Over the past several months, we&amp;rsquo;ve been working to provide a standalone or
&amp;lsquo;untethered&amp;rsquo; SoC. Cores in the original &lt;a href=&#34;https://github.com/ucb-bar/rocket-chip&#34;&gt;Rocket
chip&lt;/a&gt; rely on communicating with a
companion processor via the host-target interface (HTIF) to access peripherals
and I/O. This release removes this requirement, adding an I/O bus and
instantiating FPGA peripherals. The accompanying &lt;a href=&#34;http://www.lowrisc.org/docs/untether-v0.2/&#34;&gt;tutorial&lt;/a&gt;, written by Wei Song, describes how to
build this code release and explains the underlying structural changes. We
support both the &lt;a href=&#34;http://www.xilinx.com/products/boards-and-kits/ek-k7-kc705-g.html&#34;&gt;Xilinx
KC705&lt;/a&gt; and
the lower-priced &lt;a href=&#34;http://store.digilentinc.com/nexys-4-ddr-artix-7-fpga-trainer-board-recommended-for-ece-curriculum/&#34;&gt;Nexys4
DDR&lt;/a&gt;
development boards. We would gladly welcome assistance in supporting other
boards.&lt;/p&gt;

&lt;p&gt;Please note that the codebase temporarily lacks support for tagged memory
included in the &lt;a href=&#34;http://www.lowrisc.org/docs/tagged-memory-v0.1/&#34;&gt;previous release&lt;/a&gt;. We plan to re-integrate tagged memory support
with additional optimisations early next year. You can find a detailed list of
changes in the &lt;a href=&#34;http://www.lowrisc.org/docs/untether-v0.2/release/&#34;&gt;release notes&lt;/a&gt;.
One highlight is support for &lt;a href=&#34;http://www.lowrisc.org/docs/untether-v0.2/vsim/&#34;&gt;RTL simulation using the open-source Verilator
tool&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This development milestone should make it easier for others to contribute. If
you&amp;rsquo;re looking to get stuck in, you might want to consider looking at tasks
such as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cleaning up the &lt;a href=&#34;https://github.com/lowRISC/riscv-linux&#34;&gt;RISC-V Linux port&lt;/a&gt;,
improving devicetree support and removing the host-target interface.&lt;/li&gt;
&lt;li&gt;Replacing use of proprietary peripheral IP with open-source IP cores.&lt;/li&gt;
&lt;li&gt;Adding support for different FPGA development boards, including Altera
boards.&lt;/li&gt;
&lt;li&gt;Implementing the &lt;a href=&#34;http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-852.pdf&#34;&gt;BERI Programmable Interrupt
Controller&lt;/a&gt; (p73), and
adding necessary Linux support.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Our next development priorities are the re-integration of tagged memory
support and an initial integration of a minion core design. We also expect to
put out a job advert in the next few weeks for a new member of the lowRISC
development team at the University of Cambridge Computer Laboratory.
Interested applicants are encouraged to make informal enquiries about the post
to Rob Mullins &lt;a href=&#34;mailto:Robert.Mullins@cl.cam.ac.uk&#34;&gt;Robert.Mullins@cl.cam.ac.uk&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We hope to see many of you at the &lt;a href=&#34;https://riscv.org/2015/12/prelim-agenda-3rd-risc-v-workshop/&#34;&gt;3rd RISC-V
Workshop&lt;/a&gt; in January, where Wei Song
and Alex Bradbury will be presenting about lowRISC.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

