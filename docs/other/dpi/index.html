<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><base href=https://www.lowrisc.org><link rel=icon type=image/png sizes=32x32 href=/favicon.png><title>Suggestions for using DPI with Verilator &middot; lowRISC: Collaborative open silicon engineering</title><link href=/main.b0a63.css rel=stylesheet><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-53520714-1','auto');ga('send','pageview');}</script></head><body><header><nav class="navbar navbar-expand-md navbar-light"><div class=container><a class=navbar-brand href=#><img src=/img/logo/logo-dualcolor.svg alt=lowRISC></a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarCollapse aria-controls=navbarCollapse aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarCollapse><ul class="navbar-nav ml-auto"><li class=nav-item><a href=/our-work class=nav-link>Our work</a></li><li class=nav-item><a href=/open-silicon class=nav-link>Open Silicon</a></li><li class=nav-item><a href=/community class=nav-link>Community</a></li><li class=nav-item><a href=/blog class=nav-link>Blog</a></li><li class=nav-item><a href=/jobs class=nav-link>Jobs</a></li><li class=nav-item><a href=/about class=nav-link>About us</a></li><li class=nav-item><a class="btn lr-navbar-btn-gh" href=https://github.com/lowrisc>GitHub</a></li></ul></div></div></nav></header><main role=main><div class=container><h1>Suggestions for using DPI with Verilator</h1><p><em>By Wei Song</em> (15-Jan-2016)</p><p>The SystemVerilog Dirtect Programming Interface (DPI) is an interface between SystemVerilog and a foreign programming language, especially C/C++. It allows a SystemVerilog process to call a function/task implmented in C through DPI and also allows SystemVerilog to expose its function/task for C programs to use.</p><p>Compared with all other methods such as PLI/VPI and SystemC, DPI is the most light-weighted and supported by almost all major simulators (VCS, NCSim, ModelSim, Xilinx ISim and Verilator) but not sure about Icarus Verilog. It is basically a calling interface that allow Verilog to call C functions and C functions can read arguments from Verilog in a natural way.</p><p>The DPI standard is defined in Chapter 35 of the IEEE Standard 1800â„¢-2012 SystemVerilog LRM which can be downloaded free of charge at <a href=http://standards.ieee.org/getieee/1800/download/1800-2012.pdf>http://standards.ieee.org/getieee/1800/download/1800-2012.pdf</a>.</p><p>There is also a useful <a href=https://www.doulos.com/knowhow/sysverilog/tutorial/dpi/>tutorial</a> from Doulos with actual examples.</p><p>Verilator implements only a part of the DPI standard but should be enough for most use cases.
A compact description of DPI in Verilator can be found <a href=http://www.veripool.org/wiki/verilator/Manual-verilator/#direct_programming_interface__dpi_>here</a>.</p><p>The following is a list of suggestons for using DPI in Verilator:</p><h4 id=avoid-using-dpi-tasks:02c6ea04a5875ad4e506e85dc4959b61>Avoid using DPI tasks</h4><p>Verilator simulates synthesizable Verilog designs so the support of tasks is nearly non-existed. If a task does not incur delay, it is equivalent to a function and then it should be declared as a function. Furthermore, using a DPI task to access Verilog simulation events needs to access the Verilog scope, which is still problematic. So using DPI tasks should be totally avoided. Even using Verilog tasks in Verilator is not recommended.</p><h4 id=avoid-accessing-verilog-variables-in-the-function-body:02c6ea04a5875ad4e506e85dc4959b61>Avoid accessing Verilog variables in the function body</h4><p>Value transferring between Verilog and C/C++ should use the function argument list and the return value only. Also all arguments should be input rather than output or reference.
Any extra accesses to Verilog variables inside the function body need to access the Verilog scope, which is still problematic and, therefore, should be avoided.</p><p><em>Currently we have not found a stable method to initiate this Verilog scope in Verilator. If anyone knows how, please send an example to us, many thanks.</em></p><h4 id=do-not-use-logic-reg-wire-but-bit:02c6ea04a5875ad4e506e85dc4959b61>Do not use logic/reg/wire but bit</h4><p>Verilator currently does not support 4-state values for DPI, so use 2-state values instead.</p><h4 id=be-careful-with-impure-functions:02c6ea04a5875ad4e506e85dc4959b61>Be careful with impure functions</h4><p>By default Verilator considers DPI functions as pure (no internal state and no side-effect) which allows Verilator to schedule functions freely.
This may generated extra calls to DPI functions which are non-existed in other simulators.
Although the latest Verilator has changed this default behaviour but be prepared for remaining inconsistent issues.
A walk-around is to add a flag argument to indicated whether a DPI call is actually needed.
If the flag is unset, do not cause any side-effect on the C/C++ side (simply return).</p><h4 id=dpi-function-working-as-tasks:02c6ea04a5875ad4e506e85dc4959b61>DPI function working as tasks</h4><p>The lack of support of tasks is not a huge issue. A DPI function can have its own internal static (or global) variables to record cycles (causing side-effect and this function is no longer pure). Then the Verilog process that calling this DPI function just needs to call the function in every cycle; therefore, the DPI function can track cycles and decide if there is any delay related operations.</p><p>For the case of using global variables (or objects), which is needed when the same DPI function can be called by multiple Verilog processes, these variables can be initialized in an initial DPI function called in the initial process.</p></div></main><footer class=lr-footer><div class=container><div class=row><div class="col-lg-2 d-none d-lg-block"><img src=/img/logo/logo-dualcolor.svg width=150px></div><div class=col><p><small>The text content on this website is licensed under a <a href=https://creativecommons.org/licenses/by/4.0/>Creative Commons Attribution 4.0 International License</a>, except where otherwise noted. No license is granted for logos or other trademarks. Other content &copy; lowRISC Contributors.</small></p><p><small><a href=/privacy-policy>Privacy and cookies policy</a>
&middot; <a href=/usage-licence>Usage licence</a></small></p></div><div class=col-lg-2><p><a href=#>Back to top</a></p></div></div></div></footer><script src=/main.b0a63.js></script></body></html>