<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>lowRISC</title>
    <link>http://www.lowrisc.org/</link>
    <description>Recent content on lowRISC</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 May 2018 07:00:00 +0000</lastBuildDate>
    <atom:link href="http://www.lowrisc.org/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Barcelona RISC-V Workshop: Day Two</title>
      <link>http://www.lowrisc.org/blog/2018/05/barcelona-risc-v-workshop-day-two</link>
      <pubDate>Wed, 09 May 2018 07:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2018/05/barcelona-risc-v-workshop-day-two</guid>
      <description>

&lt;p&gt;The &lt;a href=&#34;https://riscv.org/2018/04/risc-v-workshop-in-barcelona-agenda/&#34;&gt;eighth RISC-V
workshop&lt;/a&gt; is
continuing
today in Barcleona. As usual, I&amp;rsquo;ll be keeping a semi-live blog of talks and
announcements throughout the day.&lt;/p&gt;

&lt;h2 id=&#34;fast-interrupts-for-risc-v-krste-asanovic:a5d6ec65113439624abf306f86726737&#34;&gt;Fast interrupts for RISC-V: Krste Asanovic&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Embedded is a major use for RISC-V. There is a desire for faster interrupt
handling with support for nested preempted interrupts.&lt;/li&gt;
&lt;li&gt;Summary of current RISC-V interrupts

&lt;ul&gt;
&lt;li&gt;Local interrupts are directly connected to one hart. There&amp;rsquo;s no
arbitration between harts to service. Determine cause through xcause CSR.
Only two standard local interrupts (software, timer).&lt;/li&gt;
&lt;li&gt;Global (external) interrupts are routed via the platform-level interrupt
controller (PLIC) which arbitrates between multiple harts claiming an
interrupt.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The machine interrupt pending (mip) CSR contains bits for local software,
local timer, and external interrupts (from the PLIC). It tells you which
interrupts are present.&lt;/li&gt;
&lt;li&gt;mie mirrors the layout of mip, and allows you to enable/disable interrupts.&lt;/li&gt;
&lt;li&gt;mstatus keeps track of interrupt status, containing a small interrupt stack.&lt;/li&gt;
&lt;li&gt;The interrupt is reported in the mcause CSR. The exception code indicates
which interrupt was responsible - you might have to then interrogate the PLIC
if it was an external interrupt.&lt;/li&gt;
&lt;li&gt;mtvec (machine trap vector base) contains the address of the trap vector
(&amp;lsquo;base&amp;rsquo;). It also contains bits which control whether interrupts are direct
(all exceptions and interrupts jump to base) or vectored (exceptions go to
base, interrupts are vectored).&lt;/li&gt;
&lt;li&gt;There&amp;rsquo;s two parts of an interrupt: what you were doing when it happened
(state context), and what you&amp;rsquo;re going to do. mepc and mstatus allow the
contact to be saved and restored.&lt;/li&gt;
&lt;li&gt;Problems with current interrupts:

&lt;ul&gt;
&lt;li&gt;Hardware preemption is only possible by switching privileged modes&lt;/li&gt;
&lt;li&gt;Fixed priority for local interrupts&lt;/li&gt;
&lt;li&gt;The vector table holds jumps instructions, which can only jump +/- 1MiB. A
free register would be required to jump further, resulting in even more
instructions.&lt;/li&gt;
&lt;li&gt;PLIC has variable priority, but the vectoring must be done in software.&lt;/li&gt;
&lt;li&gt;The PLIC needs two memory accesses: one to claim it, one to indicate
completion.&lt;/li&gt;
&lt;li&gt;The Unix ABI (which is the only one that has been standardised) requires
many registers to be saved/restored.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Have had input via multiple proposals: Andes, Syntacore, Seagate, Liviu
Ionescu, SiFive&lt;/li&gt;
&lt;li&gt;There have been discussions on the list about the interrupt handler
interface for software. It comes down to a choice between having the interrupt
handler as a regular C function (requiring save/restore of all caller-save
registers in hardware or software) or an inline handler which uses a gcc
interrupt attribute to convert the function to always callee-save every
register. Krste suggests both approaches are needed.&lt;/li&gt;
&lt;li&gt;Krste explains how an &amp;ldquo;interrupt&amp;rdquo; attribute on a C function might work. In
this example, every register is callee-saved, so registers are saved as you
need to use them.&lt;/li&gt;
&lt;li&gt;If you then went to call a function using the C ABI you need to save/restore
8 arguments, 7 temporaries, and 1 return address. Even more if you have to
save the floating point context. Krste argues that moving this to hardware
isn&amp;rsquo;t enough, you need a new ABI to reduce the amount of state.&lt;/li&gt;
&lt;li&gt;A number of options have been proposed for vectoring.

&lt;ul&gt;
&lt;li&gt;Having function pointers in a table. Downside is this is new functionality
you&amp;rsquo;d have to add to a pipeline.&lt;/li&gt;
&lt;li&gt;The SiFive proposal is to add a new +/-2GiB offset instruction which is
only visible in a new interrupt ISA mode. The advantage is the pipeline can
treat this as a regular instruction fetch, albeit with a different encoding.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Would like to allow each interrupt to be configured with its privilege mode
and the &amp;lsquo;interrupt level&amp;rsquo; which describes the preemption level, and a
priority.&lt;/li&gt;
&lt;li&gt;To manage preempted context state it&amp;rsquo;s necessary to push/pop
mepc/mpp/mil/mie to a memory stack. You also need to remember the previous
interrupt level, &amp;lsquo;mil&amp;rsquo;. Now multiple levels must be tracked, which Krste
proposes could be stored in mcause.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-dsp-p-extension-proposal-chuan-hua-chang:a5d6ec65113439624abf306f86726737&#34;&gt;RISC-V DSP (P) extension proposal: Chuan-Hua Chang&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;P extension task group will define and ratify a packed-SIMD DSP extension
containing instructions which operate on XLEN-bit integer registers. It will
also define compiler intrinsic functions that can be directly used in
high-level programming languages.&lt;/li&gt;
&lt;li&gt;The initial proposal is based on the AndeStar V3 DSP ISA.&lt;/li&gt;
&lt;li&gt;Supports e.g. 16-bit SIMD instructions with min, max, abs, compare, clip
operations. Similar for 8-bit SIMD.&lt;/li&gt;
&lt;li&gt;GPR-based SIMD is more efficient for various embedded domains. It addresses
the need for high performance generic code processing as well as digital
signal processing.&lt;/li&gt;
&lt;li&gt;Want to make this easy to use through intrinsic functions and optimised DSP
libraries.&lt;/li&gt;
&lt;li&gt;For 64-bit data types, use pairs of GPRs on RV32. An implementation could of
course still use a 2R1W register file, but use multiple cycles to read a
64-bit value.&lt;/li&gt;
&lt;li&gt;After the task group is created, bi-weekly meetings will be set up.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;security-task-group-update-richard-newell:a5d6ec65113439624abf306f86726737&#34;&gt;Security task group update: Richard Newell&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The security group was previously a task group of the technical committee.
There is now a new security standing committee, at the same level with the
marketing and technical committees.&lt;/li&gt;
&lt;li&gt;Task groups will be set up to look at cryptograpshic ISA extensions and
trusted execution environments for microcontroller&lt;/li&gt;
&lt;li&gt;The full charter will be published on riscv.org&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;formal-assurance-for-risc-v-implementations-daniel-m-zimmerman:a5d6ec65113439624abf306f86726737&#34;&gt;Formal assurance for RISC-V implementations: Daniel M. Zimmerman&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Galois started with a focus on cryptography, but has broadened its scope to
&amp;ldquo;high assurance everything&amp;rdquo;&lt;/li&gt;
&lt;li&gt;There are a range of definitions for RISC-V. The human-readable instruction
manual, mechanisations in the form of software simulators or hardware
implementations. The formal model working group have also been working on
this.&lt;/li&gt;
&lt;li&gt;How can we provide assurance about these definitions / mechanisations?&lt;/li&gt;
&lt;li&gt;Assurance means: the system does what it is supposed to do and doesn&amp;rsquo;t do
anything else.&lt;/li&gt;
&lt;li&gt;When trying to get assurance through compliance tests, a huge burden is put
on the shoulders of the test writers. Those conformance tests need to be 100%
complete. This also doesn&amp;rsquo;t help determine if an implementation has
undesirable behaviours.&lt;/li&gt;
&lt;li&gt;Alternatively, formally verify your system. Compile a model to RTL via
clash, then use equivalence checking tools to compare against your own
implementation.&lt;/li&gt;
&lt;li&gt;Need machine-readable specification of the correctness and security of an
implementation as well as a way to measure the conformance of an
implementation.&lt;/li&gt;
&lt;li&gt;How to validate a specification?

&lt;ul&gt;
&lt;li&gt;Might perform rigorous validation through execution: ad hoc testing,
simulation coverage analysis, or bisimulation.&lt;/li&gt;
&lt;li&gt;Alternatively perform rigorous verification through formal reasoning:
prove test benches always pass, verification coverage analysis, or
bisimulation.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Security properties require a different approach. They typically have a
different form, e.g. &amp;ldquo;the following property must never hold&amp;rdquo;. Galois is
developing a DSL that lets you specify the architecture, correctness
properties and security properties of a hardware design. It&amp;rsquo;s also working on
a security test suite.&lt;/li&gt;
&lt;li&gt;Want to help systems engineers understand and explore the effects of design
and implementation decisions on power, performance, area, and security.&lt;/li&gt;
&lt;li&gt;Status

&lt;ul&gt;
&lt;li&gt;LANDO DSL is in early stages of development. Expect initial version before
2018 RISC-V summit&lt;/li&gt;
&lt;li&gt;Security test suite: early stages of development&lt;/li&gt;
&lt;li&gt;Metrics and measures: evaluating existing tools for PPA and looking at
existing metrics work for security&lt;/li&gt;
&lt;li&gt;Dashboard: early stages of design&lt;/li&gt;
&lt;li&gt;Feature model generation: early stages of design&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;undefined-unspecified-non-deterministic-and-implementation-defined-behavior-in-verifiable-specifications-clifford-wolf:a5d6ec65113439624abf306f86726737&#34;&gt;Undefined, Unspecified, Non-deterministic, and Implementation Defined Behavior in Verifiable Specifications: Clifford Wolf&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Users of an ISA specification

&lt;ul&gt;
&lt;li&gt;Software engineers: just don&amp;rsquo;t do anything that&amp;rsquo;s not specified&lt;/li&gt;
&lt;li&gt;Software security engineers: what can we expect from the hardware if we do
the thing that wasn&amp;rsquo;t specified?&lt;/li&gt;
&lt;li&gt;Hardware design engineers: do something safe and simple for anything not
specified. But what does safe mean?&lt;/li&gt;
&lt;li&gt;Hardware verification engineers&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;This presentation is a taxonomy of types of &amp;lsquo;not specified&amp;rsquo; behaviour, using
nomenclature taking from different domains.&lt;/li&gt;
&lt;li&gt;Undefined behaviour: the &amp;ldquo;just don&amp;rsquo;t do that&amp;rdquo; approach to not specifying
behaviour. The spec is void for any program as a whole if it does this
undefined behaviour once.&lt;/li&gt;
&lt;li&gt;Could introduce an &amp;lsquo;undefined value&amp;rsquo;, but that has similar issues&lt;/li&gt;
&lt;li&gt;Non-deterministic behaviour / unpredictable behaviour: allow more than one
choice, which may change under re-execution&lt;/li&gt;
&lt;li&gt;Unspecified value: the instruction will return a value, but the spec doesn&amp;rsquo;t
say which value&lt;/li&gt;
&lt;li&gt;Implementation defined behaviour / value: similar to unspecified value /
behaviour, but the implementer must specify what it is.&lt;/li&gt;
&lt;li&gt;Fully specified behaviour: the ideal choice for verification. Explicitly
state what all implementations must do.&lt;/li&gt;
&lt;li&gt;Clifford strongly prefers implementation defined or fully specified
behaviour.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;foundational-hpc-systems-in-2020-and-beyond-steven-wallach:a5d6ec65113439624abf306f86726737&#34;&gt;Foundational HPC systems in 2020 and beyond: Steven Wallach&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Architecture 1.0 (see Mark Hill paper). The world was very
processor-centric. CPUs with memory attached.&lt;/li&gt;
&lt;li&gt;Architecture 2.0. Not just the ISA. Move towards memory-driven computing.

&lt;ul&gt;
&lt;li&gt;Numerical processing is trivial, but achieving efficient memory access is
very hard.&lt;/li&gt;
&lt;li&gt;Caches now need to be protected machine state.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;An RV128 working group is going to be started, chaired by Steven

&lt;ul&gt;
&lt;li&gt;Propose a 64-bit object ID and 64-bit byte offset.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;On an RV128 system, have to be able to execute RV64 programs and map 64-bit
virtual into 128-bit virtual. Also map system calls.&lt;/li&gt;
&lt;li&gt;Object 0 is kernel object, object 1 RV64, object 2 RV32.&lt;/li&gt;
&lt;li&gt;Encrypted memory is identified with an object ID&lt;/li&gt;
&lt;li&gt;Steven suggests disabling speculation if kernel objects are referenced.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;european-processor-initiative-and-risc-v-mateo-valero:a5d6ec65113439624abf306f86726737&#34;&gt;European processor initiative and RISC-V: Mateo Valero&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;BSC-CNS is a consortium including the Spanish government, Catalan
government, and UPC&lt;/li&gt;
&lt;li&gt;Now have 529 people from a wide range of countries.&lt;/li&gt;
&lt;li&gt;Need to reach 50GFlops/W&lt;/li&gt;
&lt;li&gt;MareNostrum 4 has been recognised as the &amp;ldquo;most beautiful datacenter in the
world&amp;rdquo;. Total peak performance is 13.7 PFlops&lt;/li&gt;
&lt;li&gt;USA, Japan, China are all building huge supercomputers with domestic
technology. Can the EU do the same?&lt;/li&gt;
&lt;li&gt;The EU has a large HPC ecosystem and a number of centers of excellence in
HPC applications.&lt;/li&gt;
&lt;li&gt;Through the Mont Blanc project, proposed the use of ARM processors in
supercomputing applications. Extended current mobile chips with HPC features.&lt;/li&gt;
&lt;li&gt;Europe has only 4 machines in the world top 20.&lt;/li&gt;
&lt;li&gt;With Brexit and Softbank, ARM is not &amp;lsquo;European&amp;rsquo; any more.&lt;/li&gt;
&lt;li&gt;Through EuroHPC, the Commission has proposed to invest 1B.&lt;/li&gt;
&lt;li&gt;The European Processor Initiative is a consortium consisting of 23 partners.
They will form the company &amp;lsquo;EPI Semiconductor&amp;rsquo; which will produce the EPI
common platform. Now looking at growing the consortium, including companies
from other countries.&lt;/li&gt;
&lt;li&gt;Three streams

&lt;ul&gt;
&lt;li&gt;General purpose and common platform. ARM SVE or other candidates. BULL
will be system integrator / chip integrator.&lt;/li&gt;
&lt;li&gt;Accelerator: RISC-V&lt;/li&gt;
&lt;li&gt;Automotive&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Barcelona RISC-V Workshop: Day One</title>
      <link>http://www.lowrisc.org/blog/2018/05/barcelona-risc-v-workshop-day-one</link>
      <pubDate>Tue, 08 May 2018 07:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2018/05/barcelona-risc-v-workshop-day-one</guid>
      <description>

&lt;p&gt;The &lt;a href=&#34;https://riscv.org/2018/04/risc-v-workshop-in-barcelona-agenda/&#34;&gt;eighth RISC-V
workshop&lt;/a&gt; is
going
on today in Barcleona. As usual, I&amp;rsquo;ll be keeping a semi-live blog of talks and
announcements throughout the day.&lt;/p&gt;

&lt;p&gt;Follow &lt;a href=&#34;http://www.lowrisc.org/blog/2018/05/barcelona-risc-v-workshop-day-two&#34;&gt;here&lt;/a&gt; for the
day two live blog.&lt;/p&gt;

&lt;h2 id=&#34;introduction-rick-o-connor:7e63e62b65afd74857129fe53555ff5b&#34;&gt;Introduction: Rick O&amp;rsquo;Connor&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This workshop has 325 attendees representing 101 companies and 25
universties. Largest outside of Silicon Valley.&lt;/li&gt;
&lt;li&gt;Rick gives the usual overview of the RISC-V Foundation structure.&lt;/li&gt;
&lt;li&gt;The RISC-V Foundation currently has over 150 members, including invidual
members. These members are distributed across 25 countries around the world.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-state-of-the-union-krste-asanovic:7e63e62b65afd74857129fe53555ff5b&#34;&gt;RISC-V state of the union: Krste Asanovic&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Krste gives an overview of the RISC-V ISA for newcomers.&lt;/li&gt;
&lt;li&gt;RISC-V encoding terminology.

&lt;ul&gt;
&lt;li&gt;Standard: defined by the Foundation&lt;/li&gt;
&lt;li&gt;Reserved: Foundation might eventually use this space for future standard
extensions.&lt;/li&gt;
&lt;li&gt;Custom: Space for implemnter-specific extensions, never claimed by
Foundation.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The RISC-V big tent philosophy: enable all types of RISC-V implementation,
from 32-bit microcontrollers with 1KiB SRAM up to 64-bit Unix servers with
virtualisation or 128-bit 100k-core supercomputer with PiBs DRAM, open or
proprietary business models, non-conforming extensions, software
implementations (e.g. QEMU), &amp;hellip;

&lt;ul&gt;
&lt;li&gt;Minimize wasted work through maximum reuse. Factor out platform-level
requirements from reusable ISA and software modules&lt;/li&gt;
&lt;li&gt;Use standard platform profiles to reduce ecosystem effort.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A system is minimally RISC-V-ISA-compliant if it runs claimed RISC-V
unprivileged code correctly. e.g. gcc-compiled RV32IMAC functions work
correctly. Platform must support loading program, returning result etc.&lt;/li&gt;
&lt;li&gt;One set of unprivileged ISA compliance tests should be able to run on any
platform. There is a challenge here in handling tiny platforms, e.g. 1KiB
SRAM.&lt;/li&gt;
&lt;li&gt;A platform specification provides tight constraints on system configuration
and options to support a software ecosystem.

&lt;ul&gt;
&lt;li&gt;It provides an interface between platform hardware and software, including
privileged levels.&lt;/li&gt;
&lt;li&gt;Avoid unnecessary duplication. Where it&amp;rsquo;s possible to define a common
standard, do so.&lt;/li&gt;
&lt;li&gt;Platform compliance tests will be built in collaboration with the relevant
ecosystem. e.g. server platform compliance, ZephyrOS platform compliance.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Software is king in the RISC-V land

&lt;ul&gt;
&lt;li&gt;ISA extensions need compiler/linker/library support&lt;/li&gt;
&lt;li&gt;There&amp;rsquo;s no point adding instructions if no software wants to use it.&lt;/li&gt;
&lt;li&gt;ISA proposals should be sensible to implement.&lt;/li&gt;
&lt;li&gt;Finished now is better than perfect sometime. But at the same time,
shouldn&amp;rsquo;t rush to freeze a spec before it&amp;rsquo;s ready.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Open-source hardware vs software

&lt;ul&gt;
&lt;li&gt;Some lessons from the free/open source software community apply, but many
things are different. e.g. very large investments in hardware that cannot be
changed once manufactured, threat of patent lawsuits&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Major milestones in 2017

&lt;ul&gt;
&lt;li&gt;Fixed holes in user ISA, no changed now in IMAFDQC&lt;/li&gt;
&lt;li&gt;Froze priv-1.10 spec. Updates must be backwards compatible&lt;/li&gt;
&lt;li&gt;Memory model work&lt;/li&gt;
&lt;li&gt;Linux ABI frozen&lt;/li&gt;
&lt;li&gt;Debug spec completed&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2018 initiatives

&lt;ul&gt;
&lt;li&gt;Working to prepare the base ISA for ratifications&lt;/li&gt;
&lt;li&gt;Formal spec in progress&lt;/li&gt;
&lt;li&gt;Hypervisor spec done, need implementations&lt;/li&gt;
&lt;li&gt;Crypto in progress&lt;/li&gt;
&lt;li&gt;J (dynamic translation / runtimes) in progress&lt;/li&gt;
&lt;li&gt;Packed SIMD in progress&lt;/li&gt;
&lt;li&gt;Security task group ongoing&lt;/li&gt;
&lt;li&gt;Fast interrupts started&lt;/li&gt;
&lt;li&gt;Trace started&lt;/li&gt;
&lt;li&gt;Krste comments it may take longer to finish these things vs comparable
industry projects.  Have many more stakeholders giving input.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2018 embedded platform

&lt;ul&gt;
&lt;li&gt;New ABI for embedded (e.g. long double = 64bit)&lt;/li&gt;
&lt;li&gt;Build on RV32E&lt;/li&gt;
&lt;li&gt;compiler/library work for improved code compression&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;RISC-V and security

&lt;ul&gt;
&lt;li&gt;Set up security standing committee. Chaired by Helena Handschuh (Rambus),
vice-chair Joe Kiniry (Galois Research).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-state-of-risc-v-software-palmer-dabbelt:7e63e62b65afd74857129fe53555ff5b&#34;&gt;The state of RISC-V software: Palmer Dabbelt&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Palmer shows a picture of Xorg with web browser, terminal, webcam, and a 3d
video game all running on a RISC-V core (SiFive Unleashed with Microsemi
add-on board).&lt;/li&gt;
&lt;li&gt;GNU-based toolchains

&lt;ul&gt;
&lt;li&gt;binutils, gcc, glibc, newlib all upstreamed.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The RISC-V Linux kernel port was upstreamed in January 2018. It only
supports RV64I systems for now, and is currently missing some platform
drivers. Help would be welcomed in getting these upstream.&lt;/li&gt;
&lt;li&gt;RISC-V Fedora and Debian support is in progress&lt;/li&gt;
&lt;li&gt;RISC-V LLVM port is making rapid progress. RV32IMFDC upstream. [As a
correction to the talk, compressed support is upstream - thanks to
contributions from Andes Tech and Qualcomm!]&lt;/li&gt;
&lt;li&gt;Bootloaders: U-boot is upstream, TianoCore is a work in progress. Coreboot
RISC-V support is upstream but a little out of date. UEFI standard process is
ongoing.&lt;/li&gt;
&lt;li&gt;Embedded runtimes: Zephry is upstream, seL4 upstream, FreeRTOS exists but
isn&amp;rsquo;t upstream, Micrium uC/OS is available, as is ThreadX.&lt;/li&gt;
&lt;li&gt;Debugging: GDB port upstream, OpenOCD exists but not upstream. Also
commercial debuggers: Segger, Lauterbach, UltraSoC, IAR is upcoming.&lt;/li&gt;
&lt;li&gt;The core software stack has been supported by a consortium of developers
from a range of companies.&lt;/li&gt;
&lt;li&gt;RISC-V software implementations: Spike, RV8, Renode, QEMU (upstreamed and
included in a upstream release about a week ago)&lt;/li&gt;
&lt;li&gt;There are also commercial simulators, such as Imperas OVP and Esperanto&amp;rsquo;s
simulator.&lt;/li&gt;
&lt;li&gt;Help wanted: OpenJDK JIT port, Arduino runtime&lt;/li&gt;
&lt;li&gt;The RISC-V platform specification working group will define profiles for
types of RISC-V systems. e.g. bare-metal embedded, RTOS, embedded Linux,
portable Linux.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-risc-v-vector-isa-update-roger-espassa:7e63e62b65afd74857129fe53555ff5b&#34;&gt;The RISC-V vector ISA update: Roger Espassa&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The spec isn&amp;rsquo;t yet ready&amp;hellip;but it&amp;rsquo;s getting really close&lt;/li&gt;
&lt;li&gt;Updates and discussion points:

&lt;ul&gt;
&lt;li&gt;Register types moved to an extension.&lt;/li&gt;
&lt;li&gt;Widening multiplies&lt;/li&gt;
&lt;li&gt;Debating whether reductions should be in base or not&lt;/li&gt;
&lt;li&gt;Worked on overlaying V-reg and F-reg to save state, decided against it&lt;/li&gt;
&lt;li&gt;Fixed point vclip instructions&lt;/li&gt;
&lt;li&gt;Mask support for speculative vectorisation&lt;/li&gt;
&lt;li&gt;Possibility to fit integer MADD within encoding&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Scalar support: the encoding allows indicating that the destination vreg is
a &amp;ldquo;scalar shape&amp;rdquo;. Introduce VLO/VSO to load/store single scalar elements.&lt;/li&gt;
&lt;li&gt;Roger is outlining the newly introduced instructions. I can&amp;rsquo;t usefully
summarise these, so you&amp;rsquo;re best waiting for the slides to be published.&lt;/li&gt;
&lt;li&gt;vclip is introduced to help support fixed point.&lt;/li&gt;
&lt;li&gt;FP16 operations are introduced and are required for the V extension.&lt;/li&gt;
&lt;li&gt;The vector extension introduces interesting instructions such as vector-fpr
merge, vector-fp merge, slide down / slide up&lt;/li&gt;
&lt;li&gt;Plan to close the base spec very soon&lt;/li&gt;
&lt;li&gt;Want to see compiler output before bringing for ratification&lt;/li&gt;
&lt;li&gt;Haven&amp;rsquo;t yet started on formal spec for the vector ISA&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-isa-ofrmal-spec-technical-update-rishiyur-nikhil:7e63e62b65afd74857129fe53555ff5b&#34;&gt;The ISA ofrmal spec technical update: Rishiyur Nikhil&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;What what use is an ISA formal spec?

&lt;ul&gt;
&lt;li&gt;Answer questions about compiler correctness. Will executing a certain two
C programs produce the same results? For all inputs? For all C and
corresponding RISC-V programs?&lt;/li&gt;
&lt;li&gt;Answer questions on implementation correctness. Will executing this progam
produce correct results? On all RISC-V processors?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ISA formal spec goals

&lt;ul&gt;
&lt;li&gt;Clear and understandable to the human reader. Precise and complete.&lt;br /&gt;
Machine readable. Executable (run RISC-V programs, boot an OS). Usable with
various formal tools.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Key issues

&lt;ul&gt;
&lt;li&gt;RISC-V&amp;rsquo;s modulatirty. A wide range of options, some of which are
dynmically selectable or can vary between privilege levels. The spec needs
to capture all combinations and still remain readable.&lt;/li&gt;
&lt;li&gt;Extensibility. Want to allow people to build upon the formal spec to add
support their own extensions.&lt;/li&gt;
&lt;li&gt;Non-detterminism and concurrency.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Status. Various approaches are being pursued: 3 projects in Haskell, 1
project in SAIL, 1 project in L3, another in a &amp;lsquo;functional subset&amp;rsquo; of Verilog

&lt;ul&gt;
&lt;li&gt;One of the Haskell projects (led by a team at MIT) is furthest along.&lt;br /&gt;
Models RV32I, RV64I, M, priv U+S+M, Sv39 VM&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Next steps: within a couple of months publish a formal spec that is complete
for RV32IMAC, RV64IMAC, user+supervisor+machine mode, sv32+sv39, and a simple
sequential memory model. Liaise with the compliance group to use the formal
spec as a golden reference for compliance suites. Then work to integrate with
the weak memory model.&lt;/li&gt;
&lt;li&gt;Potential follow-up projects (by community?)

&lt;ul&gt;
&lt;li&gt;Formally show equivalences between different ISA formalisations&lt;/li&gt;
&lt;li&gt;Demonstrate extensibility to other standard options (e.g. vector, crypto)&lt;/li&gt;
&lt;li&gt;Use it! (to provide correctness of hardware implementations, compilers,
&amp;hellip;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-memory-consistency-model-status-update-dan-lustig:7e63e62b65afd74857129fe53555ff5b&#34;&gt;RISC-V memory consistency model status update: Dan Lustig&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The specification is released for public comment, which will run through to
June 16th.&lt;/li&gt;
&lt;li&gt;Fundamentally, the RISC-V memory consistency model specifies the values that
can be returned by loads.&lt;/li&gt;
&lt;li&gt;The RISC-V memory model specification defines the RISC-V weak memory
ordering (RVWMO) model and extensions: Zam (misaligned atomics), Ztso (Total
Store Ordering).&lt;/li&gt;
&lt;li&gt;Global memory order (GMO): a total order over the memory operations
generated by the instructions in each program&lt;/li&gt;
&lt;li&gt;GMO is constrained by the Preserved Program Order (PPO)&lt;/li&gt;
&lt;li&gt;Load Value Axiom&lt;/li&gt;
&lt;li&gt;Atomicity Axiom: no store from another hart can appear in the global memory
order between a paired LR and successful SC (see spec for full details of
rule)&lt;/li&gt;
&lt;li&gt;Progress Axiom: no memory operation may be preceded in the global memory
order by an infinite sequence of other memory operations&lt;/li&gt;
&lt;li&gt;Misaligned AMOs are not supported in the base &amp;lsquo;A&amp;rsquo; extension, but can be
supported with the &amp;lsquo;Zam&amp;rsquo; extension.&lt;/li&gt;
&lt;li&gt;Ztso strengthens the baseline memory model to TSO, but TSO-only code is not
backwards-compatible with RVWMO.&lt;/li&gt;
&lt;li&gt;Authored two appendices which give lengthy explanations in plain English as
well as axiomatic and operational models. More than 7000 litmus tests are
available online.&lt;/li&gt;
&lt;li&gt;Ongoing/future work

&lt;ul&gt;
&lt;li&gt;Mixed-size, partially overlappy memory accesses&lt;/li&gt;
&lt;li&gt;Instruction fetches and fence.i, TL flushes and sfence.vma etc&lt;/li&gt;
&lt;li&gt;Integrations with V, J, N, T extensions&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;software-drives-hardware-lessons-learned-and-future-directions-robert-oshana:7e63e62b65afd74857129fe53555ff5b&#34;&gt;Software drives hardware. Lessons learned and future directions: Robert Oshana&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Software engineers can innovate earlier/often and drive more specific core
requirements for hardware design team&lt;/li&gt;
&lt;li&gt;Software engineers like to dream of a simple single core running at very
high clock rate, and zero latency unlimited bandwidth access to a single
memory. A hardware engineers dreams of many cores at 1ghz with accelerators,
separate memories etc.&lt;/li&gt;
&lt;li&gt;Trying to achieve even faster development cycles.&lt;/li&gt;
&lt;li&gt;Start with system modelling, move to system definition, and produce
intrinsic libraries, new instructions, programming model details, and a Chisel
model.&lt;/li&gt;
&lt;li&gt;Moving towards &amp;ldquo;software driven hardware&amp;rdquo; to support the software
programming model (2020).&lt;/li&gt;
&lt;li&gt;NXP are using PULPino.&lt;/li&gt;
&lt;li&gt;Challenge: establishing a robust open community for RISC-V. Want to see
multiple vendors contributing back to the &amp;lsquo;RISC-V ISA mainline&amp;rsquo;.&lt;/li&gt;
&lt;li&gt;Using RISC-V mainly as &amp;lsquo;minion cores&amp;rsquo;. Focused on efficient core designs and
ISA enhancement for application-specific functionality. e.g. bit manipulation,
crypto. Other innovation targets include a multi RISC-V core MCU SoC.&lt;/li&gt;
&lt;li&gt;Embedded software engineers will take a bigger role in defining the SoC
architecture

&lt;ul&gt;
&lt;li&gt;Programming model&lt;/li&gt;
&lt;li&gt;System optimsiation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Open source RISC-V implementations will allow more software driven hardware.&lt;br /&gt;
Ecosystem is vital to success.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;unleashing-the-power-of-data-with-risc-v-martin-fink:7e63e62b65afd74857129fe53555ff5b&#34;&gt;Unleashing the power of data with RISC-V: Martin Fink&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why has Western Digital made such a big commitment to RISC-V even though
they&amp;rsquo;re not in the processor business? Feel there&amp;rsquo;s too much focus on the CPU,
when the focus needs to be on the data.&lt;/li&gt;
&lt;li&gt;Half the world&amp;rsquo;s data lives on Western Digital devices.&lt;/li&gt;
&lt;li&gt;First Western Digital RISC-V core. 2-way superscalar, mostly in-order core
with 9 stage pipeline. RV32IMC, 1 load/store pipe, 1 multiplier, 1 divider, 4
ALU engines.

&lt;ul&gt;
&lt;li&gt;Performance targets at 28nm. Dhrystone greater than 2MIPS/Mhz, CoreMark
over 3 CM/MH. 1GHz operation.&lt;/li&gt;
&lt;li&gt;Built to show it can be done and better understand RISC-V&lt;/li&gt;
&lt;li&gt;Most of the work went into the uncore.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Produced a NAND controller SoC using RISC-V. Added instruction optimisations
for NAND media handling.&lt;/li&gt;
&lt;li&gt;Still on track to ship first products with RISC-V in 2019.&lt;/li&gt;
&lt;li&gt;RISC-V in embedded

&lt;ul&gt;
&lt;li&gt;Free and open IP connectivity buses enabling plug and play of proprietary
and open source IPs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;RISC-V in enterprise

&lt;ul&gt;
&lt;li&gt;Datacenter CPUs with smart, fast and open peripheral buses enable new
compute paradigms for AI workloads&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;General purpose architectures are no longer sufficient. Workload diversity
demands diverse technologies and architectures.&lt;/li&gt;
&lt;li&gt;Open source software licenses can apply to HDL, GDSII, Gerber. There is more
work still needed though.&lt;/li&gt;
&lt;li&gt;Strong believer in the GPLv2. The troubling part about permissive licensing
is it allows people to do proprietary things without sharing. Pragmatically,
many companies gravitate towards permissive licenses like Apache. Hope to move
work word towards copyleft over time.&lt;/li&gt;
&lt;li&gt;Western Digital is working to support development of open source IP building
blocks for the community. Will actively partner and invest in the ecosystem.
Accelerate development of purpose-built processors for a broad range of Big
Data and Fast Data environments.&lt;/li&gt;
&lt;li&gt;There is a multi-year transition of Western Digital devices, platforms and
systems to RISC-V.&lt;/li&gt;
&lt;li&gt;Question from the audience: will Western Digital be open sourcing their
cores? Would like to, but not making a commitment today. One of the challenges
is uncoupling from the uncore. Ultimately hope to share cores and IP blocks.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-debugging-custom-isa-extensions-multicore-dtm-variants-markus-goehrle:7e63e62b65afd74857129fe53555ff5b&#34;&gt;RISC-V debugging. Custom ISA extensions, multicore, DTM variants: Markus Goehrle&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Support for a variety of external and internal interfaces, as well as
interconnections of standard debug transport modules (DTM).&lt;/li&gt;
&lt;li&gt;TRACE32 has Linux-awareness, including the ability to view resources such as
task and kernel modules, addresses of dynamic objects etc.&lt;/li&gt;
&lt;li&gt;Support heterogeneous systems, custom ISA extensions&lt;/li&gt;
&lt;li&gt;Found that a lot of customers have built something based on the draft debug
specification, as well as others who implement their own custom debug IP.
People are also doing custom solutions for trace. The speaker strongly urges
people to feed into the debug specification standardisation process.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;gdb-for-risc-v-jeremy-bennett:7e63e62b65afd74857129fe53555ff5b&#34;&gt;GDB for RISC-V: Jeremy Bennett&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;GDB support was committed upstream as of early March, including basic bare
metal support. This sees nightly regression tests with a pass rate above 99%.&lt;/li&gt;
&lt;li&gt;Next steps include:

&lt;ul&gt;
&lt;li&gt;XML target description support&lt;/li&gt;
&lt;li&gt;Memory map support&lt;/li&gt;
&lt;li&gt;Remote I/O support&lt;/li&gt;
&lt;li&gt;Adding non-DWARF stack unwinding&lt;/li&gt;
&lt;li&gt;Upstreaming a GDB Simulator&lt;/li&gt;
&lt;li&gt;Linux application debugging&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;GDB support for multicore debug is evolving, with support for multiple
active inferiors with their own flow of control and address space. Each
inferior is associated with a program space (symbol table and DWARF debug
information) for the code running on that inferior.&lt;/li&gt;
&lt;li&gt;Upstream GDB supports multiple concurrent inferiors which has been tested
for RISC-V with a 36-core system. More work is needed for complex address
spaces (e.g. where some memory is shared with other inferiors).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-common-software-development-environment-for-many-core-risc-v-hardware-and-virtual-platforms-gajinder-panessar-and-simon-davidmann:7e63e62b65afd74857129fe53555ff5b&#34;&gt;A common software development environment for many-core RISC-V hardware and virtual platforms: Gajinder Panessar and Simon Davidmann&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Talking today about a collaboration between Imperas and UltraSoC to provide
a common environment for debugging simulation-based and hardware debug.&lt;/li&gt;
&lt;li&gt;Chip designs are getting more complex, including asymmetric multi-core.&lt;/li&gt;
&lt;li&gt;Embedded software is increasingly important and engineering intensive.&lt;/li&gt;
&lt;li&gt;Traditionally use GDB, with one instance per core. This has little
visibility as it only sees the memory space of the attached CPU. It also gives
poor control, and bugs may occur non-deterministically.&lt;/li&gt;
&lt;li&gt;Imperas provide a commercial simulation solution, running at 100-2000MIPS.

&lt;ul&gt;
&lt;li&gt;This suports the Imperas &amp;lsquo;MPD&amp;rsquo; full platform debugger.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;UltraSoC provide IP for debug/monitoring for the whole SoC&lt;/li&gt;
&lt;li&gt;Imperas and UltraSoC have collaborated to provide a common solution.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hifive-unleashed-world-s-first-multi-core-risc-v-linux-dev-board-yunsup-lee:7e63e62b65afd74857129fe53555ff5b&#34;&gt;HiFive unleashed. World&amp;rsquo;s First Multi-Core RISC-V Linux Dev Board: Yunsup Lee&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;When Instagram was acquired for $1B it has just 13 engineers. They achieved
that partially by reusing open source software.&lt;/li&gt;
&lt;li&gt;See SiFive silicon cloud services as a parallel to Amazon AWS. Offers a
selection of CPU soft IPs, prototype ASICs, production ASICs.&lt;/li&gt;
&lt;li&gt;Talking today about the Freedom Unleashed platform. Features 4 application
cores and 1 embedded core.&lt;/li&gt;
&lt;li&gt;The HiFive Unleashed board feature an SiFive FU540-C000, 8GB DDR4, Gigabit
Ethernet port, 32MB Quad SPI flash, microSD card for removable storage,
MicroUSB for debug and serial communication, digital GPIO pins, FMC connector.&lt;/li&gt;
&lt;li&gt;Did a preliminary SPECINT2006 comparison. Competitive with A53 chips from
Rockchip or Alwinner (higher than the lower-clocked Allwinner, but slower than
the Rockchip).&lt;/li&gt;
&lt;li&gt;Open-V: a SiFive/ONCHIP microcontroller based on Freedom Everywhere. Built
in TSMC 180nm, 3.3mm x 2.6mm. 2.7M transistors. ONCHIP provided a range of
analog IP, which were integrated with a SiFive E31 core. The components will
be available through SiFive.&lt;/li&gt;
&lt;li&gt;You can now submit proposals for your own freedom chip through the
&amp;ldquo;Democratizing Ideas&amp;rdquo; program. Partners will be announced at the First Annual
RISC-V Summit in December. Deadline is the end of October.&lt;/li&gt;
&lt;li&gt;RISC-V is completing the innovation cycle of research, education, and
industry.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hifive-unleashed-expansion-kit-ted-marena:7e63e62b65afd74857129fe53555ff5b&#34;&gt;HiFive unleashed expansion kit: Ted Marena&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Marketing update: Looking for collaboration on a porting to RISC-V
whitepaper. Would also like to see member companies communicating why they
chose RISC-V.&lt;/li&gt;
&lt;li&gt;Microsemi set up the MI-V ecosystem to support various RTOSes on soft RISC-V
cores on FPGA.&lt;/li&gt;
&lt;li&gt;The Mi-V HiFive Unleashed Expansion board connects to the HiFive board via
FMC. Has PCIe connectors, SATA, HDMI, USB, microSD.&lt;/li&gt;
&lt;li&gt;Porting an application from ARM to RISC-V is the same effort as porting from
one ARM SoC to another. No two ARM SoCs have the same memory map or peripheral
functionality. Neither will RISC-V SoCs.&lt;/li&gt;
&lt;li&gt;Mi-V HiFive Unleashed board aims to accelerate the RISC-V Linux ecosystem,
enabling the community to port tools, OSes, middleware, packages to RISC-V.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;simulating-heterogeneous-multi-node-32-bit-and-64-bit-risc-v-systems-running-linux-and-zephry-with-renode-michael-gielda:7e63e62b65afd74857129fe53555ff5b&#34;&gt;Simulating heterogeneous multi-node 32-bit and 64-bit RISC-V systems running Linux and Zephry with Renode: Michael Gielda&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Antmicro: &amp;lsquo;turn ideas into software-driven products&amp;rsquo;&lt;/li&gt;
&lt;li&gt;Check out renode.io&lt;/li&gt;
&lt;li&gt;Renode is an open source instruction set simulator with a multi-layered
framework on top. It mimics entire platforms.&lt;/li&gt;
&lt;li&gt;Cores are implemented in C, and the rest is implemented in C&amp;rsquo;, Python, or
any .NET-compatible language.&lt;/li&gt;
&lt;li&gt;Strengths include transparent and robust debugging, easy integration, rich
model abstractions, &amp;hellip;&lt;/li&gt;
&lt;li&gt;Renode has a simple platform description format that is human readable,
modular, and extendible.&lt;/li&gt;
&lt;li&gt;Also have the capability to simulate entire networks or wireless and wired
devices in one time domain.&lt;/li&gt;
&lt;li&gt;Can save and restore whole simulation state.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;debian-gnu-linux-port-for-risc-v-64-bit-manuel-fernandez-montecelo:7e63e62b65afd74857129fe53555ff5b&#34;&gt;Debian GNU/Linux port for RISC-V 64-bit: Manuel Fernandez Montecelo&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Goal is to have Debian ready to install and run on RISC-V systems.&lt;/li&gt;
&lt;li&gt;Debian has more than 27k source packages, and also supports other kernels
such as FreeBSD or GNU Hurd.&lt;/li&gt;
&lt;li&gt;There are three kinds of Debian port

&lt;ul&gt;
&lt;li&gt;Those outside of Debian infrastructure, e.g. Raspbian.&lt;/li&gt;
&lt;li&gt;Unofficial/unsupported. Not in &amp;lsquo;stable&amp;rsquo; releases but hosted in Debian
infrastructure.&lt;/li&gt;
&lt;li&gt;Officially supported. Part of the &amp;lsquo;stable&amp;rsquo; releases and fully supported.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;RISC-V is currently unofficial, working its way towards officially
supported.&lt;/li&gt;
&lt;li&gt;Initial plan

&lt;ul&gt;
&lt;li&gt;Bootstrap and create viable, basic OS disk images&lt;/li&gt;
&lt;li&gt;Get it to the state of &amp;lsquo;unofficial/unsupported&amp;rsquo;&lt;/li&gt;
&lt;li&gt;Move towards an official backend&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Why not 32-bit or 128-bit variants?

&lt;ul&gt;
&lt;li&gt;Too early for 128&lt;/li&gt;
&lt;li&gt;32-bit ports struggle to get large packages built. Plus less work has been
done on 32-bit Linux-capable systems.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Started in 2016, but went in haitus until late 2017/early 2018 for Linux and
glibc upstreaming and freezing of the ABI.&lt;/li&gt;
&lt;li&gt;25th Feb - 5th March: Cross-built base set of packages&lt;/li&gt;
&lt;li&gt;5th - 13th March: First &amp;lsquo;native&amp;rsquo; build.&lt;/li&gt;
&lt;li&gt;13th - 23rd March: Second &amp;lsquo;native&amp;rsquo; build in a clean environment (isolated
environment similar to &amp;lsquo;production&amp;rsquo; auto-builders.&lt;/li&gt;
&lt;li&gt;75% of packages are now there. Progress is slowing down as many of the
remaining packages are either very large or difficult.&lt;/li&gt;
&lt;li&gt;Uncovered a range of bugs in QEMU, toolchain and so on.&lt;/li&gt;
&lt;li&gt;Manuel has a long lost of contributors to thank. Thank you to everyone who
helped make this port happen!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;fedora-on-risc-v-richard-jones:7e63e62b65afd74857129fe53555ff5b&#34;&gt;Fedora on RISC-V: Richard Jones&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Every few years Red Hat Enterprise Linux is forked from Fedora.&lt;/li&gt;
&lt;li&gt;Red Hat and Fedora have a strong upstream first policy&lt;/li&gt;
&lt;li&gt;Final bootstrap took 2 months. 16725 builds producing 12785 binary packages&lt;/li&gt;
&lt;li&gt;The current build farm contains 2 HiFive unleashed boards, 11 qemu instances
on 4 Intel servers.&lt;/li&gt;
&lt;li&gt;The server market is worth about $80B/year annually. 3 billion physical
servers are shipped a year. Of those, x86 servers are about 85% of the market
by value.&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t make these mistakes for the server market:

&lt;ul&gt;
&lt;li&gt;Require manual intervention to choose the right bootloader/kernel per
vendor&lt;/li&gt;
&lt;li&gt;Require out of tree drivers or patches&lt;/li&gt;
&lt;li&gt;No standards or constantly changing standards&lt;/li&gt;
&lt;li&gt;No organisation providing direction on server standards&lt;/li&gt;
&lt;li&gt;Incompatible variants of the ISA meaning a single kernel image can&amp;rsquo;t be
made&lt;/li&gt;
&lt;li&gt;Breaking ABIs&lt;/li&gt;
&lt;li&gt;Intimately tied to Linux so other OS vendors are excluded&lt;/li&gt;
&lt;li&gt;Dev boards being too expensive for developers&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;smallest-risc-v-device-for-next-generation-edge-computing-seiji-munetoh:7e63e62b65afd74857129fe53555ff5b&#34;&gt;Smallest RISC-V device for next-generation edge computing: Seiji Munetoh&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;First target application is authentication. HMAC-SHA256 and variants&lt;/li&gt;
&lt;li&gt;Use optical communication for host/device comms&lt;/li&gt;
&lt;li&gt;Use SRAM to emulate storage memory chip&lt;/li&gt;
&lt;li&gt;The BootROM is synthesized and embedded in the SoC&lt;/li&gt;
&lt;li&gt;The first generation processor utilises a PULPino core. Target GF14LP, 300um
x 250uM. 2KB data SRAM. Plus authentication engine, analog custom circuits
(LDO, clock/reset, PD/LED IF).&lt;/li&gt;
&lt;li&gt;Created a 2.5D integrated device, use a silicon interposer less than 1mm2.
Processor SoC plus 32KB MPI-SRAM, plus optical IO (MicroLED, MicroPD), plus
power.&lt;/li&gt;
&lt;li&gt;Evaluated the architecture using low cost FPGA boards (ZedBoard, Zybo,
Arty).&lt;/li&gt;
&lt;li&gt;Moved the instruction SRAM out of the processor die, and evaluate the
performance effect of different widths between processor and external SRAM.
Ended up using an 8-bit bus configuration.&lt;/li&gt;
&lt;li&gt;Improved SHA256 performance by adding a hwardware engine.&lt;/li&gt;
&lt;li&gt;Made a debug chip packaged in QFP64 wire-bond&lt;/li&gt;
&lt;li&gt;Currently testing the 2.5D integrated device&lt;/li&gt;
&lt;li&gt;The second generation device was taped out in Feb 2018, featuring a new SoC
design with instruction cache, RF interface, sensors.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;poster-and-demo-previews:7e63e62b65afd74857129fe53555ff5b&#34;&gt;Poster and demo previews&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Far too fast-paced to summarise. Be sure to come back tomorrow for a new
liveblog. If you&amp;rsquo;re here at the workshop, be sure to come and say hello during
the poster session.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lowRISC 0-5 milestone release</title>
      <link>http://www.lowrisc.org/blog/2018/01/lowrisc-0-5-milestone-release</link>
      <pubDate>Fri, 12 Jan 2018 14:45:57 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2018/01/lowrisc-0-5-milestone-release</guid>
      <description>&lt;p&gt;The &lt;a href=&#34;http://www.lowrisc.org/docs/ethernet-v0.5/&#34;&gt;lowRISC 0.5 milestone release&lt;/a&gt;
is now available. The various changes are best described in our &lt;a href=&#34;http://www.lowrisc.org/docs/ethernet-v0.5/&#34;&gt;accompanying
documentation&lt;/a&gt;, but the main focus
is the integration of open-source Ethernet IP. The tutorial demonstrates how
to use Ethernet support to boot with an NFS root, as well as with a rootfs on
SD card.&lt;/p&gt;

&lt;p&gt;Our main development focus currently is migrating to a newer version of the
upstream Rocket chip design and reintegrating our changes on top of that, but
we felt that the integration of Ethernet support merits a release before that
change.&lt;/p&gt;

&lt;p&gt;Please report any issues &lt;a href=&#34;https://github.com/lowRISC/lowrisc-chip&#34;&gt;on our GitHub
repository&lt;/a&gt;, or discuss on our
&lt;a href=&#34;http://listmaster.pepperfish.net/cgi-bin/mailman/listinfo/lowrisc-dev-lists.lowrisc.org&#34;&gt;mailing
list&lt;/a&gt;.
As always, thank you to everyone who has contributed in any way - whether it&amp;rsquo;s
advice and feedback, bug reports, code, or ideas.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Seventh RISC-V Workshop: Day Two</title>
      <link>http://www.lowrisc.org/blog/2017/11/seventh-risc-v-workshop-day-two</link>
      <pubDate>Wed, 29 Nov 2017 15:16:45 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/11/seventh-risc-v-workshop-day-two</guid>
      <description>

&lt;p&gt;The &lt;a href=&#34;https://riscv.org/2017/10/7th-risc-v-workshop-agenda/&#34;&gt;seventh RISC-V
workshop&lt;/a&gt; is concluding
today at Western Digital in Milpitas. I&amp;rsquo;ll be keeping a semi-live blog of
talks and announcements throughout the day.&lt;/p&gt;

&lt;h2 id=&#34;celerity-an-open-source-511-core-risc-v-tiered-accelerator-fabric-michael-taylor:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Celerity: An Open Source 511-core RISC-V Tiered Accelerator Fabric: Michael Taylor&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Built in only 9 months.&lt;/li&gt;
&lt;li&gt;Celerity is an accelerator-centric SoC with a tiered accelertor fabric.&lt;/li&gt;
&lt;li&gt;Implemented in TSMC 16nm FFC. 25mm2 die area, 385M transistors&lt;/li&gt;
&lt;li&gt;Why 511 RISC-V cores? 5 Linux-capable RV64G Rocket cores, 496-core RV32IM
mesh tiled area &amp;ldquo;manycore&amp;rdquo;, 10-core RV32IM mesh tiled array (low voltage).&lt;/li&gt;
&lt;li&gt;Used a flip-chip package.&lt;/li&gt;
&lt;li&gt;Of the 5 general purpose cores, 4 connect to the manycore array and 1
interfaces with the Binary Neural Network accelerator. Each core executes
independently within its own address space.&lt;/li&gt;
&lt;li&gt;The BaseJump manycore architecture implements the RV32IM with a 5-stage
pipeline (full forwarded, in-order, single issue). It has 4KB+4KB instruction
and data scratchpads.&lt;/li&gt;
&lt;li&gt;BaseJump Manycore Mesh Network: stores are routed based on the destination.
Simple XY-dimension routing.&lt;/li&gt;
&lt;li&gt;Each Rocket core has its own RoCC interface connecting to one of the routers
in the mesh.&lt;/li&gt;
&lt;li&gt;Uses a remote store programming model, which enables efficient
producer-consumer programming models. Offer extended instructions such as load
reserved (load value and set the reservation address),
load-on-broken-reservation (stall if the reserved address wasn&amp;rsquo;t written by
other cores), and a consumer instruction to wait on a given address/valud. No
polling or interrupts are required.&lt;/li&gt;
&lt;li&gt;Currently working on CUDA support.&lt;/li&gt;
&lt;li&gt;Can fit 42 of the &amp;ldquo;manycore&amp;rdquo; cores per mm2 (vs 5 cores per mm2 for Rocket).&lt;/li&gt;
&lt;li&gt;80% of the modules in the manycore are from the BaseJump library.&lt;/li&gt;
&lt;li&gt;For the backend, hardened each core and replicated across the die.&lt;/li&gt;
&lt;li&gt;Over 2/3rds of each manycore tile is memory.&lt;/li&gt;
&lt;li&gt;For the BNN: each core in the manycore tier executes a remote-load-store
program to orchestrate sending weights to the specialization tier via a
hardware FIFO.&lt;/li&gt;
&lt;li&gt;All code available at &lt;a href=&#34;http://opencelerity.org&#34;&gt;opencelerity.org&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Want to build the &amp;ldquo;DNA&amp;rdquo; for open source ASICs. i.e. the basic components
needs for building a full system, spanning RTL, IP cores, hardware emulation,
packaging, PCBs. See &lt;a href=&#34;http://bjump.org&#34;&gt;bjump.org&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The BaseJump STL contains several hundred modules, all parameterised.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-pulp-cores-a-set-of-open-source-ultra-low-power-risc-v-cores-for-internet-of-things-applications-pasquale-davide-schiavone:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;The PULP Cores. A Set of Open-Source Ultra-Low-Power RISC-V Cores for Internet-of-Things Applications: Pasquale Davide Schiavone&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;PULP: Parallel Ultra-Low Power.&lt;/li&gt;
&lt;li&gt;Designed for energy efficient hardware, e.g. near-sensor computation.&lt;/li&gt;
&lt;li&gt;Have a set of 3 32-bit cores currently available, and working on a 64-bit
Linux-capable core.&lt;/li&gt;
&lt;li&gt;RISCY core has a 4-stage pipeline. RV32IM[F]C. 40.7-69.3kGE. 3.19
CoreMark/MHz. Also has a number of extensions for packed SIMD, fixed point,
bit manipulation and hardware loops.&lt;/li&gt;
&lt;li&gt;Zero-riscy has a 2-stage pipeline. RV32{I,E}[M]C. 11.6-18.9kGE. 2.44
CoreMark/MHz for RV32IMC and 0.91 for RV32EC. Optimized for area.&lt;/li&gt;
&lt;li&gt;Arian core for Linux. 6-stage pipeline, RV64IMC, 185kGE, OoE execution and
in-order commit. 2.01 CoreMark/MHz.&lt;/li&gt;
&lt;li&gt;Also have a set of software tools for PULP. Virtual platform, timing model.
Have 1MIPS simulation speed with timing accuracy between 20-20% of the target
hardware. Can also profile using kcachegrind.&lt;/li&gt;
&lt;li&gt;How to verify these cores? Use constrained pseudo-random test generation in
a perturbated environment (random interrupts, stalls). The program generator
tries to maximise the code coverage, and the instruction simulation and RTL
model are compared.&lt;/li&gt;
&lt;li&gt;Large number of companies using PULP/PULPino, e.g. Mentor, GreenWaves, NXP,
Micron, Microsemi, Cadence, ST, Google, Intel.&lt;/li&gt;
&lt;li&gt;PULPissimo platform will be released Q12018, including the new microDMA
subsystem, new interrupt controller, new SDK etc. Taping out on GF22 soon.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;boom-v2-an-open-source-out-of-order-risc-v-core-chris-celio:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;BOOM v2. An open-source out-of-order RISC-V core: Chris Celio&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Out of order superscalar implementing RV64g. Open source and written in
Chisel (~16kloc). Built on top of the rocket-chip ecosystem.&lt;/li&gt;
&lt;li&gt;Advanced branch prediction. Loads can issue out-of-order with regard to
other loads and stores.&lt;/li&gt;
&lt;li&gt;Parameterised, just a few lines to instantiate a 2-wide vs 4-wide BOOM.&lt;/li&gt;
&lt;li&gt;BOOM has now been taped out! Taped out with a 2 person team in 4 months.&lt;/li&gt;
&lt;li&gt;Total LoC for the SiFive U54 Rocket is 34kloc, vs 50kloc for BOOMv2, vs
1.3mloc (Verilog) for the UltraSPARC T2.&lt;/li&gt;
&lt;li&gt;Boomv2 achieves 3.92 CoreMark/MHz (on the taped out BOOM), vs 3.71 for the
Cortex-A9.&lt;/li&gt;
&lt;li&gt;BOOMv1 had a short pipeline inspired by R10K, 21264, Cortex-A9 and a unified
issue window.&lt;/li&gt;
&lt;li&gt;BOOMv2: broke critical paths in the frontend. Put the BTB into SRAM. Also
moved hashing to its own stage.&lt;/li&gt;
&lt;li&gt;The first place+route for register file resulted in huge area. Ended up
splitting the unified issue window, splitting the physical register file,
moving issue and register read into separate stages. Then implemented 2-stage
rename and 3-stage fetch.&lt;/li&gt;
&lt;li&gt;Didn&amp;rsquo;t have the resources to support a customised register file. A
synthesised register file resulted in huge congestion when routing the wires
from the flip-flops. Instead, black-boxed the register file and hand-wrote
some Verilog to instantiate specific flip-flops, muxes, and tri-state buffers.
Effectively hand-crafting their own bit block out of standard cells.&lt;/li&gt;
&lt;li&gt;Saw about a 25% decrease in clock period, and 20% decrease in CoreMark/MHz
(due to increased load-use delay, fixable in the future). A lot of the work
was about fixing design rule check and geometry errors.&lt;/li&gt;
&lt;li&gt;Physical design is a bottleneck for agile hardware development. RTL hacking
can be rapid, but it takes 2-3 hours for synthesis results and 8-24 hours for
P+R results. Additionally, manual intervention is often required and reports
are difficult to reason about.&lt;/li&gt;
&lt;li&gt;Future directions for BOOM: further IPC and QoR improvements. Chris is
joining Esperanto Technologies, but is committed to maintain the BOOM
open-source repository.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;rocket-engines-easy-custom-risc-v-cores-through-reuse-albert-magyar:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Rocket Engines. Easy, custom RISC-V cores through reuse: Albert Magyar&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why are there so many RISC-V cores (or: why not reuse rocket?). Often a
desire to match interface to be a &amp;ldquo;drop in&amp;rdquo; replacement for an existing core,
or want to tailor microarchitecture for custom extensions. Also, may find
Rocket is over-featured for the desired design point.&lt;/li&gt;
&lt;li&gt;Less good reasons: not invented here, fear of Chisel.&lt;/li&gt;
&lt;li&gt;There are a number of pitfalls for customized cores. e.g. introducing bugs
that have long since been avoided in Rocket.&lt;/li&gt;
&lt;li&gt;Avoid reusing either too little or too much. Can reuse individual components
without using the top-level rocket-chip framework at all. Stitch together
individual components.&lt;/li&gt;
&lt;li&gt;The &amp;ldquo;big 3&amp;rdquo; components: CSR file, decoder, RISC-V compressed (RVC) expander.&lt;/li&gt;
&lt;li&gt;produced a new RISC-V core IP: &amp;ldquo;BottleRocket&amp;rdquo;. This has a classic
three-stage pipeline with a similar microarchitecture to Z-Scale and V-Scale.
Implements RV32IMC. The generator produces a single, easy to connect tile.&lt;/li&gt;
&lt;li&gt;Supports debug, test, platform features: 0.13 debug spec, RVFI trace port,
external interrupt controller.&lt;/li&gt;
&lt;li&gt;The open sourcing effort is underway, as is the integration with
riscv-formal.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-perspective-on-the-role-of-open-source-ip-in-government-electronic-systems-linton-salmon:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;A Perspective on the Role of Open-Source IP in Government Electronic Systems: Linton Salmon&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The USD Department of Defence (DoD) needs custom SoCs. Custom ICs are
necessary to reach the target GOps/W. Computation requirements keep growing,
and real-time results are often required.&lt;/li&gt;
&lt;li&gt;Current DoD architectures often use older technology nodes. Now moving
towards newer technology nodes (28nm and below).&lt;/li&gt;
&lt;li&gt;Most of the cost for DoD custom SoCs is in design. Typically low volume (1k
parts). For small volume, find design costs 92%, fab NRE 7%, 1% production
costs.&lt;/li&gt;
&lt;li&gt;Design cost are skyrocketing, increasingly dramatically with each technology
node. This is a huge problem for the low volume DoD designs.&lt;/li&gt;
&lt;li&gt;Is open source IP the answer? The good news is that it can sharply reduce
resources, time and complexity or a DoD custom SoC design. Open source IP
permits increased use of unique DoD security approaches.&lt;/li&gt;
&lt;li&gt;The not so good news: the open source community needs to develop a complete
infrastructure, needs to e more robust than it is today, the community needs a
model to fund infrastructure, and the support model must assure long term
support and continued development of open source IP.&lt;/li&gt;
&lt;li&gt;Unique differentiation doesn&amp;rsquo;t require development of the entire platform.
Want to put all the effort into the differentiating &amp;ldquo;secret sauce&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Open source IP can address both the cost and availability of standard IP.
Open source IP macros are a critical first step, but integration IP is also
needed.&lt;/li&gt;
&lt;li&gt;Open source IP enables specialisation. It provides the blocks and standard
infrastructure that can then be specialised.&lt;/li&gt;
&lt;li&gt;Open source IP enables greater scrutiny by the DoD to ensure trust:
assurance it will only do as specified.&lt;/li&gt;
&lt;li&gt;Hardware security requires the ability to modify the SoC, including 3d party
IP. Added security capabilities require a robust base and infrastructure.&lt;/li&gt;
&lt;li&gt;RISC-V is an adaptable open standard. RISC-V processors can be built in a
way that can be trusted, and RISC-V can be used to enable increased security
(easy to add security extensions).&lt;/li&gt;
&lt;li&gt;Need a full ecosystem infrastructure. Need to cover the entire
infrastructure, be robust, and easy to use.&lt;/li&gt;
&lt;li&gt;DoD requires robustness and dependability of the open-source infrastructure.
Need complete verification, clear documentation, robustness validated through
to silicon implementation and test. This is not the role or the strength of
universities.

&lt;ul&gt;
&lt;li&gt;Savings requires the ability to depend on the open source IP.&lt;/li&gt;
&lt;li&gt;Savings require the robustness of the IP across extended performance
ranges.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Need a model to fund long-term infrastructure. This isn&amp;rsquo;t the role of DARPA,
which funds projects rather than infrastructure. Much of the work is
difficult, but not exciting.&lt;/li&gt;
&lt;li&gt;Need continual maintenance and improvement. Regular updates in terms of
performance, architecture, and fabrication technology.&lt;/li&gt;
&lt;li&gt;DARPA programs driving open source IP: PERFECT, CRAFT, SSITH, POSH, IDEA.&lt;/li&gt;
&lt;li&gt;CRAFT&amp;rsquo;s goal is to enable more efficient custom IC design/fabrication to
enable high performance electronic solutions faster and with more flexibility.&lt;/li&gt;
&lt;li&gt;SSITH: develop hardware design tools and IP to provide inherent security
against hardware vulnerabilities that are exploited through software in DoD
and commercial electronic systems.&lt;/li&gt;
&lt;li&gt;IDEA: no &amp;ldquo;human in the lop&amp;rdquo; 24-hour layout generation for mixed signal ICs,
systems in package, and PCBs. Machine generated layout of electrical circuits
and systems.&lt;/li&gt;
&lt;li&gt;POSH: an open source System on Chip design and IP ecosystem.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;boosting-risc-v-isa-with-open-source-peripherals-an-soc-for-low-power-sensors-elkim-roa:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Boosting RISC-V ISA with Open Source Peripherals. An SoC for Low Power Sensors: Elkim Roa&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Challenges: ready-to-plug IP and expensive licenses.&lt;/li&gt;
&lt;li&gt;Been working with SiFive, providing IP blocks for the always-on domain.&lt;/li&gt;
&lt;li&gt;The power management unit is a state machine running a microcode program
that triggers events as necessary.&lt;/li&gt;
&lt;li&gt;Have implemented a wide range of IP: low-noise bandgap voltage reference,
LDO, biasing control, crystal low-frequency driver (XTAL-RF), RC Oscillator,
brownout detector, power-on reset, multi-resolution DAC and ADC, fully
synthesized true random number generator&lt;/li&gt;
&lt;li&gt;Finally, integrated these always-on domain blocks in a TSMC180nm SoC using
Chisel at the top level.&lt;/li&gt;
&lt;li&gt;Deliverables: releasing Verilog models, FSM Verilog RTL, documentation etc
through the freechips project. Schematics and layout available through the
SiFive Designshare program.&lt;/li&gt;
&lt;li&gt;Taping out at the end of the year with SiFive, also want to include PHYs
like SATA, PCIe, USB next year. Hope to have a qualified range of IP in 2019.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;picosoc-how-we-created-a-risc-v-based-asic-processor-using-a-full-open-source-foundry-targeted-rtl-to-gds-flow-and-how-you-can-too-tim-edwards:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;PicoSoC: How we created a RISC-V based ASIC processor using a full open source foundry-targeted RTL-to-GDS flow, and how you can, too!: Tim Edwards&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Created an ASIC version of a RISC-V core (PicoRV32) using an entirely open
source toolflow.&lt;/li&gt;
&lt;li&gt;Targeting a 180nm process.&lt;/li&gt;
&lt;li&gt;Open source synthesis toolchain: qflow is built using yosys/ABC, vesta,
graywolf, qrouter, magic, netgin, iverilog, ngspice.&lt;/li&gt;
&lt;li&gt;PicoSoC includes a UART, SPI memory controller, scratchpad SRAM, and SPI
flash. Started the SoC targeting the open source Lattice ice40 flow, and add
padframe, power-on-reset, and generated SRAM to target ASIC.&lt;/li&gt;
&lt;li&gt;Can perform cosimulation using iverilog and ngspice.&lt;/li&gt;
&lt;li&gt;The PicoSoC core is 1mm2, with analog+SRAM+padframe, 2mm x 1.5mm.&lt;/li&gt;
&lt;li&gt;Can reproduce this yourself using the efabless IP catalog and the efablass
CloudV-based design environment.&lt;/li&gt;
&lt;li&gt;This is brought together in the efabless Open Galaxy Design Environment.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tilelink-a-free-and-open-source-high-performance-scalable-cache-coherent-fabric-designed-for-risc-v-wesley-terpstra:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;TileLink. A free and open-source, high-performance scalable cache-coherent fabric designed for RISC-V: Wesley Terpstra&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Requirements for a RISC-V bus: Open standard, easy to implemented,
cache-coherent block motion, multiple cache layers, reusable on and off-chip,
and high performance.&lt;/li&gt;
&lt;li&gt;What about AMBA CHI/ACE?

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Open standard? CHI is not open!&amp;rdquo;. Can&amp;rsquo;t get hold of the spec.&lt;/li&gt;
&lt;li&gt;Not easy to implement: 10 probe message types, split control/data, narrow
bursts, &amp;hellip;&lt;/li&gt;
&lt;li&gt;No support for multiple cache layers.&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t want to depend on a standard controlled by a RISC-V competitor&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;TileLink was a clean slate project out of UC Berkeley. Featured a reduced
message protocol, assumed all connected hardware is trusted (do security
checking at the source, not in the network), and only supports power-of-2
block transfers.&lt;/li&gt;
&lt;li&gt;TileLink is a master-slave point-to-point protocol. It&amp;rsquo;s message based with
5 priorities. Out-order design with optional ordering. It&amp;rsquo;s designed for
composability and deadlock freedom.&lt;/li&gt;
&lt;li&gt;TileLink is open source and in production. Over 30 public modules including
cores, crossbars and adapters. Has a coherency manager similar to how ACE does
snooping. Also have bridges to AXI/AHB/APB&lt;/li&gt;
&lt;li&gt;SiFive chips use a banked directory-based wormhole MESI L2$.&lt;/li&gt;
&lt;li&gt;There are a few simplifying assumptions that make the protocol easier to
work with.

&lt;ul&gt;
&lt;li&gt;Require there are no agent loops, i.e. the bus participants (agents) form
a directed acyclic graph.&lt;/li&gt;
&lt;li&gt;There are strict priorities. Messages have one of five priorities, and
lower priority messages never block higher priority messages. Responses have
a higher priority than requests.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The on-chip TileLink wire protocol uses an independent channel for each
message priority. Messages are transmitted using multi-beat bursts. Use
ready-valid.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-risc-v-vector-isa-roger-espasa:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;The RISC-V Vector ISA: Roger Espasa&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why a vector extension? Reduce instruction bandwidth, reduce memory
bandwidth, lower energy, exposes DLP, masked execution, gather/scatter.
Scalable from small to large vector processing unit.&lt;/li&gt;
&lt;li&gt;The vector ISA in a nutshell

&lt;ul&gt;
&lt;li&gt;32 vector registers. Each can hold either a scalar, vector, or a matrix
(shape). Each has an associated type (polymorphic encoding). There are a
variable number of registers (dynamically changeable).&lt;/li&gt;
&lt;li&gt;Vector instruction semantics: all instructions are controlled by the
Vector Length (VL) register and can be executed under mask. Precise
exceptions are supported.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Suppose you&amp;rsquo;re adding two vector registers: &lt;code&gt;vadd v1, v2 -&amp;gt; v0&lt;/code&gt;. If the
vector length is less than maximum vector length, the remaining values must be
zeroed.&lt;/li&gt;
&lt;li&gt;You could implement this how you like. Might choose to have a 2-lane
implementation (two FP adders), or 4-lane, or even 8-lane (SIMD, doing all in
one cycle). The number of lanes is transparent to the programmer and the same
code runs independent of the number of lanes.&lt;/li&gt;
&lt;li&gt;Data inside a VREG could be a single scalar value, a vector, or a matrix
(optionally). The current shape is held in the per-vreg type field.

&lt;ul&gt;
&lt;li&gt;e.g. &lt;code&gt;vadd v1, v2.s -&amp;gt; v0&lt;/code&gt;. This adds the scalar value in v2 to every
value in vector v1.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Masks are stored in regular vector registers (i.e. there will not be
separate mask registers). Masks are computed with compare operations, and
instructions use 2 bits of encoding to select masked execution.

&lt;ul&gt;
&lt;li&gt;e.g. &lt;code&gt;vadd v3, v4, v1.t -&amp;gt; v5&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;v1 is the only register used as mask source.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Vector load (unit stride). &lt;code&gt;vld 80(x3) -&amp;gt; v5&lt;/code&gt; will Vector Length elements.&lt;/li&gt;
&lt;li&gt;Stride vector load. &lt;code&gt;vlds 80(x3, x9) -&amp;gt; v5&lt;/code&gt; performs a strided load.&lt;/li&gt;
&lt;li&gt;Gather (indexed vector load). &lt;code&gt;vldx 80(x3, v2) -&amp;gt; v5&lt;/code&gt;. This uses a vector to
hold offsets. Repeated addresses are legal.&lt;/li&gt;
&lt;li&gt;Vector store: &lt;code&gt;vst v5 -&amp;gt; 80(x3)&lt;/code&gt;. Note that zeroes won&amp;rsquo;t be written when MVL
is larger than the vector length.&lt;/li&gt;
&lt;li&gt;Scatter (indexed vector store). &lt;code&gt;vstx v5 -&amp;gt; 80(x3, v2)&lt;/code&gt;. Will probably have
two version of scatter, where one has guarantees about the ordering or stores
to repeated addresses.&lt;/li&gt;
&lt;li&gt;Ordering:

&lt;ul&gt;
&lt;li&gt;From the point of view of a given hart, vector loads and stores happen in
order. You don&amp;rsquo;t need any fences to see your own stores.&lt;/li&gt;
&lt;li&gt;From the point of view of other harts, see the vector memory accesses as
if done by a scalar loop. This means they can be seen out-of-order by other
harts.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Typed vector registers:

&lt;ul&gt;
&lt;li&gt;Each vector register has an associated type, which can be different for
different registers.&lt;/li&gt;
&lt;li&gt;Types can be mixed in an instruction under certain rules.&lt;/li&gt;
&lt;li&gt;Register types enable a &amp;ldquo;polymorphic&amp;rdquo; encoding an is also more scalable
for the future.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;vcvt is used for type and data conversions.&lt;/li&gt;
&lt;li&gt;In some cases, types can be mixed in an instruction. e.g. adding &lt;code&gt;v1_i8, 
v2_i64 -&amp;gt; v0_i64&lt;/code&gt;. When any source is smaller than the destination, the source
is promoted to the destination size.&lt;/li&gt;
&lt;li&gt;The size of the vector register file is not set by the ISA. It is configured
by writing to the vdcfg CSR. When doing this, the hardware computes the
maximum vector length. This configuration can be done in user mode.

&lt;ul&gt;
&lt;li&gt;One implementation choice is to always return the same MVL, regardless of
config. Alternatively, split storage across logical registers, perhaps
losing some space.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;E.g the hardware has 32 registers, 4 elements per vector, each 4 bytes = 512
bytes. If the user asks for 32 F32 registers, &lt;code&gt;MVL = 512B / (32 * 4) = 4&lt;/code&gt;. If
the user asked for only 2 F32 registers, &lt;code&gt;MVL = 512B / (4+4) = 64&lt;/code&gt;. But it
would be legal for the implementation to return something smaller, e.g. 4 as
in the previous example.&lt;/li&gt;
&lt;li&gt;If the user asks for 2 F16 regs and 2 F32 registers, &lt;code&gt;MVL = 512B / (12B + 
4B) = 32&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;MVL is transparent to software, meaning code can be portable across
different number of lanes and different values of MVL.&lt;/li&gt;
&lt;li&gt;Not covered today: exceptions, kernel save + restore, custom types, or
matrix shapes.&lt;/li&gt;
&lt;li&gt;Goal is to be the best vector ISA ever! Expect LLVM and GCC to support it.&lt;/li&gt;
&lt;li&gt;Current spec on GitHub is out-of-date.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;security-task-group-update-and-risc-v-security-extension-richard-newell:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Security task group update and RISC-V security extension: Richard Newell&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The security working group works in two main areas. Trusted execution /
isolation and cryptographic extensions. Recently had changes in direction for
trusted execution / isolation.&lt;/li&gt;
&lt;li&gt;This talk will focus on the cryptographic extensions status. Hope to have a
written spec for the next workshop.&lt;/li&gt;
&lt;li&gt;Want to rely heavily on the vector extensions for crypto.&lt;/li&gt;
&lt;li&gt;Use vector functional units to perform modular and Galois Field arithmetic
needed for existing popular and promising post-quantum asymmetric cryptography
schemes. Also accelerate symmetric block ciphers and digest algorithms taking
advantage of the wide vector registers, using specialized VFUs (e.g. AES,
SHA-2).&lt;/li&gt;
&lt;li&gt;Asymmetric crypto acceleration: use hardware support for modular arithmetic,
but software for group operations and point multiplication.&lt;/li&gt;
&lt;li&gt;Propose vector element widths up to 4096, as well as an escape mechanism to
allow larger widths or non-power-of-two widths.&lt;/li&gt;
&lt;li&gt;Intend to use just one major opcode for the cryptographic extension.&lt;/li&gt;
&lt;li&gt;Richard presented a handy slide summarising the algorithms used in crypto
suites / libraries. Be sure to check it out once the slides become available!&lt;/li&gt;
&lt;li&gt;Proposing to define profiles that define the required crypto algorithms.
e.g. a profile for &amp;ldquo;internet&amp;rdquo;, &amp;ldquo;finance&amp;rdquo;, and &amp;ldquo;cellular&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;using-proposed-vector-and-crypto-extensions-for-fast-and-secure-boot-richard-newell:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Using proposed vector and crypto extensions for fast and secure boot: Richard Newell&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Richard is giving a great summary of implementing various crypto algorithms
using the proposed crypto extensions, but unfortunately it&amp;rsquo;s difficult to
summarise the information presented in these diagrams.&lt;/li&gt;
&lt;li&gt;Expect a huge speedup vs the ARM Cortex-M3 for an appropriate RV32IVY
implementation (though very dependent on the hardware that is implemented).&lt;/li&gt;
&lt;li&gt;Performed a case study using WalnutDSA signature verification, developed by
SecureRF. Saw a 3x speedup with crypto extensions vs without crypto
extensions.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;using-risc-v-as-a-security-processor-for-darpa-chips-and-commercial-iot-mark-beal:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Using RISC-V as a security processor for DARPA CHIPS and Commercial IoT: Mark Beal&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This talk is about leveraging RISC-V to deliver integrated hw/sw silicon IP.&lt;/li&gt;
&lt;li&gt;The Intrinsix secure execution environment contains a tiny RISC-V core,
crypto engines, secure fabric, as well as software.&lt;/li&gt;
&lt;li&gt;Add a security CPU to provide an isolated execution environment. It&amp;rsquo;s easier
to verify the separation between secure and non-secure actions. Costs less
than 1% of silicon area (20K gates).&lt;/li&gt;
&lt;li&gt;Implement RV32IC with machine and user modes. 2-stage pipeline with a local
ROM And RAM. The IRAM can only hold signed code, is fetch-only, and is locked
after authentication.&lt;/li&gt;
&lt;li&gt;Security RV32 runs signed firmware in user mode, and only executes from
hardwired ROM in machine mode.&lt;/li&gt;
&lt;li&gt;Suppose you have Zephyr running on Rocket, using TinyCrypt as the crypto
API. Replace TinyCrypt on Rocket with a call to an API running on the Secure
RV32.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;isa-formal-task-group-update-rishiyur-nikhil:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;ISA Formal Task Group Update: Rishiyur Nikhil&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;A formal spec is a key requirement to be able to definitively answer
questions about compiler correctness and implementation correctness. e.g. will
executing this RISC-V program on this implementation produce correct results?&lt;br /&gt;
For all RISC-V programs?&lt;/li&gt;
&lt;li&gt;Clifford Wolf has demonstrated the value of formal spaces in identifying
bugs in most publicly available RISC-V implementations.&lt;/li&gt;
&lt;li&gt;The formal spec must be clear and understandable to the human reader,
precise and complete, machine readable, executable, and usable with a variety
of formal tools.

&lt;ul&gt;
&lt;li&gt;English-text specs and instruction set simulators can be regarded as
specs, but typically do not meet many of these goals.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Our approach is to use a very minimal subset of Haskell to define a spec
that is directly executable in Haskell. Then provide parsers to connect to
other formal tools and formats.&lt;/li&gt;
&lt;li&gt;See the current prototype
&lt;a href=&#34;https://github.com/mit-plv/riscv-semantics&#34;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Done: RV32I/RV64I, M, priv spec M. Currently ignoring memory model issues.
Soon want to implement privilege spec supervisor mode, then A, C, F, D,
integration with the memory model.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;strong-formal-verification-for-risc-v-adam-chlipala:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Strong formal verification for RISC-V: Adam Chlipala&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Simplify: start by proving a shallow property, proving some straight-forward
invariants.&lt;/li&gt;
&lt;li&gt;Simplify: analyze isolated components and build larger components by
composing them.&lt;/li&gt;
&lt;li&gt;Want to avoid starting over for each design. Instead prove a property once
for all parameters.&lt;/li&gt;
&lt;li&gt;Kami is a framework to support implementing, specifying, formally verifying,
and compiling hardware designs. It is based on the Bluespec high-level
hardware design language and the Coq proof assistant.&lt;/li&gt;
&lt;li&gt;The big ideas (from Bluespec):

&lt;ul&gt;
&lt;li&gt;Program modules are objects with mutable private state accessed via
methods.&lt;/li&gt;
&lt;li&gt;Every method call appears to execute atomically. So any step is summarized
by a trace of calls.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Object refinement is inclusion of all possible traces.&lt;/li&gt;
&lt;li&gt;Composing objects hides internal method calls.&lt;/li&gt;
&lt;li&gt;Use standard Coq ASCII syntax for mathematical proofs. These are checked
automatically, just like type checking. Also benefit from streamlined IDE
support for Coq.&lt;/li&gt;
&lt;li&gt;Implement a design, which can be refined to check it against the spec (Coq
tactics are used to prove the refinements). The design is also used to
generate the RTL.&lt;/li&gt;
&lt;li&gt;We are building a translator for the formal RISC-V ISA spec into the
language of Coq/Kami.&lt;/li&gt;
&lt;li&gt;Building an open library of formally verified components. Built a
microcontroller-class RV32I. Working on desktop-class RV64IMA. Also have a
cache-coherent memory system.&lt;/li&gt;
&lt;li&gt;Reuse our proofs when composing our components with your own formally
verified accelerators.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;grvi-phalanz-update-jan-gray:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;GRVI Phalanz Update: Jan Gray&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The industry is looking to FPGAs to help accelerate cloud workloads.&lt;/li&gt;
&lt;li&gt;Software challenge is how to map you multithreaded C++ app to your
accelerator. On the hardware side, you want to avoid endless tapeouts as you
tweak your algorithm.&lt;/li&gt;
&lt;li&gt;GRVI Phalanx Accelerator Kit is a parallel processor overlay for
software-first accelerators. Recompile your application and run on hundreds of
RISC-V cores.&lt;/li&gt;
&lt;li&gt;GRVI: FPGA-efficient RISC-V processing element. No CSRs or exceptions, but
does implement mul and lr/sc.

&lt;ul&gt;
&lt;li&gt;3-stage pipeline with some resources shared by a pair of cores. Fits in
320 LUTs.&lt;/li&gt;
&lt;li&gt;Take 8 of these and connect to form a cluster (8PEs, shared RAM). Takes
approximately 3500 LUTs.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Compose cores using message passing on the FPGA-optimised Hoplite NoC.&lt;/li&gt;
&lt;li&gt;Use a partitioned global address space (PGAS).&lt;/li&gt;
&lt;li&gt;Phalanx: fabric of clusters of PEs, memories, IOs&lt;/li&gt;
&lt;li&gt;FPGAs used in the AWS F1 are huge, over 1.3M LUTs. Last December, fit 1680
RISC-V cores on that FPGA. 250MHz, 420GIPS, 2.5TB/s cluster memory bandwidth,
&amp;hellip;&lt;/li&gt;
&lt;li&gt;Working on a GRVI Phalanx SDK. Bridge the Phalanx and AX4 system interfaces
with message passing bridges.&lt;/li&gt;
&lt;li&gt;8-80 cores on the Pynq.&lt;/li&gt;
&lt;li&gt;Can fit 884 cores on the FPGA on the F1 with 3 DDR controllers, 1240 with 1
DDR controller.&lt;/li&gt;
&lt;li&gt;Currently program using bare metal multithreaded C++ and message. Working on
an OpenCL-based solution. Use the new &amp;lsquo;SDAccell for RTL&amp;rsquo;.&lt;/li&gt;
&lt;li&gt;SDK coming, allowing 8-80-800-10000 core designs. All enabled by the
excellent RISC-V ecosystem.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-tightly-coupled-light-weight-neural-network-processing-unit-with-risc-v-core-lei-zhang:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;A tightly-coupled light-weight neural network processing unit with RISC-V Core: Lei Zhang&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Neural networks can be used to replace computation-intensive but
error-resilient code.&lt;/li&gt;
&lt;li&gt;Connected a tightly-coupled neural accelerator to a Rocket core through the
RoCC interface.&lt;/li&gt;
&lt;li&gt;Extended the instruction set. Added NPE instructions for neural accelerator
initialisation and invocation. Also DMA instructions for data initialization
in a buffer. Finally, AGU instructions for data streaming from buffer to
processing elements.&lt;/li&gt;
&lt;li&gt;The Neural Accelerator is a one-dimensional systolic array.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lacore-a-risc-v-based-linear-algebra-accelerator-for-soc-designs-samuel-steffi:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Lacore: A RISC-V based linear algebra accelerator for SoC designs: Samuel Steffi&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Linear algebra is a foundation of high performance computing.&lt;/li&gt;
&lt;li&gt;Most HPC apps can be reduced to a handful of computation classes:
sparse/dense linear algebra, FFT, structured/unstructured grids. These all
have overlap with linear algebra.&lt;/li&gt;
&lt;li&gt;LACore targets a wide range of applications and tries to overcome hardware
issues of other approaches (GPU, fixed-function accelerators).&lt;/li&gt;
&lt;li&gt;Five main pieces in the LACore additions to the scalar SCPU

&lt;ul&gt;
&lt;li&gt;LAExecUnit: mixed-precision systolic datapath connected to LAMemUnits with
FIFOs. 3 inputs and 1 output, dual precision (32 and 64-bit). Datapath
consists of a vector unit and a reduction unit.&lt;/li&gt;
&lt;li&gt;LAMemUnits: read and write data-streams to the datapath FIFOs and
LACache/Scratchpad. Can read or write scalars, vectors, matrices, and sparse
matrices.&lt;/li&gt;
&lt;li&gt;LAcfg provides configuration to LAMemUnits. These registers hold all info
about data-stream type, precision, location etc.&lt;/li&gt;
&lt;li&gt;64kb scratchpad (3r1w).&lt;/li&gt;
&lt;li&gt;64kb LACache with 4 ports (3r1w) and 16 banks&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Adding 68 new instructions, broadly split into 3 classes: configuration,
data movement, and execution.&lt;/li&gt;
&lt;li&gt;The LACoreAPI allows the accelerator to be programmed.&lt;/li&gt;
&lt;li&gt;Started by implementing in gem5. This was ~25kloc of C++ and Python.&lt;/li&gt;
&lt;li&gt;Implemented the HPC Challenge (HPCC) benchmark suite. Compared versus a
in-order RISC-V core, superscalar x86 core with SSE2, and equivalent Fermi GPU
with 2 streaming multiprocessors. LACore saw a speedup of 3.43x over x86,
10.72x vs baseline RISC-V, and 12.04 vs the GPU baseline.&lt;/li&gt;
&lt;li&gt;Estimated area is only 2.53x the area of a single RISC-V scalar CPU and
0.60x the area of the equivalent GPU.&lt;/li&gt;
&lt;li&gt;Freely available &lt;a href=&#34;https://github.com/scale-lab/la-core&#34;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Currently working a LACore multi-core design and evaluation, as well as an
ASIC implementation and eventual tapeout.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;packet-manipulation-processor-a-risc-v-vliw-core-for-networking-applications-salvatore-pontarelli:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Packet manipulation processor. A RISC-v VLIW core for networking applications: Salvatore Pontarelli&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Network &amp;ldquo;softwareization&amp;rdquo; is seen as the optimal solution to design next
generation network infrastructures, services, and applications.&lt;/li&gt;
&lt;li&gt;Want high speed: 100-200Gbps (as achievable with FPGAs and network
processors) and beyond, 5Tbps as achievable with programmable forwarding
dataplanes.&lt;/li&gt;
&lt;li&gt;Propose an architecture where programmable forwarding dataplanes are
augmented with a PMP (packet manipulation processor)&lt;/li&gt;
&lt;li&gt;Design a small, efficient CPU for packet manipulation. Deploy the PMP at the
output port. Want to process packets at 10/40Gbps.&lt;/li&gt;
&lt;li&gt;Possible programmable actions: inband packet reply, custom tunneling,
NAT/PNAT.&lt;/li&gt;
&lt;li&gt;The PMP has a small instruction memory (typically need less than 8K
instructions). Small data memory (8KB). Flat memory, no cache hierarchy.&lt;/li&gt;
&lt;li&gt;PMP throughput: 10Gbps is 14.88Mpps, 67 clock cycles at 1GHz. A multi-core
CPU is one approach, but has challenges regarding the reordering of packets.
Pursue a VLIW solution instead.&lt;/li&gt;
&lt;li&gt;The PMP is a static 8-issue VLIW RISC-V core with the RV32I instruction set.
Has a 32-bit dataplane (to be upgraded). Written in VHDL. Features branch
prediction, lane forwarding.&lt;/li&gt;
&lt;li&gt;Implemented in a NetFPGA based programmable dataplane.&lt;/li&gt;
&lt;li&gt;Synthesized at 250MHz on FPGA.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;adding-a-binarized-cnn-accelerator-to-risc-v-for-person-detection-guy-lemieux:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Adding a Binarized CNN Accelerator to RISC-V for Person Detection: Guy Lemieux&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This talk uses VectorBlox Vector instructions, which are not the same as the
vector instructions proposed in the RISC-V vector working group.&lt;/li&gt;
&lt;li&gt;Prototyped in the Lattice iCE40 UltraPlus FPGA (5280 LUTs, 1Mb SRAM).&lt;/li&gt;
&lt;li&gt;Inspired by BinaryConnect. Built a custom database, performed other
optimisations, and managed 98% accuracy.&lt;/li&gt;
&lt;li&gt;Use Orca (open source, BSD licensed). Written in VHDL, 200MHz fully
pipelined, less than 2000 4LUTs.&lt;/li&gt;
&lt;li&gt;Added streaming vector extensions and binary CNN accelerator.&lt;/li&gt;
&lt;li&gt;The streaming vector instructions (SVE) operate only on stream memory. Add
streaming version of all the base RV32 integer operations, multiply
instructions. Add in some extra instructions such as mov, conditional move,
comparisons, and vector control instructions. Packed SIMD can be supported
naturally with this approach to vectors.&lt;/li&gt;
&lt;li&gt;Would also like to add an extra SVE extension for DMA.&lt;/li&gt;
&lt;li&gt;SVE has a base 32-bit encoding, as well an extended 64-bit encoding.&lt;/li&gt;
&lt;li&gt;Can redirect the data to a domain-specific streaming pipeline.&lt;/li&gt;
&lt;li&gt;4852 4-input LUTs for the whole solution.&lt;/li&gt;
&lt;li&gt;Releasing the VectorBlox instruction set as an open specification, and
joining the RISC-V vector working group to discuss it as a potential
alternative.&lt;/li&gt;
&lt;li&gt;SVE vs the RISC-V vector extension

&lt;ul&gt;
&lt;li&gt;A &amp;ldquo;memory-to-memory&amp;rdquo; architecture, challenging the conventional wisdom of
RISC.&lt;/li&gt;
&lt;li&gt;No named vector registers in the ISA (no register allocation, no compiler
changes needed)&lt;/li&gt;
&lt;li&gt;High performance. Free loop unrolling, no saving/restoring of vector data.&lt;/li&gt;
&lt;li&gt;No storage wasted with streaming memory. Free software scratchpad if
vectors aren&amp;rsquo;t used.&lt;/li&gt;
&lt;li&gt;Easier/simpler hardware. Double-buffered DMA instead of prefetching +
vector register renaming.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc5-improving-support-for-risc-v-in-gem5-alex-roelke:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;RISC5. Improving support for RISC-V in gem5: Alex Roelke&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;gem5 is a popular cycle approximate simulator, which can be very useful in
RISC-V hardware development.&lt;/li&gt;
&lt;li&gt;RISC-V in gem5 supports RV64GC. It uses syscall emulation and doesn&amp;rsquo;t yet
support the privileged ISA.&lt;/li&gt;
&lt;li&gt;Implemented the release consistency memory model for atomics.&lt;/li&gt;
&lt;li&gt;Floating point support was verified against spike and a hardware design.&lt;/li&gt;
&lt;li&gt;The main challenge when implementing the compressed instruction was
interfacing with gem5&amp;rsquo;s existing decode logic.&lt;/li&gt;
&lt;li&gt;In the future, want to support multithreaded workloads in syscall emulation
mode, enable full system mode (privileged ISA), and correct minor differences
(e.g. floating point rounding).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;renode-a-flexible-open-source-simulation-for-risc-v-system-development-michael-gielda:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;Renode. A flexible open-source simulation for RISC-V system development: Michael Gielda&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;AntMicro was founded in 2009 and has been developing Renode since 2010.&lt;/li&gt;
&lt;li&gt;Why did we build Renode? Observed data workflows for embedded development.
Needed a fast simulator for software developers, as close to production as
possible. Must support multi-node simulation, easy reuse of models, and be
extensible.&lt;/li&gt;
&lt;li&gt;It is an instruction set simulator, mostly written in C#. It supports fully
deterministic execution, transparent debugging, integration with familiar
tools (e.g. GDB).&lt;/li&gt;
&lt;li&gt;Renode is open source, has a flexible structure and is constructed out of
modular building blocks.&lt;/li&gt;
&lt;li&gt;The platform description format is human readable, modular, and extendible.&lt;/li&gt;
&lt;li&gt;Worked with Microsemi to support the Mi-V platform, integrate with
SoftConsole IDE, and support Windows as a first-class platform.&lt;/li&gt;
&lt;li&gt;Renode supports a range of handy features, such as fault injection,
record/replay, and more.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;qemu-based-hardware-modelling-of-a-multi-hard-risc-v-soc-daire-mcnamara:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;QEMU-based hardware modelling of a multi-hard RISC-V SoC: Daire McNamara&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Wanted to explore have separate execution contexts on the same SoC that are
free from interference (e.g. one core running an RTOS, while others run a
general purpose OS).&lt;/li&gt;
&lt;li&gt;In the SiFive Unleashed platform, the E51 provides services for other U54
harts.&lt;/li&gt;
&lt;li&gt;E51 services/peripheral drivers are implemented as event-driven state
machines. These are describes via a structure and states are named.&lt;/li&gt;
&lt;li&gt;Needed an emulator to model all of this.&lt;/li&gt;
&lt;li&gt;Modified RISC-V QEMU:

&lt;ul&gt;
&lt;li&gt;Updated privileged spec support.&lt;/li&gt;
&lt;li&gt;Hart synchronisation (IPIs)&lt;/li&gt;
&lt;li&gt;Modelling physical memory protection&lt;/li&gt;
&lt;li&gt;PLIC, CLINT, local interrupts&lt;/li&gt;
&lt;li&gt;Support for managing contexts of multiple harts&lt;/li&gt;
&lt;li&gt;Modelling L1/L2 cache configuration register writes/reads&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;U54-MC QEMU hasn&amp;rsquo;t yer been upstreamed to the main RISC-V QEMU github repo
yet.&lt;/li&gt;
&lt;li&gt;Can boot Linux to console and interact, but it&amp;rsquo;s a little slow (takes about
15 minutes).&lt;/li&gt;
&lt;li&gt;Future plans: improve speed, add vectorisation for local interrupts, device
tree support, QOM, remote control of real hardware. Finally, clean up and
upstream.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;firesim-cycle-accurate-rack-scale-system-simulation-using-fpgas-in-the-public-cloud-sagar-karandikar:b3d82df2c32815668820ecff5dcd0b9a&#34;&gt;FireSim. Cycle-Accurate Rack-Scale System Simulation using FPGAs in the Public Cloud: Sagar Karandikar&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why simulate datacenters? Next-gen datacenters won&amp;rsquo;t be built only from
commodity components, and custom hardware is changing faster than ever.&lt;/li&gt;
&lt;li&gt;Our simulator needs to model hardware at scale (CPUs down to
microarchitecture, fast networks and switches, novel accelerators), run real
software, and be usable.&lt;/li&gt;
&lt;li&gt;One way to test would be to build the hardware, get the chips back, then
network together into a datacenter. This has obvious disadvantages.&lt;/li&gt;
&lt;li&gt;Alternatively, use a software simulator. Easy to prototype new hardware this
way, but also easy to model something that you can&amp;rsquo;t build. Additionally, it
can be very slow to run, requiring the use of small microbenchmarks or
sampling.&lt;/li&gt;
&lt;li&gt;Or, build a hardware-accelerated simulator (see DIABLO). You need to
hand-write RTL models, which in many ways is harder than &amp;ldquo;tapeout-ready&amp;rdquo; RTL.&lt;/li&gt;
&lt;li&gt;How do we improve? Harness useful hardware trends such as the open RISC-V
SoC, open silicon designs, high productivity hardware design languages
(Chisel), FPGAs in the cloud.&lt;/li&gt;
&lt;li&gt;FireSim target design: server blades, each with quad-core RISC-V Rocket at
3.2GHz, 16KiB I+D cache, 256KiB L2, 16Gb DRAM, 200Gbps Ethernet NIC, optional
accelerators. The network has parameterisable bandwidth/link latency and a
configurable topology.&lt;/li&gt;
&lt;li&gt;Transform the RTL to simulate on the FPGA. For the network simulation, use
CPUs and the host network (one thread per port).&lt;/li&gt;
&lt;li&gt;FAME-1 transforming RTL: given RTL, want to automatically transform it into
decoupled cycle-accurate simulator RTL that we can run on the FPGA.&lt;/li&gt;
&lt;li&gt;Can pack four quad-core server simulations per FPGA, meaning 32 server
simulations per f1.16xlarge (128 simulated cores). Use a 32-port 200Gbps
per-port top of rack switch model. The simulation runs at 5MHz (~400 million
instructions/second). $13.20/hr on-demand, ~$2.60/hr on the spot market.&lt;/li&gt;
&lt;li&gt;Can scale to simulating a 1024 node RISC-V datacenter. Ran across 32
f1.16xlarge instances. In aggregate, runs at 3.4MHz (13 billions insts/s
across the simulated datacenter).&lt;/li&gt;
&lt;li&gt;Can also achieve &amp;ldquo;functional&amp;rdquo; network simulation. e.g. allowing all of
SPECInt06-ref to run on Rocket Chip at 150MHz (completing in less than one
day).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Seventh RISC-V Workshop: Day One</title>
      <link>http://www.lowrisc.org/blog/2017/11/seventh-risc-v-workshop-day-one</link>
      <pubDate>Tue, 28 Nov 2017 15:16:45 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/11/seventh-risc-v-workshop-day-one</guid>
      <description>

&lt;p&gt;The &lt;a href=&#34;https://riscv.org/2017/10/7th-risc-v-workshop-agenda/&#34;&gt;seventh RISC-V
workshop&lt;/a&gt; is going
on today and tomorrow at Western Digital in Milpitas. I&amp;rsquo;ll be
keeping a semi-live blog of talks and announcements throughout the day.&lt;/p&gt;

&lt;p&gt;Follow &lt;a href=&#34;http://www.lowrisc.org/blog/2017/11/seventh-risc-v-workshop-day-two&#34;&gt;here&lt;/a&gt; for the
day two live blog.&lt;/p&gt;

&lt;h2 id=&#34;introduction-rick-o-connor:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Introduction: Rick O&amp;rsquo;Connor&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Workshop is sold out, 498 attendees registered representing 138 companies
and 35 universities.&lt;/li&gt;
&lt;li&gt;There will be 47 sessions squeezed into 12 and 24 minute increments, plus 26
poster / demo sessions.&lt;/li&gt;
&lt;li&gt;The 8th RISC-V workshop will be held on May 7th-10th at the Barcelona
Supercomputing Center and Universitat Politecnica de Catalunya.&lt;/li&gt;
&lt;li&gt;Rick gives a refresher on the structure of the RISC-V Foundation.&lt;/li&gt;
&lt;li&gt;The RISC-V Foundation now has only 100 members (including individual
members).&lt;/li&gt;
&lt;li&gt;We&amp;rsquo;re on a &lt;em&gt;tight&lt;/em&gt; schedule today. No applause and no questions!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-state-of-the-union-krste-asanovic:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;RISC-V state of the union: Krste Asanovic&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Krste gives a rapid overview of the RISC-V ISA.&lt;/li&gt;
&lt;li&gt;RISC-V aims to be simple, clean-slate, modular, and stable.&lt;/li&gt;
&lt;li&gt;RISC-V started in May 2010. v1.0 of the ISA came in 2011, first Rocket
tapeout in 2012, first Linux port in 2013, v2.0 (frozen) IMAFD spec in 2014.
First commercial softcores and first commercial SoC in 2017.&lt;/li&gt;
&lt;li&gt;Large companies are adopting RISC-V for deeply embedded controllers in their
SoCs (&amp;ldquo;minion cores&amp;rdquo;), replacing home-grown and commercial cores.

&lt;ul&gt;
&lt;li&gt;[Editor&amp;rsquo;s note: pleasing to see the &amp;ldquo;minion core&amp;rdquo; name take off around the
wider RISC-V community!].&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Small and proprietary-ISA soft-core IP companies are switching to the RISC-V
standard to access a larger market. &amp;ldquo;If you&amp;rsquo;re a softcore IP provider, you
should have a RISC-V product in development&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;RISC-V has seen government adoption, e.g. India adopted it as a national
ISA. A recent security-focused DARPA project standardised on RISC-V. Israel
Innovation Authority are creating the GenPro platform around RISC-V.&lt;/li&gt;
&lt;li&gt;Many startups are choosing RISC-V for new products. &amp;ldquo;We haven&amp;rsquo;t had to tell
startups about RISC-V; they find out about it very quickly when shopping for
processor IP&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Commercial ecosystem providers: starting to see mainstream commercial
support. &amp;ldquo;Demand is driving supply in the commercial ecosystem&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;RISC-V in academic research: becoming the standard ISA for academic
research. There will be talks at the workshop about the Celerity 500 RISC-V
core SoC in 16nm FinFET, and FireSim which models 1024 quad-core RISC-V
servers in the cloud.

&lt;ul&gt;
&lt;li&gt;The CARRV RISC-V workshop at MICRO was even better attended than the
machine learning workshop.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Expect in a few years time that the vast majority of undergraduates will be
taught RISC-V at University.&lt;/li&gt;
&lt;li&gt;Racepoint Global have been hired for Foundation marketing.&lt;/li&gt;
&lt;li&gt;RISC-V Technical Roadmap for 2017:

&lt;ul&gt;
&lt;li&gt;Primary goal was to formally standardise the base ISA, resolve issues with
the memory model, debug, and stabilize the privileged architecture.&lt;/li&gt;
&lt;li&gt;Good progress has been made, but the spec hasn&amp;rsquo;t yet been ratified. One of
the issues is differentiating the base spec versus clarifications for
different &amp;ldquo;profiles&amp;rdquo;. There is no plan to change any instruction
specification versus 2.0.&lt;/li&gt;
&lt;li&gt;The Unix platform is stable as of the privileged 1.10 spec (i.e. no
backwards incompatible changes from now on).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ISA specifications and profiles

&lt;ul&gt;
&lt;li&gt;The original ISA specs mixed instruction specifications with platform
mandates. Now work is ongoing to separate instruction set specifications
from platform profiles.&lt;/li&gt;
&lt;li&gt;Instruction set specifications should be maximally reusable, while the
profiles should be as constrained as possible to simplify software
compatibility.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Single-letter names will run out some day, so a proposal has been made to
allow finer-grained naming of instruction sets to describe profiles. Use Zxxxx
to name standard instruction extensions (while Xyyyyy is used for non-standard
instruction extensions). See the isa-dev list for more information.&lt;/li&gt;
&lt;li&gt;Profiles for software compatibility. A software ABI/SBI defines a profile.
A software ABI/SBI defines a profile. Also need profiles M-mode-only
microcontrollers, and MU-mode microcontrollers, and for booting MSU platforms.
Aim for have first ready in Q12018.&lt;/li&gt;
&lt;li&gt;Memory model: the original was too weak for C11 and underspecified, but a
team of experts have come together over the past year to resolve the issues.
RVWMO is the base memory model and is weak, while RVTSO is an optional
extension providing a strong TSO memory model.&lt;/li&gt;
&lt;li&gt;Calling convention and ABI has been stabilized and documented.&lt;/li&gt;
&lt;li&gt;GCC and binutils have been upstreamed and released in GCC. LLVM upstream is
in progress.&lt;/li&gt;
&lt;li&gt;A number of other compilers and languages are now available. e.g. CompCert,
Go, Rust, OCaml, Jikes JVM, OpenJDK, &amp;hellip;&lt;/li&gt;
&lt;li&gt;The Linux port has been accepted upstream for the 4.15 release.
Additionally, the hypervisor spec has been released (designed to support
recursive virtualisation using an enhanced S mode).&lt;/li&gt;
&lt;li&gt;Run-halt debug going well, is being targeted by commercial vendors.&lt;/li&gt;
&lt;li&gt;2017 summary: All planned major technical decisions settled, some more work
on the ratification process is needed.&lt;/li&gt;
&lt;li&gt;Technical roadmap goals for 2018:

&lt;ul&gt;
&lt;li&gt;Complete ratification of base ISA and first profiles&lt;/li&gt;
&lt;li&gt;Base vector extensions proposed and ratified&lt;/li&gt;
&lt;li&gt;Hypervisor implemented, spec ratified&lt;/li&gt;
&lt;li&gt;Formal spec completed and released&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Vector: see the talk from Roger. Aim to be the Best Vector ISA Ever &amp;trade;.&lt;/li&gt;
&lt;li&gt;Security: really two separable efforts in the foundation: trusted execution
environments and cryptographic instruction extensions. Also a huge amount of
other work in the academic community.&lt;/li&gt;
&lt;li&gt;Interrupts: currently have fast local interrupts and global platform-level
interrupts. Also have requests for high end systems who want per-hart
message-signal interrupts (MSI) and from low-end embedded that want
pre-emptive vectored prioritized interrupts.&lt;/li&gt;
&lt;li&gt;Improving embedded compression: the C extension was designed for general
purpose computing with Unix binaries. People are seeing non-competitive RISC-V
code size on pure embedded workloads, like due to lack of byte/halfword memory
access? Considering an alternative C extension for RV32E systems.&lt;/li&gt;
&lt;li&gt;A new task group has been up for the &amp;lsquo;J&amp;rsquo; extension, exploring support for
dynamically translated languages. Looking at issues like integer overflow,
garbage collection, and instruction cache management.&lt;/li&gt;
&lt;li&gt;Summary

&lt;ul&gt;
&lt;li&gt;Very rapid development and adoption &amp;ldquo;by the time you decide to do a
project, support will be there&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Question: does the foundation have any formal ways of addressing IP
challenges? Answer: have been documenting prior art for the base ISA
instructions. Would be good to continue to expand this to cover reference
hardware implementations.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-hypervisor-extension-andrew-waterman:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;RISC-V Hypervisor Extension: Andrew Waterman&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Presenting work with extensive contributions from Paolo Bonzini and John
Hauser&lt;/li&gt;
&lt;li&gt;Goal is to virtualize S-mode to support running guest OSes under Type-1,
Type-2 and hybrid hypervisors. Also want to be high performance and to support
recursive virtualisation.&lt;/li&gt;
&lt;li&gt;The hypervisor extension adds new privileged modes. S-mode becomes HS-mode,
and we also add the Virtualised Supervisor (VS) and Virtualized User (VU)
modes.&lt;/li&gt;
&lt;li&gt;What needs to be virtualized? Supervisor architecture state (CSRs), memory,
I/O and interrupts.&lt;/li&gt;
&lt;li&gt;Additional copies of most supervisor CSrs are provisioned as background
supervisor CSRs, e.g. bsscratch, bsepc. In HS-mode, foreground CSRs contain
S-mode state and background CSRs contain inactive VS-mode state. These are
swapped in VS-mode.&lt;/li&gt;
&lt;li&gt;Use two-level address translation to virtualize memory. Original virtual
addresses are translated to guest physical addresses by the VS-level page
table, and then guest physical addresses are translated to machine physical
addresses by the HS-level page table.

&lt;ul&gt;
&lt;li&gt;Page table entry formats and page table layouts are the same as S-mode&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Software and timer interrupts are easy to virtualise, as they&amp;rsquo;re already
exposed via the SBI. The two-level paging scheme can be used to trap MMIO
accesses.

&lt;ul&gt;
&lt;li&gt;Could avoid extra traps into the hypervisor with a virtualisation-aware
PLIC. This is considered a platform issues, outside of the scope of the
hypervisor ISA.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Need an I/O MMU to initiated DMAs without trap into the hypervisor - also a
platform issue.&lt;/li&gt;
&lt;li&gt;The hypervisor extension is designed to be efficiently emulatable on M/S/U
systems with traps into M-mode.&lt;/li&gt;
&lt;li&gt;Specification v.01 is &lt;a href=&#34;https://github.com/riscv/riscv-isa-manual&#34;&gt;available on
GitHub&lt;/a&gt;. Hoping to implement in
Spike in Q1 2018.&lt;/li&gt;
&lt;li&gt;Want to see a silicon implementation prior to ratification.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-memory-consistency-model-status-update-dan-lustig:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;RISC-V memory consistency model status update: Dan Lustig&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The goal was to define the RISC-V memory consistency model (&amp;ldquo;specifies the
values that can be returned by loads&amp;rdquo;). Support a wide range of hardware
implementations, as well as Linux, C/C++ and lots of other critical software.&lt;/li&gt;
&lt;li&gt;The fundamental debate was about strong models (such as x86-TSO) vs weak
models (ARM, IBM Power). Strong models have stricter ordering rules, resulting
in something that&amp;rsquo;s simpler for programmers and for architects. Weak models
have more relaxed ordering rules, better performance/power/area and more
microarchitectural freedom.&lt;/li&gt;
&lt;li&gt;In order to find a compromise, defined RVTSO (strong) and RVWMO (weak).

&lt;ul&gt;
&lt;li&gt;Both are multi-copy atomic. This means cores are allowed to peek at stores
they have issues as long as they haven&amp;rsquo;t been observed by anyone else and is
much simpler to reason about than the Power and ARMv7 memory models.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The base RISC-V memory model is RVWMO (software must assume this if it wants
to be portable). It&amp;rsquo;s important to note that a hardware implementation meeting
the RVWMO specification could be more conservative (stronger). Additional have
the Ztso extension for RVTSO, which software might target.&lt;/li&gt;
&lt;li&gt;RVWMO and RVTSO differ in the degree of memory access reordering they permit
at the point of global visibility. In RVTSO, only store-to-load reordering can
be observed. In RVWMO, most memory accesses can be reordered freely unless
synchronized via .sq, .rl and/or fences.&lt;/li&gt;
&lt;li&gt;Dan has some handy diagrams that explain the RVWMO and RVTSO rules in a
nutshell, which you should be able to study once the slides become available.&lt;/li&gt;
&lt;li&gt;Software written for RVWMO will run on all RISC-V hardware (RVWMO and Ztso).
RVTSO-only software can be be written, but will only run on hardware
implementing Ztso. A flag in the ELF header will be used to ensure this.&lt;/li&gt;
&lt;li&gt;If you don&amp;rsquo;t want to think about memory models, just use the standard OSes
and toolchains. If you care about PPA or flexibility, use RVWMO. If you have
lots of legacy x86 code, use hardware implementing Ztso so that any software
will work. If you believe TSO is the future, use hardware with Ztso and emit
code with the TSO-only magic number.&lt;/li&gt;
&lt;li&gt;Fragmentation due to the presence of two memory models is an obvious risk.
Try to discourage software from targeting both, and encourage targeting RVWMO
wherever possible (redundant fences simple become no-ops).&lt;/li&gt;
&lt;li&gt;There have been a number of other ISA changes. ld.rl and sd.aq are
deprecated. ld.aqrl and sd.aqrl mean RCsc. Also clarified other subtleties.
May have future extensions to the fence instruction, and .aq/.rl variants for
byte and halfword-size loads/stores.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-enabling-a-new-era-of-open-data-centric-computing-architectures-martin-fink:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;RISC-V - Enabling a new era of open data-centric computing architectures: Martin Fink&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Most people think of Western Digital as a storage company, but actually
they&amp;rsquo;re a &lt;em&gt;data&lt;/em&gt; company.&lt;/li&gt;
&lt;li&gt;Big data is well known, but increasingly there are applications that require
&amp;ldquo;fast data&amp;rdquo; (immediate access to information).&lt;/li&gt;
&lt;li&gt;Big data applications have historically focused on general purpose compute.
But we need to be able to move beyond general purpose compute to meet new
application requirements.&lt;/li&gt;
&lt;li&gt;In a general purpose compute architecture, everything is centered around the
CPU rather than the data.&lt;/li&gt;
&lt;li&gt;Workload diversity demands diverse technologies and architectures, both for
&amp;ldquo;big data&amp;rdquo; and &amp;ldquo;fast data&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;There are a wide range of data-centric applications at the edge.&lt;/li&gt;
&lt;li&gt;RISC-V meets the needs of big data (move compute to data) and fast data
(memory centric compute). It enables purpose-built environments for big data
and fast data applications.&lt;/li&gt;
&lt;li&gt;Western Digital ships in excess of 1 billion cores per year, and expect to
double that. They are making a commitment to transition all of those 1 billion
cores towards RISC-V, across their whole product portfolio.&lt;/li&gt;
&lt;li&gt;Want to process the data where it lives, which RISC-V will help to enable.&lt;/li&gt;
&lt;li&gt;Represents a new style of development. In some cases, WD may develop their
own cores, in others may buy them, in others may partner with another company
to co-develop them.&lt;/li&gt;
&lt;li&gt;Western Digital will work to accelerate the RISC-V ecosystem:

&lt;ul&gt;
&lt;li&gt;Support the development of open source IP building blocks for the
community&lt;/li&gt;
&lt;li&gt;Actively partner and invest in the ecosystem&lt;/li&gt;
&lt;li&gt;Accelerate development of purpose-built processors for a broad range of
Big Data and Fast Data environments&lt;/li&gt;
&lt;li&gt;Multi-year transition of Western Digital devices, platforms and systems to
RISC-V purpose built architectures&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;First device from WD with a RISC-V core is likely to not ship until late
2019 to early 2020.&lt;/li&gt;
&lt;li&gt;Summary

&lt;ul&gt;
&lt;li&gt;Big Data and Fast Data need purpose-built environments&lt;/li&gt;
&lt;li&gt;Openness and ecosystem enable best-in-class innovation. The motivation is
enabling innovation, &lt;em&gt;not&lt;/em&gt; reducing cost.&lt;/li&gt;
&lt;li&gt;Western Digital brings the momentum of over 1B cores per year&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;industrial-strength-high-performance-risc-v-processors-for-energy-efficient-computing-dave-ditzel:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Industrial-strength high-performance RISC-V processors for energy-efficient computing: Dave Ditzel&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Coming out of &amp;ldquo;stealth mode&amp;rdquo; in this talk.&lt;/li&gt;
&lt;li&gt;Chris Celio is joining Esperanto, but will continue to maintain and support
BOOM. Esperanto will also be implementing even higher performance out-of-order
processors.&lt;/li&gt;
&lt;li&gt;Esperanto have been pursuing an implementing of the draft Vector ISA in
order to understand design trade-offs.&lt;/li&gt;
&lt;li&gt;RISC-V is off to a great start, but many in industry view RISC-V as a
curiosity or toy, only for low end. Repeatedly see questions about high-end
designs (in Verilog!), graphics, machine learning, or HPC applications.&lt;/li&gt;
&lt;li&gt;See Esperanto as complementing existing core vendors, &amp;ldquo;expanding RISC-V&amp;rsquo;s
piece of the pie&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Experanto is designing a high-performance RISC-V core comparable to the best
IP alternatives. It is designing an energy-efficient RISC-V core for high
TeraFLOP computing needs. The goal is to make RISC-V more compelling than the
other high-end alternatives.&lt;/li&gt;
&lt;li&gt;Will produce IP with human readable, synthesizable Verilog.&lt;/li&gt;
&lt;li&gt;Esperanto is building the highest TeraFLOPS per Watt machine learning
computing system, and it will be based on the RISC-V ISA&lt;/li&gt;
&lt;li&gt;ET-Maxion will be the highest single thread performance 64-bit RISC-V
processor. Starting from BOOM v2, but expect substantial changes. Optimized
for 7nm CMOS. This will be used in Esperanto&amp;rsquo;s products and made available as
a licensable core.&lt;/li&gt;
&lt;li&gt;Second core is the ET-Minion. This is intended to do all the heavy floating
point work, with very high floating point throughput and energy efficiency.
This will be a 64-bit RISC-V core with vector extensions, an in-order
pipeline, and extra instruction extensions for machine learning. Also have
multiple hardware threads of execution. Like the ET-Maxion, this will be used
in Esperanto products and available as a licensable core.&lt;/li&gt;
&lt;li&gt;Putting these together in a product: Esperanto&amp;rsquo;s AI supercomputer on a chip.
16 64-bit ET-Maxion RISC-V cores with private L1 and L2 caches, 4096 64-bit
ET-Minion RISC-V cores each with their own vector floating point unit,
hardware accelerators, Network on Chip to allow processors to reside in the
same address space, multiple levels of cache, etc.&lt;/li&gt;
&lt;li&gt;Other companies are proposing special purpose hardware for machine learning
using proprietary instruction sets. Esperanto want to base all processing on
RISC-V, adding instruction extensions and hardware accelerators where
necessary.&lt;/li&gt;
&lt;li&gt;Also looked at using RISC-V for graphics. Wrote a shader compiler that can
generate RISC-V compilers, and the code to distribute the workload across
thousands of cores.&lt;/li&gt;
&lt;li&gt;Argue that proprietary, custom instruction sets are a bad choice. Instead,
make general purpose RISC-V processors with domain specific extensions when
needed.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;andes-extended-features-dr-chuan-hua-chang:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Andes Extended Features: Dr Chuan-Hua Chang&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Andes Technology is a Taiwan-based CPU IP company with over 2 billion
Andes-Embedded SoCs shipped in diverse applications.&lt;/li&gt;
&lt;li&gt;Have extended the RISC-V architecture in the V5m with:

&lt;ul&gt;
&lt;li&gt;Vectored interrupts and priority-based preemptive interrupts for the PLIC&lt;/li&gt;
&lt;li&gt;StackSafe features&lt;/li&gt;
&lt;li&gt;Exception redirection to the debuggers&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The V5m ISA includes

&lt;ul&gt;
&lt;li&gt;Andes Perfomance extension&lt;/li&gt;
&lt;li&gt;Optional Andes DSP extension&lt;/li&gt;
&lt;li&gt;Optional Andes Custom extension&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;For the vectored PLIC, vector table entry 0 contains exceptions and local
interrupts except &amp;ldquo;external interrupt&amp;rdquo;. Vector table entry 1 and above
contains external interrupts from the PLIC. The PLIC interrupt ID is
transmitted directly from PLIC to a hart.&lt;/li&gt;
&lt;li&gt;The extended PLIC saves over 30 instructions for dispatch and software
preemption overhead.&lt;/li&gt;
&lt;li&gt;StackSafe monitors the SP register value to detect stack pointer overflow
and underflow, and for recording the maximum observed stack size.&lt;/li&gt;
&lt;li&gt;Andes ISA extensions add

&lt;ul&gt;
&lt;li&gt;GP-implied load/store instructions with a larger immediate range.&lt;/li&gt;
&lt;li&gt;Compare an operand with a small constant and branch&lt;/li&gt;
&lt;li&gt;Instructions for zero/sign-extensions&lt;/li&gt;
&lt;li&gt;CoDense: code size compression instructions&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The Andes DSP ISA extension features over 130 instructions, using only GPRs.
Introduces a range of SIMD instructions, zero-overhead loops, and 64-bit
signed/unsigned addition and subtractions, and signed/unsigned multiplication
and addition.

&lt;ul&gt;
&lt;li&gt;See 50% cycle reduction for the Helix MP3 decoder, and 80.1% cycle
reduction for the G.729 codec.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Andes Custom Extension (ACE) provides a framework to facilitate custom
instruction design and implementation.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;customisation-of-a-risc-v-processor-to-achieve-dsp-performance-gain-marcela-zachariasova:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Customisation of a RISC-V processor to achieve DSP performance gain: Marcela Zachariasova&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Codasip studio is a processor development environment which takes a high
level description of a processor and automatically generates software tool,
RTL, and verification environments.&lt;/li&gt;
&lt;li&gt;Take one of Codasip&amp;rsquo;s Berkelium RISC-V cores as the starting point.&lt;/li&gt;
&lt;li&gt;Configure the core by enabling/disabling ISA extensions as desired. You can
also define new instructions, driven by profiling information.&lt;/li&gt;
&lt;li&gt;Case study: audio processing solution for IoT (developed with Microsemi).&lt;/li&gt;
&lt;li&gt;Ultimately, saw a 13.62x speedup for a 2.43x area overhead vs RV32IM.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;freedom-u500-linux-capable-1-5gh-quad-core-rv64gc-soc-jack-kang:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Freedom U500, Linux-capable, 1.5GH quad-core RV64GC SoC: Jack Kang&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Freedom Unleashed 500: 250M+ transistors, TSMC 28nm, high-performance
integrated RISC-V SoC, U54MC RISC-V CPU Core Complex&lt;/li&gt;
&lt;li&gt;1.5GHz+ SiFive E51/U53 CPU. 1xE51 (16KB L1I$, 8KB DTIM), 4 x U54. 32KB L1I$,
32KB L1D$.&lt;/li&gt;
&lt;li&gt;All five cores in a coherent system with 2MB L2$.&lt;/li&gt;
&lt;li&gt;Development board available in Q12018.&lt;/li&gt;
&lt;li&gt;Feature GbE, DDR3/4, and ChipLink (a serialized chip-to-chip TileLink
interconnect).&lt;/li&gt;
&lt;li&gt;The E51 core is a 64-bit, 1.5GHz CPU &amp;ldquo;minion core&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Coherent, 2MB 16-way L2 subsystem.&lt;/li&gt;
&lt;li&gt;Single U54 core-only area 0.224mm2, single U53 core complex area 0.538mm2
(including 32KB/32KB L1 cache). 1.7 DMIPS/MH, 2.75 CoreMark/MHz.&lt;/li&gt;
&lt;li&gt;HiFive Unleashed will have the SiFive Freedom Unleashed 500 SoC connected to
a Microsemi PolarFire FPGA, Provide USB and HDMI via the FPGA, as well as
PCIe. Available Q1&amp;rsquo;2018.&lt;/li&gt;
&lt;li&gt;HiFive Unleashed Early Access Program: give early access to FPGA-based
prototypes (now) and development boards (soon). To get access, email
info@sifive.com.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;revolutionizing-risc-v-based-application-design-possibilities-with-globalfoundries-gregg-bartlett:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Revolutionizing RISC-V based application design possibilities with GlobalFoundries: Gregg Bartlett&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;GlobalFoundries is the only foundry that is a RISC-V Foundation member. See
that the RISC-V approach is a good match for GlobalFoundries.&lt;/li&gt;
&lt;li&gt;For the last year, have been engaged in applications where RISC-V processors
are showing up. DNN accelerators, cluster computing, automotive/embedded SoCs,
X86/GPU co-processors.&lt;/li&gt;
&lt;li&gt;Argue foundry technology allows differentiated customer solutions. e.g.
22FDX and 12FDX.&lt;/li&gt;
&lt;li&gt;22FDX is targeted to serve segments such as mobility, IoT, RF, and
automotive.&lt;/li&gt;
&lt;li&gt;FDXcellerator program features multiple RISC-V cores, as well as LPDDR4,
MIPI etc.&lt;/li&gt;
&lt;li&gt;Partnered with SiFive (E31+E51), Reduced Energy Microsystems, Andes, ETH
Zurich / University of Bologna (PULP), Berkeley Labs, IIT Chennai.&lt;/li&gt;
&lt;li&gt;For the SiFive partnership, no cost to customers for E31/E51 cores until
production starts.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-llvm-towards-a-production-ready-llvm-based-toolchain-alex-bradbury:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;RISC-V LLVM. Towards a production-ready LLVM-based toolchain: Alex Bradbury&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;I was the presenter, so no notes right now.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-risc-v-java-update-martin-maas:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;A RISC-V Java update: Martin Maas&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Jikes RVM now runs full JDK6 applications, including the Decapo benchmark
suite. Passes the Jikes RVM core test suite. About 15000 lines of code.&lt;/li&gt;
&lt;li&gt;Managed languages have been under-represented in computer architecture
research for quite some time.&lt;/li&gt;
&lt;li&gt;Challenges: long running on many cores, concurrent tasks, fine-grained
interactions. Difficult fit for many common simulation approaches, e.g. Qemu
or Gem5.&lt;/li&gt;
&lt;li&gt;Instead, we can run managed workloads on real RISC-V hardware in FPGA-based
simulation to enable modifying the entire stack.&lt;/li&gt;
&lt;li&gt;By modifying the hardware, we can do fine-grained tracing without perturbing
the software being tested.&lt;/li&gt;
&lt;li&gt;Can explore the interaction with the memory system, e.g. DRAM row misses
encountered during garbage collection.&lt;/li&gt;
&lt;li&gt;This will allow a wide range of research that was difficult without this
infrastructure.&lt;/li&gt;
&lt;li&gt;Have the Jikes Research VM (baseline JIT, no optimising JIT). Can run
OpenJDK Hotspot JVM with the Zero (interpreter) backend, but no
high-performance JIT compiler port yet. Help needed!&lt;/li&gt;
&lt;li&gt;The RISC-V Foundation has launched the J extension working group today, to
better support managed-language support to RISC-V.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;microprobe-an-open-source-microbenchmark-generator-ported-to-the-risc-v-isa-schuyler-eldridge:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;MicroProbe. An open source microbenchmark generator ported to the RISC-V ISA: Schuyler Eldridge&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Not yet open source, but in the process of releasing it.&lt;/li&gt;
&lt;li&gt;Why make microbenchmarks? Might want to study worst case power consumption,
look for performance bugs, determine if the design is reliable, &amp;hellip; But
writing microbenchmarks is a labour-intensive process.&lt;/li&gt;
&lt;li&gt;MicroProbe has the user write microbenchmark generation policies. The
framework then produces benchmarks according to those policies.&lt;/li&gt;
&lt;li&gt;The target definition (ISA, microarchitecture, environment) is written using
YAML. Code generation and generation policies are written using Python.&lt;/li&gt;
&lt;li&gt;MicroProbe uses riscv-meta from Michael Clark.&lt;/li&gt;
&lt;li&gt;The user describes a microbenchmark as transforms over an intermediate
representation (IR) for describing benchmarks.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lauterbach-debug-support-for-risc-v-bob-kupyn:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Lauterbach debug support for RISC-V: Bob Kupyn&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Lauterbach is solely focused on hardware and software debug tools. All
design, development and manufacture is done in Munich.&lt;/li&gt;
&lt;li&gt;Claim the widest range of supported microprocessors in the market.&lt;/li&gt;
&lt;li&gt;More than 100k installed Lauterbach debuggers, estimate 40% of the market.&lt;/li&gt;
&lt;li&gt;Have a RISC-V JTAG debugger. Currently just run-control, awaiting a stable
trace debug spec.&lt;/li&gt;
&lt;li&gt;Trace32 debugger supports all the features you&amp;rsquo;d expect. The RISC-V port
supports RV32 and RV64. In the future, want to add trace support and
Linux/Target OS awareness.&lt;/li&gt;
&lt;li&gt;In the initial release, support SiFive Coreplex E31 and E51.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;j-link-debug-probe-now-available-for-risc-v-paul-curtis:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;J-link debug probe now available for RISC-V: Paul Curtis&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;J-Link aims to be the &amp;ldquo;ultimate debug probe&amp;rdquo;. Supporting ARM, Mips, RX,
8051, and now RISC-V.&lt;/li&gt;
&lt;li&gt;J-Link is open in the sense you can incorporate it into your product using
the J-Link SDK.&lt;/li&gt;
&lt;li&gt;J-Link is &amp;ldquo;intelligent&amp;rdquo;, eliminating round-trip-time over USB or IP using
kernels in the debug adapter.&lt;/li&gt;
&lt;li&gt;Over 600k units sold.&lt;/li&gt;
&lt;li&gt;Also have Embedded Studio, other products.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;porting-the-threadx-rtos-to-risc-v-john-carbone:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Porting the ThreadX RTOS to RISC-V: John Carbone&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ThreadX in production since 1997.&lt;/li&gt;
&lt;li&gt;Small footprint, priority-based, fully preemptive RTOS with a single linear
address space.&lt;/li&gt;
&lt;li&gt;Has advanced features like preemption-threshold scheduling, real-time event
trace, memory-protected modules.&lt;/li&gt;
&lt;li&gt;Ported with co-operation from Mirosemi, ran on the Smartfusion2 Creative
Development Board.&lt;/li&gt;
&lt;li&gt;Anticipate commercial availability for RISC-V before the end of 2017.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;xbgas-a-bridge-proposal-for-rv128-and-hpc-john-leidel:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;xBGAS. A bridge proposal for RV128 and HPC: John Leidel&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Extended Base Global Address Space (xBGAS)&lt;/li&gt;
&lt;li&gt;Want to provide extended addressing capabilities without ruining the base
ABI.&lt;/li&gt;
&lt;li&gt;Extended addressing must not specifically rely upon any one virtual memory&lt;/li&gt;
&lt;li&gt;xBGAS is not a direct replacement for RV128.&lt;/li&gt;
&lt;li&gt;See a variety of potential application domains.&lt;/li&gt;
&lt;li&gt;HPC-PGAS: traditional message passing has a tremendous amount of overhead.
There are a range of low-latency PGAS runtimes, but little hardware/uarch
support.&lt;/li&gt;
&lt;li&gt;Add extended (eN) register that map to base general registers. These are
manually utilized via extended load/store/move instructions.&lt;/li&gt;
&lt;li&gt;You only get access to the extended address space when using the new
extended addressing instructions.&lt;/li&gt;
&lt;li&gt;ISA extensions: base integer load/store, raw integer load/store, address
management (explicitly read/write the extended registers).&lt;/li&gt;
&lt;li&gt;No support for things like atomics currently. (Question for the community:
how to define extensions to extensions?)&lt;/li&gt;
&lt;li&gt;A number of outstanding issues with the ABI and calling convention. How to
link base RISC-V objects with objects containing extended addressing? Howe do
we address the caller/callee saved state with extended registers? What about
debugging and debugging metadata.&lt;/li&gt;
&lt;li&gt;The software part of this is being led by the Data Intensive Scalable
Computing Lab at Texas Tech. Have a prototype implementation in LLVM.&lt;/li&gt;
&lt;li&gt;Hardware part of the effort taking place at Tactical Computing Labs, LBNL
and MIT. Looking at pipelined and accelerator-based implementations.&lt;/li&gt;
&lt;li&gt;The current spec is &lt;a href=&#34;https://github.com/tactcomplabs/xbgas-archspec&#34;&gt;available
here&lt;/a&gt;. Comments and
collaborators are encouraged!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;extending-the-16-gpr-standard-beyond-rv32e-mitch-hayenga:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Extending the 16 GPR standard beyond RV32E: Mitch Hayenga&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Motivation: Register file area/power/latency is critical to any processor.
Large register files help with static code scheduling, but wide issue
out-of-order processors have the potential to hide register spill latency and
issue bandwidth.&lt;/li&gt;
&lt;li&gt;There are a number of commercially available cores that only offer 16
double-precision floating point registers.&lt;/li&gt;
&lt;li&gt;Want to see the 16GPR option being orthogonal just like any other ISA
variant (RV32E currently can&amp;rsquo;t be combined with the F and D extensions).&lt;/li&gt;
&lt;li&gt;Reduced the available registers to x0-x15 and f0-f15. Modified GCC and glibc
and used gem5 with the Coremark/Dhrystone/Whetstone/Spec2006 benchmarks.&lt;/li&gt;
&lt;li&gt;For the simple benchmarks, saw a 6-8% increase in static code size. Smaller
increase in dynamic instructions (and Whetstone saw a reduction). Saw in-order
execution time impacted, but much smaller impact for the out-of-order designs.&lt;/li&gt;
&lt;li&gt;For SPECInt, saw (very) slightly improved code density and execution time.&lt;br /&gt;
In perlbench this was primarily due to reduced function call overhead.&lt;/li&gt;
&lt;li&gt;The impact was more negative for SPECFP.&lt;/li&gt;
&lt;li&gt;Architectural overheads limit the viable design space of multithreaded
out-of-order CPUs.&lt;/li&gt;
&lt;li&gt;New potential designs:

&lt;ul&gt;
&lt;li&gt;Dual-threaded, small window out-of-order CPUs (~20 instruction windows).
This is impractical with the current RISC-V register file size requirements&lt;/li&gt;
&lt;li&gt;Large, high-IPC, many threaded CPU designs.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;using-pyrope-to-create-transformable-risc-v-architectures-haven-skinner:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Using Pyrope to create transformable RISC-V architectures: Haven Skinner&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Hardware design is difficult. You need multiple codebases (cycle accurate,
high level simulation, verification reference model). Also need to adjust
pipeline stages and verify the hardware.&lt;/li&gt;
&lt;li&gt;A new HDL (Pyrope) can help!&lt;/li&gt;
&lt;li&gt;Fluid pipelines are the &amp;ldquo;hammer&amp;rdquo; used to address design complexity. Fluid
pipeline transformations change the number of stages as part of the compile
flow.&lt;/li&gt;
&lt;li&gt;A fluid pipeline has valid/stop signals, and pipeline stages should tolerate
random delays.&lt;/li&gt;
&lt;li&gt;Collapsing stages was useful in order to build an emulator out of a RISC-V
fluid core. Can also change the number of pipeline stages automatically, and
perform formal verification.&lt;/li&gt;
&lt;li&gt;For a Verilog implementation, saw 2MIPS when compiling with Verilator. When
collapsing fluid pipelines to produce a fast emulator, saw 6MIPS. Spike
achieves around 12 MIPS.&lt;/li&gt;
&lt;li&gt;Compared synthesis results of the fluid pipelines vs a range of open source
RISC-V cores.&lt;/li&gt;
&lt;li&gt;For &amp;ldquo;fluid verification&amp;rdquo;, can collapse the stages in a RISC-V core, then
verify against a trivial single stage RISC-V core. Used yosys to do this.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;performance-isolation-for-multicore-within-labeled-risc-v-zihao-yu:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Performance isolation for multicore within labeled RISC-V: Zihao Yu&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;In multi-core architectures, core share resources such as L3, memory, and
I/O. This can cause uncertainties and QoS violations.&lt;/li&gt;
&lt;li&gt;Take inspiration from labeled networks and try to apply to computer
architecture. Describe the Labeled von Neumann Architecture (LvNA).&lt;/li&gt;
&lt;li&gt;Each request has a label, each label is correlated with a
process/thread/variable, labels are propagated across the whole machine, and
software-defined control logic is used to provide different service for
different labeled groups.&lt;/li&gt;
&lt;li&gt;Proposed PARD (ASPLOS 2015). Programmable Architecture for
Resourcing-on-Demand.

&lt;ul&gt;
&lt;li&gt;Add a label register, allocate a label for each VM, attach a label to each
request, and add label-based programmable control logic.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;LvNA + RISC-V = Labeled RISC-V&lt;/li&gt;
&lt;li&gt;Saw less than 3% overhead in terms of code, less than 5% resource overhead,
and no performance overheads for critical apps.&lt;/li&gt;
&lt;li&gt;Plan to tape out with TSMC 40nm next year.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-practical-implementation-of-a-platform-level-interrupt-controller-plic-richard-herveille:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;A Practical Implementation of a Platform Level Interrupt Controller (PLIC): Richard Herveille&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;PLIC design goals: easy integration with external bus interfaces, be fully
compliant, and very flexible. Should work from small microcontrollers all the
way up to large server applications.&lt;/li&gt;
&lt;li&gt;The deign flexibility may result in management complexity. Potentially
hundreds or thousands of registers in a memory mapped management interface. So
try to define a management interface that minimises the memory map.&lt;/li&gt;
&lt;li&gt;Create the memory map dynamically based on parameters given to the IP core.&lt;br /&gt;
The register arrangement and documentation is automated.&lt;/li&gt;
&lt;li&gt;See the &lt;a href=&#34;https://roalogic.com&#34;&gt;Roa Logic website&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;open-source-rtos-ports-on-risc-v-nitin-deshpande:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;Open source RTOS ports on RISC-V: Nitin Deshpande&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Ported FreeRTOS, MyNewt, and Huawei LitOS.&lt;/li&gt;
&lt;li&gt;FreeRTOS: 32-bit version running on a RISC-V soft processor, 64-bit
currently runs on Spike.&lt;/li&gt;
&lt;li&gt;MyNewt: RISC-V support was already available, added the BSP and MCU/HAL
support.&lt;/li&gt;
&lt;li&gt;LiteOs: ported the kernel, BSP, and HAL. Already merged into upstream LiteOS
GitHub.&lt;/li&gt;
&lt;li&gt;Had a positive experience with RISC-V.&lt;/li&gt;
&lt;li&gt;Mi-V is an ecosystem that aims to accelerate the adoption of RISC-V.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;risc-v-poster-preview:c2b101a090d7cc5ec0df656eac1944a4&#34;&gt;RISC-V poster preview&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This is too rapid fire to summarise, sorry!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GSoC 2017 student report: core lockstep for minion cores</title>
      <link>http://www.lowrisc.org/blog/2017/10/gsoc-2017-student-report-core-lockstep-for-minion-cores</link>
      <pubDate>Thu, 05 Oct 2017 19:45:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/10/gsoc-2017-student-report-core-lockstep-for-minion-cores</guid>
      <description>&lt;p&gt;This year, as part of &lt;a href=&#34;https://developers.google.com/open-source/gsoc/&#34;&gt;Google Summer of
Code&lt;/a&gt; we had the pleasure of
working with Nikitas Chronas. Alongside his degree studies, Nikitas had become
involved with the &lt;a href=&#34;https://libre.space/&#34;&gt;Libre Space Foundation&lt;/a&gt; and developed
a strong interest in the possibility of open source hardware in
&lt;a href=&#34;https://en.wikipedia.org/wiki/CubeSat&#34;&gt;CubeSats&lt;/a&gt;. Fault tolerance of some
sort is important for harsh environments, and Nikitas worked to add fault
tolerance through the implementation of &lt;a href=&#34;https://en.wikipedia.org/wiki/Lockstep_(computing)&#34;&gt;core
lockstep&lt;/a&gt; for the
PULPino-based minion
core subsystem. This was a really successful project which ended up
making contributions in areas beyond the core lockstep focus:
documentation, code quality, support for the Arty FPGA development board, and
even prototyping a code generation mechanism. See the &lt;a href=&#34;http://www.lowrisc.org/docs/gsoc-2017/core-lockstep/&#34;&gt;detailed write-up&lt;/a&gt;
for all the details, and below for the all-important blinky lights demo.&lt;/p&gt;

&lt;iframe src=&#34;https://giphy.com/embed/26vIg6cZFMWvi6AbS&#34; width=&#34;480&#34; height=&#34;401&#34; frameBorder=&#34;0&#34; class=&#34;giphy-embed&#34; allowFullScreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Moving RISC-V LLVM forwards</title>
      <link>http://www.lowrisc.org/blog/2017/09/moving-risc-v-llvm-forwards</link>
      <pubDate>Wed, 27 Sep 2017 17:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/09/moving-risc-v-llvm-forwards</guid>
      <description>

&lt;p&gt;A high quality, upstream RISC-V backend for LLVM is perhaps the most
frequently requested missing piece of the RISC-V software ecosystem. This
blog post provides an update on the rapid progress we&amp;rsquo;ve been making towards
that goal, outlines next steps and upcoming events, and tries to better
explain the approach that we&amp;rsquo;re taking.
As always, you
can track status &lt;a href=&#34;http://www.lowrisc.org/llvm/status/&#34;&gt;here&lt;/a&gt; and find the code
&lt;a href=&#34;https://github.com/lowRISC/riscv-llvm&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;status:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Status&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve been able to make substantial progress since the &lt;a href=&#34;http://lists.llvm.org/pipermail/llvm-dev/2017-August/116709.html&#34;&gt;last
update&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;rv32:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;RV32&lt;/h3&gt;

&lt;p&gt;100% of the GCC torture suite passes for RV32I at -O0, -O1, -O2, -O3, and -Os
(after masking gcc-only tests). MC-layer (assembler) support for RV32IMAFD has
now been implemented, as well as code generation for RV32IM.&lt;/p&gt;

&lt;h3 id=&#34;rv64:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;RV64&lt;/h3&gt;

&lt;p&gt;This is the biggest change versus my last update. LLVM recently gained support
for parameterising backends by register size, which allows code duplication to
be massively reduced for architectures like RISC-V. As planned, I&amp;rsquo;ve gone
ahead and implemented RV64I MC-layer and code generation support making use of
this feature. I&amp;rsquo;m happy to report that 100% of the GCC torture suite passes
for RV64I at O1, O2, O3 and Os (and there&amp;rsquo;s a single compilation failure at
O0). I&amp;rsquo;m very grateful for Krzysztof Parzyszek&amp;rsquo;s (QUIC) work on variable-sized
register classes, which has made it possible to parameterise the backend on
XLEN in this way. That LLVM feature was actually motivated by requirements of
the Hexagon architecture - I think this is a great example of how we can all
benefit by contributing upstream to projects, even across different ISAs.&lt;/p&gt;

&lt;h3 id=&#34;other-activities:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Other activities&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Community members Lus Marques and David Craven have been experimenting with
D and Rust support respectively.&lt;/li&gt;
&lt;li&gt;Andes Technology have started working to contribute to this effort, and are
putting together patches for compressed instruction set support. This is a
really positive move and I hope others will follow their lead.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;development-stats:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Development stats&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The &amp;lsquo;reference&amp;rsquo; &lt;a href=&#34;https://github.com/lowRISC/riscv-llvm&#34;&gt;patch queue&lt;/a&gt; consists
of 48 patches, modifying 128 files and inserting over 11500 lines to the LLVM
and Clang codebases. Close to 50% of these lines are new tests.&lt;/li&gt;
&lt;li&gt;Other activities:

&lt;ul&gt;
&lt;li&gt;8 committed patches to LLVM in areas other than lib/Target/RISCV
(cleanups, support code, documentation improvements, bug fixes) with 5 more
making their way through the review process.&lt;/li&gt;
&lt;li&gt;2 GCC/binutils bugs reported&lt;/li&gt;
&lt;li&gt;RISC-V &lt;a href=&#34;https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md&#34;&gt;psABI
doc&lt;/a&gt;:
Authored 7 merged commits, 13 issues filed.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;d like to thank &lt;a href=&#34;https://github.com/lowRISC/riscv-llvm#credits&#34;&gt;everyone&lt;/a&gt;
who has contributed code review, feedback, or suggestions so far, as well as
our industrial sponsor.&lt;/p&gt;

&lt;h2 id=&#34;approach-and-philosophy:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Approach and philosophy&lt;/h2&gt;

&lt;p&gt;As enthusiastic supporters of RISC-V, I think we all want to see a huge range
of RISC-V core implementations, making different trade-offs or targeting
different classes of applications. But we &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want to see that variety in
the RISC-V ecosystem result in dozens of different vendor-specific compiler
toolchains and a fractured software ecosystem. Unfortunately most work on LLVM
for RISC-V has been invested in private/proprietary code bases or short-term
prototypes. The work described in this post has been performed out in the open
from the start, with a strong focus on code quality, testing, and on moving
development upstream as quickly as possible - i.e. a solution for the long term.&lt;/p&gt;

&lt;p&gt;My implementation approach has been to first work towards a cleanly designed
and well tested RV32I baseline compiler. Once the fundamentals are solid, it
is &lt;em&gt;significantly&lt;/em&gt; easier to add in new features, optimisations, or indeed
customisations for different RISC-V variants. This careful approach has
enabled the rapid progress of the past few weeks. I would summarise this
approach as:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Ensuring (to the extent possible) that correct code is always generated for
a simple RV32I baseline&lt;/li&gt;
&lt;li&gt;Expand that baseline to support more RISC-V ISA variants (RV{32,64}IMA and
later FD)&lt;/li&gt;
&lt;li&gt;Push forwards on optimisations (generated code quality) and compiler
feature support. Part of this work is moving to larger scale test programs and
benchmarks in order to maintain confidence about the correctness of generated
code.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This project is currently in the process of moving from point 2) to point 3)
on the list above. As it stands, you will benefit from LLVM&amp;rsquo;s many middle-end
optimisations, but the final code generation stage has seen little work
focused on the performance of generated code. With a high quality base now in
place, adding these optimisations can be done relatively easily.&lt;/p&gt;

&lt;p&gt;If you want to see first-class support for RISC-V in LLVM, now is the time to
get involved and help make it happen.&lt;/p&gt;

&lt;h2 id=&#34;roadmap-and-upcoming-events:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Roadmap and upcoming events&lt;/h2&gt;

&lt;p&gt;My aim is to have Clang and LLVM developed to serve as a competitive
alternative to GCC on RISC-V by the end of the calendar year. If the RISC-V
community works together, this is an achievable goal.&lt;/p&gt;

&lt;p&gt;My near-term goals are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Expand testing for RV64. There are rather few RV64 unit tests right now
because parameterising the backend by XLEN mostly &amp;ldquo;just worked&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Go through the implementation again (particularly recently added code) to
look for further cleanup or refactoring opportunities, then propose to merge
it upstream.&lt;/li&gt;
&lt;li&gt;Once I&amp;rsquo;m happy with the implementation approach for the most recently added
features, move the 5.0-based
&lt;a href=&#34;http://github.com/lowrisc/riscv-llvm-integration&#34;&gt;riscv-llvm-integration&lt;/a&gt;
tree forwards.&lt;/li&gt;
&lt;li&gt;Review patches from contributors such as Andes and help to support language
port efforts.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Focus areas after that include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Clang toolchain driver, MAFD codegen and ABI support&lt;/li&gt;
&lt;li&gt;Benchmarking vs RISC-V GCC and generated code quality improvements&lt;/li&gt;
&lt;li&gt;Documentation, expanded test cases, and improved compiler testing tooling&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;ve mapped out a number of TODO items
&lt;a href=&#34;https://github.com/lowRISC/riscv-llvm/issues&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m pleased to report that my proposal for a RISC-V &amp;ldquo;birds of a feather&amp;rdquo;
session at the &lt;a href=&#34;http://llvm.org/devmtg/2017-10/#bof4&#34;&gt;upcoming LLVM Dev
Meeting&lt;/a&gt; (Oct 18th) was accepted. You
should definitely attend this event if you are an LLVM developer working on an
out-of-tree RISC-V backends or are looking to get involved (representatives
from several companies in that position are already confirmed as attending).
We&amp;rsquo;re also looking to run a longer working/hacking session the day before, at
a San Jose location. More details on both events will be circulated shortly.&lt;/p&gt;

&lt;h2 id=&#34;faq:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;FAQ&lt;/h2&gt;

&lt;h3 id=&#34;do-you-care-about-performance-of-generated-code-and-code-size:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Do you care about performance of generated code and code size?&lt;/h3&gt;

&lt;p&gt;Like any compiler developer, of course. Starting with a solid and well tested
base is the best way of achieving those aims. We&amp;rsquo;re now in a position where we
can push forwards on these fronts, which will will soon become a primary focus
of this development effort.&lt;/p&gt;

&lt;h3 id=&#34;i-have-a-risc-v-llvm-fork-which-works-for-me-why-should-i-care-about-an-upstream-backend:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;I have a RISC-V LLVM fork which works for me, why should I care about an upstream backend?&lt;/h3&gt;

&lt;p&gt;This is ultimately a question about long-term maintenance and sharing the
support burden with others in the RISC-V ecosystem. By working together and
pooling our development efforts, we can unlock the benefits of the open source
approach. Contributing to this effort is almost definitely the right long-term
choice for your project. If you want to discuss how to contribute, please drop
me an email or come along to the upcoming birds of a feather session.&lt;/p&gt;

&lt;h3 id=&#34;what-is-the-difference-between-this-and-other-risc-v-llvm-efforts:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;What is the difference between this and other RISC-V LLVM efforts?&lt;/h3&gt;

&lt;p&gt;This effort is focused on high code quality, long term maintainability, and in
getting development merged in to upstream LLVM. Andes have recently released a
private development tree to the public. That tree was was based on an early
version of the lowRISC patchset, but diverged significantly in terms of
implementation approach. Andes are now working to submit patches to this
effort.&lt;/p&gt;

&lt;h3 id=&#34;who-are-you:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Who are you?&lt;/h3&gt;

&lt;p&gt;I (Alex Bradbury) am a co-founder and director of lowRISC CIC, where this
development work has been taking place. I have been developing LLVM backends
for the past seven years, and am now upstream code owner for the RISC-V
backend. If you&amp;rsquo;re interested in LLVM, you are hopefully already familiar with
my &lt;a href=&#34;http://llvmweekly.org/&#34;&gt;LLVM Weekly&lt;/a&gt; newsletter.&lt;/p&gt;

&lt;h3 id=&#34;why-is-lowrisc-interested-in-llvm:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Why is lowRISC interested in LLVM?&lt;/h3&gt;

&lt;p&gt;lowRISC is a not-for-profit created to push forward open source hardware by
developing a secure, open, and flexible SoC design. Enabling custom hardware
and derivative designs is about much more than shipping RTL with an open
source license - hardware is of little use without the software infrastructure
in place to support it. A high quality and easy to modify LLVM backend is
important for potential lowRISC adopters, but also benefits our own hardware
development efforts. Specifically, we will be building the software component
of our tagged memory mechanisms on top of LLVM. If our mission sounds
interesting to you, there&amp;rsquo;s good news - &lt;a href=&#34;http://www.lowrisc.org/blog/2017/09/were-hiring-work-on-making-open-source-hardware-a-reality/&#34;&gt;we&amp;rsquo;re
hiring&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;who-do-i-contact-to-discuss-further-sponsoring-this-effort:37a127be6d81e67368fb40a190b2ef8f&#34;&gt;Who do I contact to discuss further sponsoring this effort?&lt;/h3&gt;

&lt;p&gt;If your company would like to see lowRISC&amp;rsquo;s work on RISC-V LLVM be sustained
or expanded through 2018, then contributing development time and/or
sponsorship is the best way to do this. Please contact asb@lowrisc.org to
discuss further.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lowRISC tagged memory OS enablement</title>
      <link>http://www.lowrisc.org/blog/2017/09/lowrisc-tagged-memory-os-enablement</link>
      <pubDate>Tue, 19 Sep 2017 14:45:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/09/lowrisc-tagged-memory-os-enablement</guid>
      <description>&lt;p&gt;This summer, we were fortunate enough to have Katherine Lim join the lowRISC
team at the University of Cambridge Computer Laboratory as an intern.
Katherine&amp;rsquo;s focus was on operating system and software enabled for lowRISC&amp;rsquo;s
tagged memory, building upon our
&lt;a href=&#34;http://www.lowrisc.org/docs/minion-v0.4/&#34;&gt;most recent milestone release&lt;/a&gt;.
As Katherine&amp;rsquo;s &lt;a href=&#34;http://www.lowrisc.org/docs/tagged-memory-os-enablement-internship-2017/&#34;&gt;detailed write-up&lt;/a&gt; demonstrates,
it&amp;rsquo;s been a very productive summer.&lt;/p&gt;

&lt;p&gt;The goal of this internship was to take the lowRISC hardware release, and
demonstrate kernel support and software support for the hardware tagged memory
primitives. This includes support for context-switch of the &lt;code&gt;tagctrl&lt;/code&gt; register
used to configure tag rules, maintaining tags in pages upon copy-on-write,
delivering tag exceptions to user space, loading tags from ELF binaries, and
more. It culminated in a demonstration that pulls these various pieces of work
together, showing how tagged memory can be used to mark valid branch targets.
Read the &lt;a href=&#34;http://www.lowrisc.org/docs/tagged-memory-os-enablement-internship-2017/&#34;&gt;report&lt;/a&gt; for full
details.&lt;/p&gt;

&lt;p&gt;We believe there is a rich design space in hardware support for tagged memory
and tag-based software policies. This operating system enablement work is an
important part of exploring that space, and in making it easier for other
groups to do the same.&lt;/p&gt;

&lt;p&gt;If working on problems like this sounds interesting to you, there&amp;rsquo;s good news
- &lt;a href=&#34;http://www.lowrisc.org/blog/2017/09/were-hiring-work-on-making-open-source-hardware-a-reality&#34;&gt;&lt;strong&gt;we&amp;rsquo;re hiring&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury and Katherine Lim&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>We&#39;re hiring! Work on making open source hardware a reality</title>
      <link>http://www.lowrisc.org/blog/2017/09/were-hiring-work-on-making-open-source-hardware-a-reality</link>
      <pubDate>Mon, 18 Sep 2017 08:15:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/09/were-hiring-work-on-making-open-source-hardware-a-reality</guid>
      <description>&lt;p&gt;We are looking for a talented hardware engineer to join the lowRISC team and
help make our vision for an open source, secure, and flexible SoC a reality.
&lt;a href=&#34;https://lowrisc.workable.com/j/DBAC61322F&#34;&gt;Apply now&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;lowRISC C.I.C. is a not-for-profit company that aims to demonstrate, promote
and support the use of open-source hardware. The lowRISC project was
established in 2014 with the aim of bringing the benefits of open-source to
the hardware world. It is working to do this by producing a high quality,
secure, open, and flexible System-on-Chip (SoC) platform. lowRISC C.I.C. also
provides hardware and software services to support the growing RISC-V
ecosystem. Our expertise includes the LLVM Compiler, hardware security
extensions and RISC-V tools, hardware and processor design.&lt;/p&gt;

&lt;p&gt;The successful candidate will be interested in computer architecture and
hardware design. The primary focus of the role will be the development of the
lowRISC SoC platform, which will involve work to evaluate and extend our
current design including our general-purpose tagged-memory system. lowRISC is
an ambitious project with a small core team, so you will be heavily involved
in the project&amp;rsquo;s development direction. This role will involve frequent work
with external contributors and collaborators. While much of the work will be
at the hardware level the post will offer experience of the full
hardware/software stack, higher-level simulation tools and architectural
design issues.&lt;/p&gt;

&lt;p&gt;Some practical experience of hardware design with a HDL such as
Verilog/SystemVerilog is essential, as is a good knowledge of the HW/SW stack.
Ideally, candidates will also have experience or demonstrated interest in some
of: SoC design, large-scale open source development, hardware or software
security, technical documentation, board support package development and
driver development. Industrial experience and higher degree levels are valued,
but we would be happy to consider an enthusiastic recent graduate with a
strong academic record.&lt;/p&gt;

&lt;p&gt;Informal enquires should be made to Alex Bradbury &lt;a href=&#34;mailto:asb@lowrisc.org&#34;&gt;asb@lowrisc.org&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building upstream RISC-V GCC&#43;binutils&#43;newlib: the quick and dirty way</title>
      <link>http://www.lowrisc.org/blog/2017/09/building-upstream-risc-v-gccbinutilsnewlib-the-quick-and-dirty-way</link>
      <pubDate>Tue, 05 Sep 2017 14:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/09/building-upstream-risc-v-gccbinutilsnewlib-the-quick-and-dirty-way</guid>
      <description>&lt;p&gt;There are a number of available options for building a RISC-V GCC toolchain.
You might use the build system from the
&lt;a href=&#34;https://github.com/riscv/riscv-tools&#34;&gt;riscv/riscv-tools repository&lt;/a&gt;, or
investigate toolchain generators such as
&lt;a href=&#34;http://crosstool-ng.github.io/&#34;&gt;crosstool-ng&lt;/a&gt;. However in the case of
riscv-tools, it&amp;rsquo;s not always clear how this corresponds to the code in the
relevant upstream projects. When investigating a potential bug, you often just
want to build the latest upstream code with as little fuss as possible. For
distribution purposes you&amp;rsquo;d probably want to perform a proper multi-stage
build, but for a quick test you might find the following recipe useful:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone --depth=1 git://gcc.gnu.org/git/gcc.git gcc
git clone --depth=1 git://sourceware.org/git/binutils-gdb.git
git clone --depth=1 git://sourceware.org/git/newlib-cygwin.git
mkdir combined
cd combined
ln -s ../newlib-cygwin/* .
ln --force -s ../binutils-gdb/* .
ln --force -s ../gcc/* .
mkdir build
cd build
../configure --target=riscv32-unknown-elf --enable-languages=c \
--disable-shared --disable-threads --disable-multilib --disable-gdb \
--disable-libssp --with-newlib \
--with-arch=rv32ima --with-abi=ilp32 --prefix=$(pwd)/built
make -j
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will produce a newlib toolchain targeting RV32IMA in the &lt;code&gt;built/&lt;/code&gt;
subdirectory. When files are duplicated in the newlib, binutils and gcc
repositories, the gcc version takes precedence.&lt;/p&gt;

&lt;p&gt;Major credit to everyone who worked on getting these toolchain
ports upstream (Kito Cheng, Palmer Dabbelt, and others).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lowRISC 0-4 milestone release</title>
      <link>http://www.lowrisc.org/blog/2017/06/lowrisc-0-4-milestone-release</link>
      <pubDate>Fri, 09 Jun 2017 12:35:57 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/06/lowrisc-0-4-milestone-release</guid>
      <description>&lt;p&gt;The &lt;a href=&#34;http://www.lowrisc.org/docs/minion-v0.4/&#34;&gt;lowRISC 0.4 milestone release&lt;/a&gt;
is now available. The various changes are best described in our &lt;a href=&#34;http://www.lowrisc.org/docs/minion-v0.4/&#34;&gt;accompanying
documentation&lt;/a&gt;, but in summary this
release:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Moves forward our support for tagged memory by re-integrating the tag cache,
reducing overhead with a &lt;a href=&#34;http://www.lowrisc.org/docs/minion-v0.4/tag_cache/&#34;&gt;hierarchical scheme&lt;/a&gt;.
This will significantly reduce caches misses caused by tagged memory accesses
where tags are distributed sparsely.&lt;/li&gt;
&lt;li&gt;Integrates support for specifying and configuring &lt;a href=&#34;http://www.lowrisc.org/docs/minion-v0.4/tag_core/&#34;&gt;tag propagation and
exception behaviour&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;A &lt;a href=&#34;http://www.pulp-platform.org/&#34;&gt;PULPino&lt;/a&gt; based &amp;ldquo;minion core&amp;rdquo; has been
integrated, and is used to provide peripherals such as the SD card
interface, keyboard, and VGA tex display (when using the Nexys4 DDR FPGA
development board).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Please report any issues &lt;a href=&#34;https://github.com/lowRISC/lowrisc-chip&#34;&gt;on our GitHub
repository&lt;/a&gt;, or discuss on our
&lt;a href=&#34;http://listmaster.pepperfish.net/cgi-bin/mailman/listinfo/lowrisc-dev-lists.lowrisc.org&#34;&gt;mailing list&lt;/a&gt;. As always, thank you to everyone who has contributed in any way - whether it&amp;rsquo;s advice and feedback, bug reports, code, or ideas.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apply now for GSoC 2017</title>
      <link>http://www.lowrisc.org/blog/2017/03/apply-now-for-gsoc-2017</link>
      <pubDate>Mon, 27 Mar 2017 09:35:57 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/03/apply-now-for-gsoc-2017</guid>
      <description>&lt;p&gt;We are very grateful for being selected again to take part as a mentoring
organisation in the &lt;a href=&#34;https://summerofcode.withgoogle.com/&#34;&gt;Google Summer of
Code&lt;/a&gt;, now for the third year running.
If you are a student who would like to be paid to work on open source during
the summer, then take a look at &lt;a href=&#34;http://www.lowrisc.org/docs/gsoc-2017-ideas/&#34;&gt;the lowRISC ideas
list&lt;/a&gt; and
&lt;a href=&#34;https://summerofcode.withgoogle.com/organizations/6271463900315648/&#34;&gt;apply&lt;/a&gt;.
The deadline for applications is 4pm UTC on April 3rd. We&amp;rsquo;re always very interested in
ideas suggested by students, and encourage you to share them &lt;a href=&#34;https://listmaster.pepperfish.net/cgi-bin/mailman/listinfo/lowrisc-dev-lists.lowrisc.org&#34;&gt;on our
discussion
list&lt;/a&gt;
for feedback before making a proposal.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2017 NetFPGA Design Challenge</title>
      <link>http://www.lowrisc.org/blog/2017/02/2017-netfpga-design-challenge</link>
      <pubDate>Wed, 01 Feb 2017 14:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2017/02/2017-netfpga-design-challenge</guid>
      <description>&lt;p&gt;As most of you know, the majority of full-time development on lowRISC takes
place at the University of Cambridge Computer Laboratory. However, we&amp;rsquo;re far
from the only open source hardware activity at the University. Our colleagues
on the NetFPGA project have an open source design challenge that many readers
of this blog might be interested in. See the &lt;a href=&#34;http://www.cl.cam.ac.uk/research/srg/netfpga/challenge2017/&#34;&gt;design challenge
website&lt;/a&gt;, or read
below for more details:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;We are pleased to announce the 2017 NetFPGA Design Challenge!

NetFPGA platforms are used by the networked systems community for close to 
a decade. The platforms enable researchers and instructors to build 
high-speed, hardware-accelerated networking systems. The platforms can be used 
by researchers to prototype advanced services for next-generation networked 
systems. By using Field Programmable Gate Arrays (FPGAs), NetFPGA enables new 
types of packet routing circuits to be implemented and detailed measurements 
of network traffic to be obtained.

The NetFPGA 2017 contest is a design challenge. The design teams are to 
produce a working implementation employing any HW and SW design methodology 
and targeting the NetFPGA SUME platform. The deadline for submissions is April 
13th, 2017. The winners will be announced at the NetFPGA Developers Summit 
(Thursday 20th - Friday, 21st April, 2017 Cambridge, UK).

Challenge: Lowest Latency Switch

Low latency devices are being increasingly used across a large number of 
applications. Low latency solutions are few, and are rarely open source. The 
goal of this challenge is to provide a usable, high performance, open source 
alternative to use by universities and organizations who need the flexibility 
of open source.  The systems will be evaluated using OSNT, an Open Source 
Network Tester. Test benches will be available online, for users to experiment 
and independently evaluate their design. The competition is open to students 
of all levels (undergraduate and postgraduate), as well as to non students. 
There is no need to own a NetFPGA SUME platform to take part in the 
competition although, clearly, development and testing will be made easier if 
you have access to this platform.  

Team Prizes:
First place: 500
Best students project: 500

The winning projects and runner ups will be invited to present their work 
at the NetFPGA Developers Summit 2017.  All challenge participants are keenly 
encouraged to attend the NetFPGA Developers Summit and are entitled to a 
reduced registration rate.

The design challenge prizes are generously 
supported by IMC http://www.imc.nl/
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>lowRISC Q&#43;A</title>
      <link>http://www.lowrisc.org/blog/2016/12/lowrisc-qa</link>
      <pubDate>Fri, 09 Dec 2016 17:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/12/lowrisc-qa</guid>
      <description>&lt;p&gt;Yesterday, lowRISC triggered a lot of discussion when someone submitted it to
Hacker News. The &lt;a href=&#34;https://news.ycombinator.com/item?id=13129076&#34;&gt;comment
thread&lt;/a&gt; became something of an
impromptu Q+A about our project direction and status. I thought it was worth
linking to it here and highlighting the discussion for a wider audience. If
you have any additional questions, then feel free to comment on this blog post
or else, as always, drop by our &lt;a href=&#34;http://www.lowrisc.org/community/&#34;&gt;mailing list&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Alex Bradbury&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fifth RISC-V Workshop: Day Two</title>
      <link>http://www.lowrisc.org/blog/2016/11/fifth-risc-v-workshop-day-two</link>
      <pubDate>Wed, 30 Nov 2016 17:00:00 +0000</pubDate>
      
      <guid>http://www.lowrisc.org/blog/2016/11/fifth-risc-v-workshop-day-two</guid>
      <description>

&lt;p&gt;Today is the second day of the &lt;a href=&#34;https://riscv.org/2016/10/5th-risc-v-workshop-agenda/&#34;&gt;fifth RISC-V
workshop&lt;/a&gt;. I&amp;rsquo;ll be
keeping a semi-live blog of talks and announcements throughout the day.&lt;/p&gt;

&lt;h2 id=&#34;opensoc-system-architect-farzad-fatollahi-fard:529e3037a37627249629f6513082618e&#34;&gt;OpenSoC System Architect: Farzad Fatollahi-Fard&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Current architectures are wasteful. Only a small fraction of chip area goes
to computation.&lt;/li&gt;
&lt;li&gt;For both GoblinCore and OpenHPC, ended up doing a lot of similar work to
achieve only a point design. Why not make a generator to avoid repeating the
same steps?&lt;/li&gt;
&lt;li&gt;OpenSoC System Architect is a combination of multiple tools to form a
well-defined development flow for complex RISC-V SoCs&lt;/li&gt;
&lt;li&gt;Supports standard RISC-V modules and custom extensions&lt;/li&gt;
&lt;li&gt;It outputs pre-verified Chisel for the SoC, synthesisable Verilog, and an
LLVM compiler for the SoC&lt;/li&gt;
&lt;li&gt;OpenSoC Fabric is an open-source, flexible, parameterised NoC generator. It
integrates with a wide variety of existing processors, as well as IO devices.&lt;/li&gt;
&lt;li&gt;Created a &amp;lsquo;CoreGen&amp;rsquo; IR. It allows automatic generation of HDL
representations of the SoC and build LLVM compiler backend implementations of
the SoC and any extensions.&lt;/li&gt;
&lt;li&gt;The IR is stored on disk in well-formed XML&lt;/li&gt;
&lt;li&gt;What&amp;rsquo;s next? Better support for Chisel3, more integration with existing
RISC-V tools and environment, frontend support to import existing
Chisel/Verilog/SystemVerilog. Also want CoreGen as a standalone IR&lt;/li&gt;
&lt;li&gt;See the website at &lt;a href=&#34;http://www.opensoc.community/&#34;&gt;http://www.opensoc.community/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;v-vector-extension-proposal-krste-asanovic:529e3037a37627249629f6513082618e&#34;&gt;V Vector Extension Proposal: Krste Asanovic&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The vector extension intends to scale to all reasonable design points
(low-cost microcontroller or high-performance supercomputer). Support both
implicit auto-vectorisation and explicit SPMD&lt;/li&gt;
&lt;li&gt;Fit into the 32-bit encoding space, but be a base for future vector
extensions (e.g. crypto algorithms)&lt;/li&gt;
&lt;li&gt;The goal is to ratify a proposal 12 months from now, at the 7th workshop&lt;/li&gt;
&lt;li&gt;Cray-style vectors. &amp;ldquo;The right way&amp;rdquo; to exploit SIMD parallelism (as opposed
to the wrong way: GPUs or packed SIMD)&lt;/li&gt;
&lt;li&gt;V has an implementation-dependent vector length, meaning the same code runs
across different hardware without recompiling&lt;/li&gt;
&lt;li&gt;Each vector data register is configured with a width and type, or disabled.
There are also a configurable number of predicate registers. The maximum
vector length is a function of configuration, physical register storage, and
microarchitecture&lt;/li&gt;
&lt;li&gt;There are a number of mandatory supported types. e.g. an RV32IF system must
support X8, X16, X32, F16, F32. This means that scalar and vector half
precision floating point is a requirement if you are supporting floating
point.&lt;/li&gt;
&lt;li&gt;Each vector data register has a 4-bit field in a CSR (or multiple CSRs)
indicating its width, and another for its type.&lt;/li&gt;
&lt;li&gt;A vcfgd CSR alias is defined to allow faster writes of common vector data
configurations.&lt;/li&gt;
&lt;li&gt;Most user code would use the setvl instruction (which is actually setting a
CSR).&lt;/li&gt;
&lt;li&gt;A 16-bit+32-bit vector addition is pleasingly straight forward to specify in
assembly&lt;/li&gt;
&lt;li&gt;The architecture guarantees a minimum vector length of four regardless of
configuration. This means 1KB SRAM is required as a minimum&lt;/li&gt;
&lt;li&gt;A polymorphic instruction encoding is used. A single signed integer ADD
opcode works on different size inputs and outputs, depending on the
configuration of its inputs.&lt;/li&gt;
&lt;li&gt;There is support for vector atomics (e.g. vector fetch-and-add).&lt;/li&gt;
&lt;li&gt;For vector function calls (e.g. in auto-vectorised code) you want to make
vector calls to a function library with separate vector calling convention.
The caller has to allocate registers for the callee to use. It sets the
maximum width, allowing the callee to change the vctype as needed.&lt;/li&gt;
&lt;li&gt;For OpenCL/CUDA/SPMD, the configuration must be set at kernel launch to the
maximum width used anywhere in the call tree. It needs a general vector
function call capability with standard callee/caller save protocol&lt;/li&gt;
&lt;li&gt;Krste argues autovectorisation is much preferable to OpenCL or CUDA.&lt;/li&gt;
&lt;li&gt;Question: are you interested in smaller types (e.g. 4-bit). Answer: yes,
also interested in non-power-of-two types&lt;/li&gt;
&lt;li&gt;Question about the calling convention: the vector configuration state is
assumed to be caller-saved (including the vector register file), meaning the
scalar ABI is unmodified&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;towards-thousand-core-risc-v-shared-memory-systems-quan-nguyen:529e3037a37627249629f6513082618e&#34;&gt;Towards Thousand-Core RISC-V Shared Memory Systems: Quan Nguyen&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Tardis is a new cache coherency protocol with greater scalability than
traditional directory coherence protocols.&lt;/li&gt;
&lt;li&gt;Tardis enforces consistency through timestamps, using logical leases&lt;/li&gt;
&lt;li&gt;It only tracks the exclusive owner of any particular cache line, requiring
only O(log N) storage. No broadcast invalidations, and timestamps aren&amp;rsquo;t tied
to the core count. There is no need for synchronised real-time clocks&lt;/li&gt;
&lt;li&gt;They are building a thousand-core prototype. Fit as many cores as possible
on a ZC706 FPGA, the connect in a 3D mesh to demonstrate at scale.&lt;/li&gt;
&lt;li&gt;Want to adapt Tardis for release consistency (rather than sequential
consistency), and Quan introduces how they have started to do this by
introducing new timestamps&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;scrx-a-family-of-state-of-the-art-risc-v-synthesizable-cores-alexander-redkin:529e3037a37627249629f6513082618e&#34;&gt;SCRx: a family of state-of-the art RISC-V synthesizable cores: Alexander Redkin&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Syntacore develops and licenses energy-efficient programmable cores
implementing the RISC-V ISA&lt;/li&gt;
&lt;li&gt;SCRx is the family of RISC-V implementations, now available for evaluation.
Each core can be extended and customised&lt;/li&gt;
&lt;li&gt;The smallest core, SCR1 is less than 20kgates in a basic untethered
configuration.&lt;/li&gt;
&lt;li&gt;SCR3 is a high-performance MCU core with up to 1.7DMIPS/MHz,
3.16CoreMark/MHz.&lt;/li&gt;
&lt;li&gt;SCR4 is an MCU core with a high-performance FPU.&lt;/li&gt;
&lt;li&gt;SCR5 is an efficient mid-range embedded core. Full MMU with Linux support.
1GHz+ at 28nm, and 1.5+DMIPS/MHz per core.&lt;/li&gt;
&lt;li&gt;In the near term, want to support the latest privileged spec, adding trace
debug&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;enabling-hardware-software-co-design-with-risc-v-and-llvm-alex-bradbury:529e3037a37627249629f6513082618e&#34;&gt;Enabling hardware/software co-design with RISC-V and LLVM: Alex Bradbury&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;I&amp;rsquo;ll try and write something up for the blog later, but for now see my
slides
&lt;a href=&#34;https://speakerdeck.com/asb/software-co-design-with-risc-v-and-llvm&#34;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vm-threads-an-alternative-model-for-virtual-machines-on-risc-vm-ron-minnich:529e3037a37627249629f6513082618e&#34;&gt;VM threads: an alternative model for virtual machines on RISC-VM: Ron Minnich&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Akaros is a research kernel originally from UC Berkeley.&lt;/li&gt;
&lt;li&gt;One core idea is the &amp;lsquo;multi core process&amp;rsquo;. This can be thought of as a set
of cores assigned an entity to a program.&lt;/li&gt;
&lt;li&gt;How do VMs fit into the Akaros model. A VM could be kind of a process.&lt;/li&gt;
&lt;li&gt;Look back at how we start a process. With the introduction of fork(), it
became easy and clean. But its introduction was controversial.&lt;/li&gt;
&lt;li&gt;Virtualisation on Linux/BSD/Unix requires a device (e.g. /dev/kvm). This
typically requires daemons who are used to interact with the device. In
Akaros, they did not want to recreate this.&lt;/li&gt;
&lt;li&gt;Can we just run a virtual machine like we do a thread? Introduce
&lt;code&gt;vthread_create&lt;/code&gt;. In Akaros, they have extended the thread model to include
virtual machine threads.&lt;/li&gt;
&lt;li&gt;Virtual machine threads (vthreads) can run Linux 4.8 (with 12 lines of
patches) and any code that shares the host ring 3 address space.&lt;/li&gt;
&lt;li&gt;Ring 3 and Ring V share and address space. Ring V is limited to 2^46 bytes,
while ring 3 is in a 2^47 byte address space.&lt;/li&gt;
&lt;li&gt;VM threads are integrated tightly into the kernel.&lt;/li&gt;
&lt;li&gt;On x86, Akaros pairs page table roots and page table pages. Page table pages
are 2x4k pages, with the process PTP in the lower 4K and the VM PTP in the
upper 4K. This makes it trivial to convert the two.&lt;/li&gt;
&lt;li&gt;It is significantly easier to write virtual machine managers in Akaros than
with the Linux model&lt;/li&gt;
&lt;li&gt;Akaros VMS are unlike any other VMs - threads can easily switch from being a
VM to being a host thread&lt;/li&gt;
&lt;li&gt;Kernels also look like threads, and spinning up a core looks like CPU
hotplug, accomplished by spinning up a vthread with IP at the 64-bit entry
point.&lt;/li&gt;
&lt;li&gt;There are a variety of implications and questions for RISC-V. How will
RISC-V handle nested paging? Can we avoid massive shadow state. How about
injecting interrupts without a vmexit?&lt;/li&gt;
&lt;li&gt;RISC-V is a chance to enable software innovation. We shouldn&amp;rsquo;t get locked
into &amp;ldquo;but we&amp;rsquo;ve always done it this way&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;enabling-low-power-smartphone-like-graphical-uis-for-risc-v-socs-michael-gielda:529e3037a37627249629f6513082618e&#34;&gt;Enabling low-power, smartphone-like graphical UIs for RISC-V SoCs: Michael Gielda&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Industrial/embedded UIs mostly look bad, but also have terribly user
experience&lt;/li&gt;
&lt;li&gt;For better UIs you mostly have to jump to Android or Linux - there&amp;rsquo;s a lack
of a middle ground&lt;/li&gt;
&lt;li&gt;For a previous project, produced a mobile-like GUI experience targeting an
MCU (STM32F4).&lt;/li&gt;
&lt;li&gt;With the right approach and tools, embedded GUIs can be beautiful too&lt;/li&gt;
&lt;li&gt;Their library was written in C++, with support for layers+formats. It has
its own font engine for kerning, anti-aliasing etc.&lt;/li&gt;
&lt;li&gt;The GUI is specified in XML and has its own minimal CSS&lt;/li&gt;
&lt;li&gt;Initially developed for eCos RTOS, and has an initial port for FreeRTOS. Can
also run on Linux.&lt;/li&gt;
&lt;li&gt;To prototype on a Zynq, implemented &amp;lsquo;micro blender&amp;rsquo; for blending, filling,
scaling etc. This was written in Chisel.&lt;/li&gt;
&lt;li&gt;Software-driven IP (silicon) is possible (and advisable!)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-fast-instruction-set-simulator-for-risc-v-maxim-maslov:529e3037a37627249629f6513082618e&#34;&gt;A Fast Instruction Set Simulator for RISC-V: Maxim Maslov&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Esperanto is a stealth mode startup designing chips with RISC-V&lt;/li&gt;
&lt;li&gt;Wanted a fast RISC-V ISA simulator capable of running large applications
with minimal slowdown&lt;/li&gt;
&lt;li&gt;[Sorry folks, I had to duck out for a quick discussion - see the
&lt;a href=&#34;https://riscv.org/wp-content/uploads/2016/11/Wed1330-Fast-ISA-Simulator-for-RISC-V-Maslov-Esperanto.pdf&#34;&gt;slides&lt;/a&gt;]&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-on-rv64g-benjamin-barenblat-and-michael-pratt:529e3037a37627249629f6513082618e&#34;&gt;Go on RV64G: Benjamin Barenblat and Michael Pratt&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why RISC-V? Better architecture, lower power, faster processing, easier
accelerator development. RISC-V is not going away&lt;/li&gt;
&lt;li&gt;The Go toolchain is complex. It has its own compiler, assembler (and
assembly language), and linker&lt;/li&gt;
&lt;li&gt;Getting close, but the runtime doesn&amp;rsquo;t quite compile. Hope to get it working
in the next few months.&lt;/li&gt;
&lt;li&gt;In the mean time, relatively simple go programs will compile and run&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s been mostly good. One pain-point has been that other Go ports don&amp;rsquo;t
target architectures with good conditional branches so had to emulate a flag
register. Another gripe is that loading 64-bit constants is a pain.&lt;/li&gt;
&lt;li&gt;Within a couple of months you should be able to compile real Go programs and
have them run on RISC-V&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-java-virtual-machine-for-risc-v-porting-the-jikes-rvm-martin-maas:529e3037a37627249629f6513082618e&#34;&gt;A Java Virtual Machine for RISC-V: Porting the Jikes RVM: Martin Maas&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why do a JVM port? Both to run interesting applications, and for research
(e.g. hardware support for GCed languages)&lt;/li&gt;
&lt;li&gt;Porting OpenJDK/Hotspot for high performance, and the Jikes research VM for
academic work. This talk will focus on Jikes&lt;/li&gt;
&lt;li&gt;Jikes is itself written in Java&lt;/li&gt;
&lt;li&gt;JVMs have a large number of dependencies, so use the riscv-poky Linux
distribution generator to build a cross-compiled SDK and Linux image.&lt;/li&gt;
&lt;li&gt;While developing, add assertions everywhere to fail as early as possible&lt;/li&gt;
&lt;li&gt;Allowed the JIT to selectively emit instructions that dump trace output&lt;/li&gt;
&lt;li&gt;Booting JikesRVM is no easy task (there a &lt;em&gt;lot&lt;/em&gt; to do in order to get to
hello world)&lt;/li&gt;
&lt;li&gt;The non-optimising JIT compiler is mostly feature-complete. Passes &lt;sup&gt;65&lt;/sup&gt;&amp;frasl;&lt;sub&gt;68&lt;/sub&gt;
core tests. Targets RV64G&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;yopuzzle-an-open-v-development-platform-the-next-generation-elkim-roa:529e3037a37627249629f6513082618e&#34;&gt;YoPuzzle - an Open-V development platform the next generation: Elkim Roa&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&amp;lsquo;Open source&amp;rsquo; hardware. Raspberry Pi have sold 10 million boards, Arduino
sold 4.5 million boards (estimated). Some predictions indicate the market will
be worth over $1B within the next four years. These are based on commercial,
closed-source silicon&lt;/li&gt;
&lt;li&gt;OnChip UIS have developed an open 32-bit RISC-V based microcontroller. To
test the initial silicon, used chip-on-board&lt;/li&gt;
&lt;li&gt;RV32IM with a 3-stage pipeline. On TSMC 130nm GP. Die area 2.1mm x 2.1mm.&lt;/li&gt;
&lt;li&gt;The Microprocessor core is 0.12mm2, max freq 200MHz, core voltage 1.2V, core
dynamic power at 100MHz is 167uW/MHz (all peripheral clocks disabled)&lt;/li&gt;
&lt;li&gt;Arduino is mostly aimed at children in secondary schools. But what about
1-10 year olds?&lt;/li&gt;
&lt;li&gt;The Open-V microcontroller is up on crowdsupply, trying to raise funds to
produce 70k chips. Aim to do the second tapeout in Q1 2017, and produce puzzle
boards in Q2 2018.&lt;/li&gt;
&lt;li&gt;Elkim showed a neat live demo of the OnChip prototype along with a
browser-based programming environment&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-risc-v-community-needs-peripheral-cores-elkim-roa:529e3037a37627249629f6513082618e&#34;&gt;The RISC-V community needs peripheral cores: Elkim Roa&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;It&amp;rsquo;s good to have an open ISA, but what about the peripherals? e.g. PHYs,
bus IP, clocking circuitry, GPIO&lt;/li&gt;
&lt;li&gt;Open hardware would translate into quality (Linux) drivers&lt;/li&gt;
&lt;li&gt;There is no standard for GPIO. Want to have standard features (e.g.
switching speed, current drive) with a standard interface.&lt;/li&gt;
&lt;li&gt;The OnChip peripherals use AMBA buses&lt;/li&gt;
&lt;li&gt;Have a synthesizable CDR and PLL&lt;/li&gt;
&lt;li&gt;Are working on USB 3.1 gen 2, including the analog frontend.&lt;/li&gt;
&lt;li&gt;Have also been working on &amp;lsquo;chipscope&amp;rsquo; and offset correction&lt;/li&gt;
&lt;li&gt;Also working on LPDDR3. PCS is done, working on UVM IP&lt;/li&gt;
&lt;li&gt;Have a fully synthesised true-random noise generator, and working on NVRAM
on CMOS&lt;/li&gt;
&lt;li&gt;Suggestion: have a common listing of recommended IP (e.g. SPI, I2C, USB PHY
etc).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sub-microsecond-adaptive-voltage-scaling-in-a-28nm-risc-v-socs-ben-keller:529e3037a37627249629f6513082618e&#34;&gt;Sub-microsecond Adaptive Voltage Scaling in a 28nm RISC-V SoCs: Ben Keller&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Energy efficiency is critical in mobile applications&lt;/li&gt;
&lt;li&gt;Faster adaptive voltage scaling (AVS) saves more energy, especially for
bursty workloads&lt;/li&gt;
&lt;li&gt;State of the art SoCs cannot achieve fine-grained AVS because they use
off-chip regulators&lt;/li&gt;
&lt;li&gt;Integrate switch-cap regulators entirely on-die.&lt;/li&gt;
&lt;li&gt;Need adaptive clock generation&lt;/li&gt;
&lt;li&gt;The tape-out (~2 years ago) featured a version of Rocket. 16K I$, 32K D$, no
L2. It also feature a version of Hwacha&lt;/li&gt;
&lt;li&gt;Use a Z-scale core for the power management unit&lt;/li&gt;
&lt;li&gt;Taped out in 28nm FD-SOI. Die area 3.03mm2, with the core area 1.07mm2. 568K
standard cells&lt;/li&gt;
&lt;li&gt;Achieved 41.8 DP GFLOPS/W&lt;/li&gt;
&lt;li&gt;Body bias can be tuned to optimise efficiency for different workloads&lt;/li&gt;
&lt;li&gt;Integrated voltage regulation provided 82-89% system efficiency with
adaptive clocking&lt;/li&gt;
&lt;li&gt;Sub-microsecond adaptive voltage scaling provided up to 40% energy savings
with negligible performance loss&lt;/li&gt;
&lt;li&gt;Will now talk about the Berkeley interpretation of &amp;lsquo;agile&amp;rsquo; hardware
development. See &amp;ldquo;An Agile Approach to Building RISC-V Microprocessors&amp;rdquo;, MICRO
2016.&lt;/li&gt;
&lt;li&gt;&amp;lsquo;Tape-ins&amp;rsquo; before &amp;lsquo;tape-outs&amp;rsquo;. Sprint to an initial design that is
feature-incomplete but functional, put it through the tools etc and shake out
the issues with the VLSI flow. Then iteratively add features.&lt;/li&gt;
&lt;li&gt;There have been 13 Berkeley RISC-V tapeouts in the last 5 years&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;reprogrammable-redundancy-for-cache-vmin-reduction-in-a-28nm-risc-v-processor-brian-zimmer:529e3037a37627249629f6513082618e&#34;&gt;Reprogrammable Redundancy for Cache Vmin Reduction in a 28nm RISC-V Processor: Brian Zimmer&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Voltage scaling is effective in reducing energy consumption, and SRAM limits
the minimum operating voltage&lt;/li&gt;
&lt;li&gt;Instead of preventing errors, tolerate errors. A significant reduction in
the minimum voltage is possibly by tolerating 1000s of errors per MB of SRAM&lt;/li&gt;
&lt;li&gt;There&amp;rsquo;s been lots of work on the circuit-level for preventing errors, and at
the architectural level for tolerating errors&lt;/li&gt;
&lt;li&gt;Goal for the chip is to prove that SRAM Vmin can be effectively lowered by
tolerating a reasonable number of failing bitcells&lt;/li&gt;
&lt;li&gt;Built on Rocket and modified caches to add reprogrammable redundancy, ECC,
and BIST&lt;/li&gt;
&lt;li&gt;Implemented three techniques: dynamic column redundancy (avoid single-bit
errors in data SRAM), line disable (avoid &lt;code&gt;&amp;gt;=&lt;/code&gt; 2 bit errors in data SRAM), and
bit bypass (avoid all errors in tag SRAM)&lt;/li&gt;
&lt;li&gt;The system architecture involves three voltage domains. One for the uncore,
one for the core, and another for the L2 cache&lt;/li&gt;
&lt;li&gt;Reprogrammable redundancy is fairly straight-forward to add to the L1, but
ECC is more difficult. The ECC decoding is pipelined. If an error is detected,
the operation is recycled&lt;/li&gt;
&lt;li&gt;There is a 2% area overhead for the L2.&lt;/li&gt;
&lt;li&gt;Fabricated prototype is TSMC 28nm HPM.&lt;/li&gt;
&lt;li&gt;The proposed techniques achieve 25% average Vmin reduction (and 49% power
reduction) in the L2 for a 2% area overhead&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

