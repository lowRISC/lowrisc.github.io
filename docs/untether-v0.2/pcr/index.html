<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><base href=https://www.lowrisc.org><link rel=icon type=image/png sizes=32x32 href=/favicon.png><title>Memory and I/O maps, soft reset, and interrupts &middot; lowRISC: Collaborative open silicon engineering</title><link href=/main.b0a63.css rel=stylesheet><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-53520714-1','auto');ga('send','pageview');}</script></head><body><header><nav class="navbar navbar-expand-md navbar-light"><div class=container><a class=navbar-brand href=#><img src=/img/logo/logo-dualcolor.svg alt=lowRISC></a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarCollapse aria-controls=navbarCollapse aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarCollapse><ul class="navbar-nav ml-auto"><li class=nav-item><a href=/our-work class=nav-link>Our work</a></li><li class=nav-item><a href=/open-silicon class=nav-link>Open Silicon</a></li><li class=nav-item><a href=/community class=nav-link>Community</a></li><li class=nav-item><a href=/blog class=nav-link>Blog</a></li><li class=nav-item><a href=/jobs class=nav-link>Jobs</a></li><li class=nav-item><a href=/about class=nav-link>About us</a></li><li class=nav-item><a class="btn lr-navbar-btn-gh" href=https://github.com/lowrisc>GitHub</a></li></ul></div></div></nav></header><main role=main><div class=container><h1>Memory and I/O maps, soft reset, and interrupts</h1><p><strong>Note: the content of this section is subject to change as the specification develops.</strong></p><p>This <code>untethered</code> release starts to regulate the shared resources among cores, such as interrupts, memory and I/O maps, global timers, etc. A subset of control status register (CSR) space is defined as processor control registers (PCRs), whose values and accesses are shared by all cores and controlled by a global PCR control unit (<code>PCRControl</code>). The connections of the PCR control units is shown below.</p><p><img src=../figures/pcr_ctl.png alt=Drawing style=width:450px></p><h2 id=ports-of-pcrcontrol:e2024145d35b2c747c2f5bf628155765>Ports of <code>PCRControl</code></h2><h4 id=pcr-read-write-requests-pcr-req:e2024145d35b2c747c2f5bf628155765>PCR read/write requests (<code>pcr_req</code>)</h4><p>The CSR file in each core has a dedicated request channel to the global PCR control unit. When a CSR address is identified as a PCR, the CSR request is forwarded to <code>PCRControl</code>.</p><h4 id=pcr-read-write-response-pcr-resp:e2024145d35b2c747c2f5bf628155765>PCR read/write response (<code>pcr_resp</code>)</h4><p>Upon receiving a request from <code>pcr_req</code>, the PCR control unit processes the
request and sends back a response through the <code>pcr_resp</code> port connected to the
requesting core when it is finished. When it is a read request, the PCR value
is sent back in the response.</p><h4 id=broadcast-of-pcr-update-pcr-update:e2024145d35b2c747c2f5bf628155765>Broadcast of PCR update (<code>pcr_update</code>)</h4><p>Operations on some PCRs trigger changes of the global status, such as changing
the I/O map. In this case, the updated PCR is broadcast to all components
potentially affected by this change. In this implementation, every L1 D$ has
an <code>ioaddr</code> module for identifying I/O requests. To enforce the address
mapping defined in the memory map, a memory address converter (<code>conv</code>) is
added just below the L2 arbiter. Besides CSR modules, all <code>ioaddr</code> modules and
the memory address converter receive PCR updates to track the changes in I/O
and memory maps.</p><h4 id=irq-irq:e2024145d35b2c747c2f5bf628155765>IRQ (<code>irq</code>)</h4><p>All cores share the same interrupt sources but they can enable/disable
individual interrupts separately. When an interrupt arrives, it is forwarded
to all cores who have enabled it.</p><h4 id=soft-reset-soft-reset:e2024145d35b2c747c2f5bf628155765>Soft reset (<code>soft_reset</code>)</h4><p>When a soft reset is triggered (a write to CSR <code>reset</code>), a reset signal is
broadcast to all cores and the L2.</p><h2 id=individual-pcrs:e2024145d35b2c747c2f5bf628155765>Individual PCRs</h2><p>All PCRs are readable or writable in machine mode ONLY.</p><table><thead><tr><th>Name</th><th>Address</th><th>Operation</th><th>Reset value</th><th>Description</th></tr></thead><tbody><tr><td>time</td><td><code>0x701</code></td><td>Read Only</td><td>0</td><td>Global wall clock.</td></tr><tr><td>tohost</td><td><code>0x780</code></td><td>Read/Write</td><td>0</td><td>Legacy, only used in ISA regression test to identify return value.</td></tr><tr><td>fromhost</td><td><code>0x781</code></td><td>Read/Write</td><td>0</td><td>Legacy, not used.</td></tr><tr><td>reset</td><td><code>0x782</code></td><td>Read/Write</td><td>0</td><td>When written, trigger a soft reset. Always reads 0.</td></tr><tr><td>mem_base0</td><td><code>0x7a0</code></td><td>Read/Write</td><td>InitMemBase</td><td>Base address of memory section 0.</td></tr><tr><td>mem_mask0</td><td><code>0x7a1</code></td><td>Read/write</td><td>InitMemMask</td><td>Address mask of memory section 0.</td></tr><tr><td>mem_phy0</td><td><code>0x7a2</code></td><td>Read/Write</td><td>InitPhyBase</td><td>Physical base address of memory section 0.</td></tr><tr><td>mem_base1</td><td><code>0x7a4</code></td><td>Read/Write</td><td>0</td><td>Base address of memory section 1.</td></tr><tr><td>mem_mask1</td><td><code>0x7a5</code></td><td>Read/write</td><td>0</td><td>Address mask of memory section 1.</td></tr><tr><td>mem_phy1</td><td><code>0x7a6</code></td><td>Read/Write</td><td>0</td><td>Physical base address of memory section 1.</td></tr><tr><td>mem_base2</td><td><code>0x7a8</code></td><td>Read/Write</td><td>0</td><td>Base address of memory section 2.</td></tr><tr><td>mem_mask2</td><td><code>0x7a9</code></td><td>Read/write</td><td>0</td><td>Address mask of memory section 2.</td></tr><tr><td>mem_phy2</td><td><code>0x7aa</code></td><td>Read/Write</td><td>0</td><td>Physical base address of memory section 2.</td></tr><tr><td>mem_base3</td><td><code>0x7ac</code></td><td>Read/Write</td><td>0</td><td>Base address of memory section 3.</td></tr><tr><td>mem_mask3</td><td><code>0x7ad</code></td><td>Read/write</td><td>0</td><td>Address mask of memory section 3.</td></tr><tr><td>mem_phy3</td><td><code>0x7ae</code></td><td>Read/Write</td><td>0</td><td>Physical base address of memory section 3.</td></tr><tr><td>mem_update</td><td><code>0x7af</code></td><td>Read/Write</td><td>0</td><td>When written, trigger memory map update. Always reads 0.</td></tr><tr><td>io_base0</td><td><code>0x7b0</code></td><td>Read/Write</td><td>InitIOBase</td><td>Base address of I/O section 0.</td></tr><tr><td>io_mask0</td><td><code>0x7b1</code></td><td>Read/write</td><td>InitIOMask</td><td>Address mask of I/O section 0.</td></tr><tr><td>io_base1</td><td><code>0x7b4</code></td><td>Read/Write</td><td>0</td><td>Base address of I/O section 1.</td></tr><tr><td>io_mask1</td><td><code>0x7b5</code></td><td>Read/write</td><td>0</td><td>Address mask of I/O section 1.</td></tr><tr><td>io_base2</td><td><code>0x7b8</code></td><td>Read/Write</td><td>0</td><td>Base address of I/O section 2.</td></tr><tr><td>io_mask2</td><td><code>0x7b9</code></td><td>Read/write</td><td>0</td><td>Address mask of I/O section 2.</td></tr><tr><td>io_base3</td><td><code>0x7bc</code></td><td>Read/Write</td><td>0</td><td>Base address of I/O section 3.</td></tr><tr><td>io_mask3</td><td><code>0x7bd</code></td><td>Read/write</td><td>0</td><td>Address mask of I/O section 3.</td></tr><tr><td>io_update</td><td><code>0x7bf</code></td><td>Read/Write</td><td>0</td><td>When written, trigger I/O map update. Always reads 0.</td></tr><tr><td>int_en0</td><td><code>0x7c0</code></td><td>Read/Write</td><td>0</td><td>IRQ enable for core 0.</td></tr><tr><td>int_pending0</td><td><code>0x7c1</code></td><td>Read Only</td><td>N/A</td><td>Pending IRQ for core 0.</td></tr><tr><td>int_en1</td><td><code>0x7c2</code></td><td>Read/Write</td><td>0</td><td>IRQ enable for core 1.</td></tr><tr><td>int_pending1</td><td><code>0x7c3</code></td><td>Read Only</td><td>N/A</td><td>Pending IRQ for core 1.</td></tr><tr><td>int_en2</td><td><code>0x7c4</code></td><td>Read/Write</td><td>0</td><td>IRQ enable for core 2.</td></tr><tr><td>int_pending2</td><td><code>0x7c5</code></td><td>Read Only</td><td>N/A</td><td>Pending IRQ for core 2.</td></tr><tr><td>int_en3</td><td><code>0x7c6</code></td><td>Read/Write</td><td>0</td><td>IRQ enable for core 3.</td></tr><tr><td>int_pending3</td><td><code>0x7c7</code></td><td>Read Only</td><td>N/A</td><td>Pending IRQ for core 3.</td></tr><tr><td>int_en4</td><td><code>0x7c8</code></td><td>Read/Write</td><td>0</td><td>IRQ enable for core 4.</td></tr><tr><td>int_pending4</td><td><code>0x7c9</code></td><td>Read Only</td><td>N/A</td><td>Pending IRQ for core 4.</td></tr><tr><td>int_en5</td><td><code>0x7ca</code></td><td>Read/Write</td><td>0</td><td>IRQ enable for core 5.</td></tr><tr><td>int_pending5</td><td><code>0x7cb</code></td><td>Read Only</td><td>N/A</td><td>Pending IRQ for core 5.</td></tr><tr><td>int_en6</td><td><code>0x7cc</code></td><td>Read/Write</td><td>0</td><td>IRQ enable for core 6.</td></tr><tr><td>int_pending6</td><td><code>0x7cd</code></td><td>Read Only</td><td>N/A</td><td>Pending IRQ for core 6.</td></tr><tr><td>int_en7</td><td><code>0x7ce</code></td><td>Read/Write</td><td>0</td><td>IRQ enable for core 7.</td></tr><tr><td>int_pending7</td><td><code>0x7cf</code></td><td>Read Only</td><td>N/A</td><td>Pending IRQ for core 7.</td></tr></tbody></table><h2 id=time:e2024145d35b2c747c2f5bf628155765>Time</h2><p>The current wall clock counts at 50MHz. The value of this wall clock is updated to all cores every 20 cycles. The wall clock is not writable.</p><p>When a core reads the CSR <code>time</code>, an actual read of the wall clock is
initiated. However, the timer comparator in each core is compared against the
infrequently updated local copy, which incurs a 20 cycle inaccuracy in the
worst case.</p><h2 id=to-from-host:e2024145d35b2c747c2f5bf628155765>To/from host</h2><p>This pair of registers are kept for legacy reasons. They are used in the ISA regression test only for identifying the end of a test and the return value. Writing <code>tohost</code> has no effect in FPGA but writing a non-zero value to <code>fromhost</code> triggers an exception.</p><h2 id=reset:e2024145d35b2c747c2f5bf628155765>Reset</h2><p>Writing any value to <code>reset</code> triggers a soft reset.</p><h2 id=memory-map:e2024145d35b2c747c2f5bf628155765>Memory map</h2><p>This implementation supports up to 4 separate memory sections. The space of
any two sections should not overlap.</p><p>For each section, <code>mem_base</code> defines the base address as seen by the core;
<code>mem_mask</code> defines the actual size of the section; <code>mem_phy</code> defines the base
address as seen by on-chip interconnects. When <code>mem_mask</code> is 0, the section is
disabled (size of 0). For any address (<code>addr</code>), it belongs to a memory section
if <code>(addr &amp; ~mem_mask) == mem_base</code>. The translated address to on-chip
interconnects is <code>(addr &amp; mem_mask) | mem_phy</code>.</p><p>The update of a memory section should be an atomic operation. To ease this requirement, any write to a memory map is buffered. The actual update to the memory map is triggered by a write to <code>mem_update</code>.</p><h2 id=i-o-map:e2024145d35b2c747c2f5bf628155765>I/O map</h2><p>This implementation supports up to 4 separate I/O sections. The space of any
two sections should not overlap.</p><p>For each section, <code>io_base</code> defines the base address; <code>io_mask</code> defines the actual size of the section. When <code>io_mask</code> is 0, the section is disabled (size of 0). For any address (<code>addr</code>), it belongs to an I/O section if <code>(addr &amp; ~io_mask) == io_base</code>. There is no address translation for I/O addresses.</p><p>Similar to the memory map, the update of an I/O section should be an atomic operation. In the same way, any write to I/O map is buffered. The actual update is triggered by a write to <code>io_update</code>.</p><h2 id=irqs:e2024145d35b2c747c2f5bf628155765>IRQs</h2><p>Up to 64 interrupt sources are supported.</p><p>Every core has two PCRs: <code>int_en</code> and <code>int_pending</code>. <code>int_en</code> defines which IRQ should be notified to the core, while <code>int_pending</code> identifies any pending IRQs. The actual interrupt sources are latched in the PCR control unit. The value of <code>int_pending</code> is generated by <code>int_pending = interrupt &amp; int_en</code>.</p><p>When an IRQ is triggered, the responding core can find out the actual IRQ source by reading <code>int_pending</code>. Currently the responding core needs to access the actual peripheral to resolve a pending IRQ.</p><p>In this implementation, interrupt bit 0 is connected to UART and bit 1 is connected to SPI.</p></div></main><footer class=lr-footer><div class=container><div class=row><div class="col-lg-2 d-none d-lg-block"><img src=/img/logo/logo-dualcolor.svg width=150px></div><div class=col><p><small>The text content on this website is licensed under a <a href=https://creativecommons.org/licenses/by/4.0/>Creative Commons Attribution 4.0 International License</a>, except where otherwise noted. No license is granted for logos or other trademarks. Other content &copy; lowRISC Contributors.</small></p><p><small><a href=/privacy-policy>Privacy and cookies policy</a>
&middot; <a href=/usage-licence>Usage licence</a></small></p></div><div class=col-lg-2><p><a href=#>Back to top</a></p></div></div></div></footer><script src=/main.b0a63.js></script></body></html>