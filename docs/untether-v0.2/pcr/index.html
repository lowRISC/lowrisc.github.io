<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
        
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

        <title>Memory and I/O maps, soft reset, and interrupts &middot; lowRISC</title>
        <link rel='stylesheet' href='http://fonts.googleapis.com/css?family=Open+Sans:400,300,600' type='text/css'>
        <link rel="stylesheet" href="http://www.lowrisc.org//libraries/normalize.3.0.1.css" />
        <link rel="stylesheet" href="http://www.lowrisc.org//css/liquorice.css" />
        <link rel="shortcut icon" href="http://www.lowrisc.org//favicon.ico" />
        <link rel="alternate" href="http://www.lowrisc.org//index.xml" type="application/rss+xml" title="lowRISC" />
        <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-53520714-1', 'auto');
        ga('send', 'pageview');
      </script>
  </head>
    <body class="li-body">

<header class="li-page-header">
  <div class="li-header-top">
  </div>
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <div class="li-brand li-left">
                
                <a href="http://www.lowrisc.org/"><img src="http://www.lowrisc.org//img/lowrisc_header_logo.png"/></a></div>
                <div class="li-menu li-left">
                    <span class="li-menu-icon" onclick="javascript:toggle('menu');">&#9776;</span>
                    <ul id="menu2" class="li-menu-items">
                        
                            <li><a href="/"> Home </a></li>
                        
                            <li><a href="/about/"> About </a></li>
                        
                            <li><a href="/faq/"> FAQ </a></li>
                        
                            <li><a href="/docs/"> Docs </a></li>
                        
                            <li><a href="/community/"> Community </a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="sixteen columns">
                <ul id="menu" class="li-menu-items li-menu-mobile">
                    
                        <li><a href="/"> Home </a></li>
                    
                        <li><a href="/about/"> About </a></li>
                    
                        <li><a href="/faq/"> FAQ </a></li>
                    
                        <li><a href="/docs/"> Docs </a></li>
                    
                        <li><a href="/community/"> Community </a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</header>









    <div class="container">
        <div class="row">
            <div class="sixteen columns">
                <article class="li-article">
                
                    <header class="li-article-header">
                        <h1 class="li-article-title">Memory and I/O maps, soft reset, and interrupts</h1>
                        <span class="li-article-taxonomies">
                            

                            
                        </span>
                        
                        
                    </header>
                    <section>
                        

<p><strong>Note: the content of this section is subject to change as the specification develops.</strong></p>

<p>This <code>untethered</code> release starts to regulate the shared resources among cores, such as interrupts, memory and I/O maps, global timers, etc. A subset of control status register (CSR) space is defined as processor control registers (PCRs), whose values and accesses are shared by all cores and controlled by a global PCR control unit (<code>PCRControl</code>). The connections of the PCR control units is shown below.</p>

<p><img src="../figures/pcr_ctl.png" alt="Drawing" style="width: 450px;"/></p>

<h2 id="ports-of-pcrcontrol:b09078dfce21ca0f6aa6d6ada91ffb50">Ports of <code>PCRControl</code></h2>

<h4 id="pcr-read-write-requests-pcr-req:b09078dfce21ca0f6aa6d6ada91ffb50">PCR read/write requests (<code>pcr_req</code>)</h4>

<p>The CSR file in each core has a dedicated request channel to the global PCR control unit. When a CSR address is identified as a PCR, the CSR request is forwarded to <code>PCRControl</code>.</p>

<h4 id="pcr-read-write-response-pcr-resp:b09078dfce21ca0f6aa6d6ada91ffb50">PCR read/write response (<code>pcr_resp</code>)</h4>

<p>Upon receiving a request from <code>pcr_req</code>, the PCR control unit processes the
request and sends back a response through the <code>pcr_resp</code> port connected to the
requesting core when it is finished. When it is a read request, the PCR value
is sent back in the response.</p>

<h4 id="broadcast-of-pcr-update-pcr-update:b09078dfce21ca0f6aa6d6ada91ffb50">Broadcast of PCR update (<code>pcr_update</code>)</h4>

<p>Operations on some PCRs trigger changes of the global status, such as changing
the I/O map. In this case, the updated PCR is broadcast to all components
potentially affected by this change. In this implementation, every L1 D$ has
an <code>ioaddr</code> module for identifying I/O requests. To enforce the address
mapping defined in the memory map, a memory address converter (<code>conv</code>) is
added just below the L2 arbiter. Besides CSR modules, all <code>ioaddr</code> modules and
the memory address converter receive PCR updates to track the changes in I/O
and memory maps.</p>

<h4 id="irq-irq:b09078dfce21ca0f6aa6d6ada91ffb50">IRQ (<code>irq</code>)</h4>

<p>All cores share the same interrupt sources but they can enable/disable
individual interrupts separately. When an interrupt arrives, it is forwarded
to all cores who have enabled it.</p>

<h4 id="soft-reset-soft-reset:b09078dfce21ca0f6aa6d6ada91ffb50">Soft reset (<code>soft_reset</code>)</h4>

<p>When a soft reset is triggered (a write to CSR <code>reset</code>), a reset signal is
broadcast to all cores and the L2.</p>

<h2 id="individual-pcrs:b09078dfce21ca0f6aa6d6ada91ffb50">Individual PCRs</h2>

<p>All PCRs are readable or writable in machine mode ONLY.</p>

<table>
<thead>
<tr>
<th>Name</th>
<th>Address</th>
<th>Operation</th>
<th>Reset value</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>time</td>
<td><code>0x701</code></td>
<td>Read Only</td>
<td>0</td>
<td>Global wall clock.</td>
</tr>

<tr>
<td>tohost</td>
<td><code>0x780</code></td>
<td>Read/Write</td>
<td>0</td>
<td>Legacy, only used in ISA regression test to identify return value.</td>
</tr>

<tr>
<td>fromhost</td>
<td><code>0x781</code></td>
<td>Read/Write</td>
<td>0</td>
<td>Legacy, not used.</td>
</tr>

<tr>
<td>reset</td>
<td><code>0x782</code></td>
<td>Read/Write</td>
<td>0</td>
<td>When written, trigger a soft reset. Always reads 0.</td>
</tr>

<tr>
<td>mem_base0</td>
<td><code>0x7a0</code></td>
<td>Read/Write</td>
<td>InitMemBase</td>
<td>Base address of memory section 0.</td>
</tr>

<tr>
<td>mem_mask0</td>
<td><code>0x7a1</code></td>
<td>Read/write</td>
<td>InitMemMask</td>
<td>Address mask of memory section 0.</td>
</tr>

<tr>
<td>mem_phy0</td>
<td><code>0x7a2</code></td>
<td>Read/Write</td>
<td>InitPhyBase</td>
<td>Physical base address of memory section 0.</td>
</tr>

<tr>
<td>mem_base1</td>
<td><code>0x7a4</code></td>
<td>Read/Write</td>
<td>0</td>
<td>Base address of memory section 1.</td>
</tr>

<tr>
<td>mem_mask1</td>
<td><code>0x7a5</code></td>
<td>Read/write</td>
<td>0</td>
<td>Address mask of memory section 1.</td>
</tr>

<tr>
<td>mem_phy1</td>
<td><code>0x7a6</code></td>
<td>Read/Write</td>
<td>0</td>
<td>Physical base address of memory section 1.</td>
</tr>

<tr>
<td>mem_base2</td>
<td><code>0x7a8</code></td>
<td>Read/Write</td>
<td>0</td>
<td>Base address of memory section 2.</td>
</tr>

<tr>
<td>mem_mask2</td>
<td><code>0x7a9</code></td>
<td>Read/write</td>
<td>0</td>
<td>Address mask of memory section 2.</td>
</tr>

<tr>
<td>mem_phy2</td>
<td><code>0x7aa</code></td>
<td>Read/Write</td>
<td>0</td>
<td>Physical base address of memory section 2.</td>
</tr>

<tr>
<td>mem_base3</td>
<td><code>0x7ac</code></td>
<td>Read/Write</td>
<td>0</td>
<td>Base address of memory section 3.</td>
</tr>

<tr>
<td>mem_mask3</td>
<td><code>0x7ad</code></td>
<td>Read/write</td>
<td>0</td>
<td>Address mask of memory section 3.</td>
</tr>

<tr>
<td>mem_phy3</td>
<td><code>0x7ae</code></td>
<td>Read/Write</td>
<td>0</td>
<td>Physical base address of memory section 3.</td>
</tr>

<tr>
<td>mem_update</td>
<td><code>0x7af</code></td>
<td>Read/Write</td>
<td>0</td>
<td>When written, trigger memory map update. Always reads 0.</td>
</tr>

<tr>
<td>io_base0</td>
<td><code>0x7b0</code></td>
<td>Read/Write</td>
<td>InitIOBase</td>
<td>Base address of I/O section 0.</td>
</tr>

<tr>
<td>io_mask0</td>
<td><code>0x7b1</code></td>
<td>Read/write</td>
<td>InitIOMask</td>
<td>Address mask of I/O section 0.</td>
</tr>

<tr>
<td>io_base1</td>
<td><code>0x7b4</code></td>
<td>Read/Write</td>
<td>0</td>
<td>Base address of I/O section 1.</td>
</tr>

<tr>
<td>io_mask1</td>
<td><code>0x7b5</code></td>
<td>Read/write</td>
<td>0</td>
<td>Address mask of I/O section 1.</td>
</tr>

<tr>
<td>io_base2</td>
<td><code>0x7b8</code></td>
<td>Read/Write</td>
<td>0</td>
<td>Base address of I/O section 2.</td>
</tr>

<tr>
<td>io_mask2</td>
<td><code>0x7b9</code></td>
<td>Read/write</td>
<td>0</td>
<td>Address mask of I/O section 2.</td>
</tr>

<tr>
<td>io_base3</td>
<td><code>0x7bc</code></td>
<td>Read/Write</td>
<td>0</td>
<td>Base address of I/O section 3.</td>
</tr>

<tr>
<td>io_mask3</td>
<td><code>0x7bd</code></td>
<td>Read/write</td>
<td>0</td>
<td>Address mask of I/O section 3.</td>
</tr>

<tr>
<td>io_update</td>
<td><code>0x7bf</code></td>
<td>Read/Write</td>
<td>0</td>
<td>When written, trigger I/O map update. Always reads 0.</td>
</tr>

<tr>
<td>int_en0</td>
<td><code>0x7c0</code></td>
<td>Read/Write</td>
<td>0</td>
<td>IRQ enable for core 0.</td>
</tr>

<tr>
<td>int_pending0</td>
<td><code>0x7c1</code></td>
<td>Read Only</td>
<td>N/A</td>
<td>Pending IRQ for core 0.</td>
</tr>

<tr>
<td>int_en1</td>
<td><code>0x7c2</code></td>
<td>Read/Write</td>
<td>0</td>
<td>IRQ enable for core 1.</td>
</tr>

<tr>
<td>int_pending1</td>
<td><code>0x7c3</code></td>
<td>Read Only</td>
<td>N/A</td>
<td>Pending IRQ for core 1.</td>
</tr>

<tr>
<td>int_en2</td>
<td><code>0x7c4</code></td>
<td>Read/Write</td>
<td>0</td>
<td>IRQ enable for core 2.</td>
</tr>

<tr>
<td>int_pending2</td>
<td><code>0x7c5</code></td>
<td>Read Only</td>
<td>N/A</td>
<td>Pending IRQ for core 2.</td>
</tr>

<tr>
<td>int_en3</td>
<td><code>0x7c6</code></td>
<td>Read/Write</td>
<td>0</td>
<td>IRQ enable for core 3.</td>
</tr>

<tr>
<td>int_pending3</td>
<td><code>0x7c7</code></td>
<td>Read Only</td>
<td>N/A</td>
<td>Pending IRQ for core 3.</td>
</tr>

<tr>
<td>int_en4</td>
<td><code>0x7c8</code></td>
<td>Read/Write</td>
<td>0</td>
<td>IRQ enable for core 4.</td>
</tr>

<tr>
<td>int_pending4</td>
<td><code>0x7c9</code></td>
<td>Read Only</td>
<td>N/A</td>
<td>Pending IRQ for core 4.</td>
</tr>

<tr>
<td>int_en5</td>
<td><code>0x7ca</code></td>
<td>Read/Write</td>
<td>0</td>
<td>IRQ enable for core 5.</td>
</tr>

<tr>
<td>int_pending5</td>
<td><code>0x7cb</code></td>
<td>Read Only</td>
<td>N/A</td>
<td>Pending IRQ for core 5.</td>
</tr>

<tr>
<td>int_en6</td>
<td><code>0x7cc</code></td>
<td>Read/Write</td>
<td>0</td>
<td>IRQ enable for core 6.</td>
</tr>

<tr>
<td>int_pending6</td>
<td><code>0x7cd</code></td>
<td>Read Only</td>
<td>N/A</td>
<td>Pending IRQ for core 6.</td>
</tr>

<tr>
<td>int_en7</td>
<td><code>0x7ce</code></td>
<td>Read/Write</td>
<td>0</td>
<td>IRQ enable for core 7.</td>
</tr>

<tr>
<td>int_pending7</td>
<td><code>0x7cf</code></td>
<td>Read Only</td>
<td>N/A</td>
<td>Pending IRQ for core 7.</td>
</tr>
</tbody>
</table>

<h2 id="time:b09078dfce21ca0f6aa6d6ada91ffb50">Time</h2>

<p>The current wall clock counts at 50MHz. The value of this wall clock is updated to all cores every 20 cycles. The wall clock is not writable.</p>

<p>When a core reads the CSR <code>time</code>, an actual read of the wall clock is
initiated.  However, the timer comparator in each core is compared against the
infrequently updated local copy, which incurs a 20 cycle inaccuracy in the
worst case.</p>

<h2 id="to-from-host:b09078dfce21ca0f6aa6d6ada91ffb50">To/from host</h2>

<p>This pair of registers are kept for legacy reasons. They are used in the ISA regression test only for identifying the end of a test and the return value. Writing <code>tohost</code> has no effect in FPGA but writing a non-zero value to <code>fromhost</code> triggers an exception.</p>

<h2 id="reset:b09078dfce21ca0f6aa6d6ada91ffb50">Reset</h2>

<p>Writing any value to <code>reset</code> triggers a soft reset.</p>

<h2 id="memory-map:b09078dfce21ca0f6aa6d6ada91ffb50">Memory map</h2>

<p>This implementation supports up to 4 separate memory sections. The space of
any two sections should not overlap.</p>

<p>For each section, <code>mem_base</code> defines the base address as seen by the core;
<code>mem_mask</code> defines the actual size of the section; <code>mem_phy</code> defines the base
address as seen by on-chip interconnects. When <code>mem_mask</code> is 0, the section is
disabled (size of 0). For any address (<code>addr</code>), it belongs to a memory section
if <code>(addr &amp; ~mem_mask) == mem_base</code>. The translated address to on-chip
interconnects is <code>(addr &amp; mem_mask) | mem_phy</code>.</p>

<p>The update of a memory section should be an atomic operation. To ease this requirement, any write to a memory map is buffered. The actual update to the memory map is triggered by a write to <code>mem_update</code>.</p>

<h2 id="i-o-map:b09078dfce21ca0f6aa6d6ada91ffb50">I/O map</h2>

<p>This implementation supports up to 4 separate I/O sections. The space of any
two sections should not overlap.</p>

<p>For each section, <code>io_base</code> defines the base address; <code>io_mask</code> defines the actual size of the section. When <code>io_mask</code> is 0, the section is disabled (size of 0). For any address (<code>addr</code>), it belongs to an I/O section if <code>(addr &amp; ~io_mask) == io_base</code>. There is no address translation for I/O addresses.</p>

<p>Similar to the memory map, the update of an I/O section should be an atomic operation. In the same way, any write to I/O map is buffered. The actual update is triggered by a write to <code>io_update</code>.</p>

<h2 id="irqs:b09078dfce21ca0f6aa6d6ada91ffb50">IRQs</h2>

<p>Up to 64 interrupt sources are supported.</p>

<p>Every core has two PCRs: <code>int_en</code> and <code>int_pending</code>. <code>int_en</code> defines which IRQ should be notified to the core, while <code>int_pending</code> identifies any pending IRQs. The actual interrupt sources are latched in the PCR control unit. The value of <code>int_pending</code> is generated by <code>int_pending = interrupt &amp; int_en</code>.</p>

<p>When an IRQ is triggered, the responding core can find out the actual IRQ source by reading <code>int_pending</code>. Currently the responding core needs to access the actual peripheral to resolve a pending IRQ.</p>

<p>In this implementation, interrupt bit 0 is connected to UART and bit 1 is connected to SPI.</p>

                    </section>
                </article>

        </div>
    </div>
    
    <div class="row li-pagination">
      <div class="eight columns">
        <div class="li-pagination-previous">
          &nbsp;
          
        </div>
      </div>
      <div class="eight columns">
        <div class="li-pagination-next">
          &nbsp;
          
        </div>
      </div>
    </div>
    


                

            <div id="disqus_thread"></div>
            <script type="text/javascript">
                 
                var disqus_shortname = 'lowrisc'; 
                var disqus_identifier = "/" + "docs/untether-v0.2/pcr";
                var disqus_title = "Memory and I/O maps, soft reset, and interrupts";
                var disqus_url = "http://www.lowrisc.org" + "docs/untether-v0.2/pcr";

                 
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
            </div>
            

<footer class="li-page-footer">
    <div class="container">
        <div class="row">
            <div class="sixteen columns">
            </div>
        </div>
    </div>
</footer>

    <script type="text/javascript">
    function toggle(id) {
        var e = document.getElementById(id);
        e.style.display == 'block' ? e.style.display = 'none' : e.style.display = 'block';
    }
    </script>
    </body>
</html>

