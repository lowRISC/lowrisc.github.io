<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><base href=https://www.lowrisc.org><link rel=icon type=image/png sizes=32x32 href=/favicon.png><title>GSoC 2017 student report: Core lockstep for minion cores &middot; lowRISC: Collaborative open silicon engineering</title><link href=/main.f5831.css rel=stylesheet></head><body><header><nav class="navbar navbar-expand-md navbar-light"><div class=container><a class=navbar-brand href=#><img src=/img/logo/logo-dualcolor.svg alt=lowRISC></a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarCollapse aria-controls=navbarCollapse aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarCollapse><ul class="navbar-nav ml-auto"><li class=nav-item><a href=/our-work class=nav-link>Our work</a></li><li class=nav-item><a href=/open-silicon class=nav-link>Open Silicon</a></li><li class=nav-item><a href=/community class=nav-link>Community</a></li><li class=nav-item><a href=/blog class=nav-link>Blog</a></li><li class=nav-item><a href=/jobs class=nav-link>Jobs</a></li><li class=nav-item><a href=/about class=nav-link>About us</a></li><li class=nav-item><a class="btn lr-navbar-btn-gh" href=https://github.com/lowrisc>GitHub</a></li></ul></div></div></nav></header><main role=main><div class=container><h1>GSoC 2017 student report: Core lockstep for minion cores</h1><p><em>Nikitas Chronas</em></p><h2 id=introduction:77614929e15065dd7aa41233ec798d25>Introduction</h2><p>The upgraded role of <a href=https://en.wikipedia.org/wiki/CubeSat>CubeSats</a>, fueled
by technological advances and lowered launch costs in the aerospace industry,
has opened access to space for a wider audience. Space is a harsh environment
for microelectronics - radiation induced Single Event Upsets can trigger bit
flips in memory that could have catastrophic consequences, rendering a CubeSat
useless. The two main options for fault tolerance are to either select from a
limited range of expensive Rad-Hard electronics or to use Commercial
Off-The-Shelf electronics that offer little protection. This project modifies
the minion core subsystem lowRISC SoC, employing the
<a href=https://en.wikipedia.org/wiki/Lockstep_(computing)>Core Lock Step</a> (CLS)
fault tolerant technique by integrating a CLS assist unit in order to be
suitable for use in a CubeSat mission.</p><h2 id=work-summary:77614929e15065dd7aa41233ec798d25>Work summary</h2><p>Here is a short summary of the work that was completed during the <a href=https://developers.google.com/open-source/gsoc/>Google
Summer of Code</a> (GSoC) 2017,
along with the repository branches.</p><p>I ported the minion subsystem to work with the
<a href=https://www.veripool.org/wiki/verilator>Verilator</a> simulator, and with
Digilent&rsquo;s inexpensive
<a href=https://reference.digilentinc.com/reference/programmable-logic/arty/start>Arty</a>
FPGA board, then created a simple C program that would run in the above. The
<a href=https://github.com/nchronas/minion_subsystem/tree/minion_minimal>minion_minimal</a>
has the C example. These ports are available in the
<a href=https://github.com/nchronas/minion_subsystem/tree/arty_2>arty</a> and
<a href=https://github.com/nchronas/minion_subsystem/tree/verilator>verilator</a>
branches, and have been submitted for merging in to the master branch. The
<a href=https://github.com/nchronas/minion_subsystem/tree/jinja_gen>jinja_generation</a>
branch contains the code generation project described later in this document.</p><p>During the Core Lock Step implementation, I identified and made some
improvements in the SoC codebase. The
<a href=https://github.com/nchronas/minion_subsystem/tree/coremem_cleanup>coremem_cleanup</a>
branch was merged upstream, and improves the coremem module by removing
unreached states in the code and removing duplicate code. The
<a href=https://github.com/nchronas/minion_subsystem/tree/minion_peripherals>minion_peripherals</a>
branch is an attempt to clean up and improve clarity for the SoC&rsquo;s custom bus,
but has yet to be merged.</p><p>The
<a href=https://github.com/lowRISC/minion_subsystem/tree/core-lockstep-codegen>core-lockstep-codegen</a>
branch contains the majority of the work from over the summer in a form
readyto be used. It includes the <code>minion_minimal</code>, arty, verilator, core lock
step and code generation work. Different variations of the SoC can be
generated based on included configs.</p><p>The
<a href=https://github.com/lowRISC/minion_subsystem/tree/core-lockstep>core-lockstep</a>
branch contains a core lock step configuration that could be used with an
otherwise unmodified version of the minion core subsystem. It was primary
developed as a showcase for the code.</p><p>The following repositories contain early versions of the previous designs and
are only included for reference.
<a href=https://github.com/nchronas/minion_subsystem/tree/minion_verilator>minion_verilator</a>
contains the first versions for the Arty and Verilator ports as well as
assembly and C example programs. Forked from the minion verilator branch, the
<a href=https://github.com/nchronas/minion_subsystem/tree/minion_CLS>minion_CLS</a> has
the first prototypes of the CLS configuration.</p><h2 id=setting-up-the-environment:77614929e15065dd7aa41233ec798d25>Setting up the environment</h2><p>All the work was done in a virtual machine based on ubuntu 16.04 LTS and a
Vivado 2015.4 64bit install with Free webPACK licence. The project uses the
programs reccomended by other lowRISC documentation. I had some issues while
installing all programs but it wasn’t anything that wasn&rsquo;t easily resolved.
More information can be found
<a href=https://www.lowrisc.org/docs/minion-v0.4/environment/>here</a>.</p><h3 id=verilator:77614929e15065dd7aa41233ec798d25>Verilator</h3><p>Verilator was installed based on these
<a href=https://www.veripool.org/projects/verilator/wiki/Installing>instructions</a>,
as recommended by the lowRISC
<a href=https://www.lowrisc.org/docs/untether-v0.2/verilator/>documentation</a>. I used
GTKWave for viewing the waveforms generated from verilator, installed using
<code>apt-get</code>. Verilator needed the following environment variables in order to
run:</p><pre><code>export PATH=$PATH:$VERILATOR_ROOT/bin
export VERILATOR_ROOT=/path_to_folder/verilator
</code></pre><h3 id=vivado:77614929e15065dd7aa41233ec798d25>Vivado</h3><p>A guide about installing Vivado can be found in lowRISC documentation. One
difference from that guide is that in my installation that I used the
following command <code>source
/local/tool/Xilinx/Vivado/2015.4/.settings64-Vivado.sh</code>. It&rsquo;s generally a
pretty straightforward installation but took a while to finish.</p><h3 id=arty:77614929e15065dd7aa41233ec798d25>Arty</h3><p>While this is not needed in order to run the project, I think it might be
helpful. In order to use the Arty board in Vivado for a new project, this
<a href=https://reference.digilentinc.com/learn/software/tutorials/vivado-board-files/start>guide</a>
should be followed.</p><h3 id=compiler:77614929e15065dd7aa41233ec798d25>Compiler</h3><p>The PULPino-derived minion core uses a patched GCC compiler, found
<a href=https://github.com/pulp-platform/ri5cy_gnu_toolchain>here</a>. The repository
has sufficient instructions. You could either create a symlink in <code>/usr/bin</code>
or add an appropriate directoy to your <code>$PATH</code>.</p><h3 id=minion-soc:77614929e15065dd7aa41233ec798d25>Minion SoC</h3><p>The code for the minion SoC can be found in the lowRISC minion subsystem
<a href=https://github.com/lowRISC/minion_subsystem>repository</a>. The branch that all
my work is derived from is the minion-v0.4. Clone either the lowRISC
repository or my <a href=https://github.com/nchronas/minion_subsystem>fork</a>. For
cloning the repository, git should be installed.</p><p>In order to compile software for the minion SoC, the romgen program must be
compiled. romgen uses OCaml, so it has to be installed in the system in order
to compile it (install using <code>apt-get install ocaml</code>).</p><h3 id=code-generation:77614929e15065dd7aa41233ec798d25>Code generation</h3><p>The code generation project uses python 2.7 and the jinja2 templating engine.
Jinja is installed by simply running (sudo) <code>pip install jinja2</code>.</p><h2 id=running-the-examples:77614929e15065dd7aa41233ec798d25>Running the examples</h2><iframe src=https://giphy.com/embed/l378u8meC0uNts7HG width=480 height=334 frameborder=0 class=giphy-embed allowfullscreen></iframe><p><em>Arty example program</em></p><p>After preparing the environment, the following steps are required to run the
examples:</p><ol><li>First we must select the correct code. Go the <code>minion_subsystem</code> folder and
switch to the core-lockstep-codegen branch using <code>git checkout
core-lockstep-codegen</code></li><li>The generator will produce the files needed depending on the config used.
Go to the <code>socgen</code> folder and run <code>python generator.py config</code>. In the place
of config select the predefined configs found in the conf folder or make a
custom. Note that the argument in the generator should have the conf folder as
well. E.g. <code>python generator.py conf/cls_config.json</code>. There are 4
configuration files found in the folder, please select the one you like.<ol><li>The <code>minion_config</code> file has the parameters for generating the
equivalent of the minion-v0.4. This config can’&rsquo; be used with verilator.</li><li>At the moment the verilator can only be used with the GPIO and UART
peripherals. This <code>verilator_config</code> file generates a minion SoC for use
in verilator.</li><li>The <code>cls_config</code> generates the SoC with core lock step and identical
configuration with the minion-v0.4. Again this config can&rsquo;t be used with
verilator.</li><li>The <code>cls_finj_config</code> file generates the SoC with fault injection
functionality, used in testing.</li></ol></li><li>We now compile the examples running in the minion SoC. The examples are in
the <code>software/minimal</code> and <code>software/minimal_cls</code> folder. Compile the minimal
C and minimal C CLS examples by running make inside each folder. If everything
works ok, the <code>code.v</code> and <code>data.v</code> files should have been created.</li><li>For running verilator, the following steps are required.<ol><li>This step is not necessary but it will make simulation a lot quicker by
shortening the delay time. Replace <code>REAL_DELAY</code> with <code>SIM_DELAY</code> found in
the delay function in the minion.c file and recompile the software.</li><li>Next the verilator simulator is compiled. Go to the vsim folder and run
<code>make</code> to simulate the minion SoC without CLS. Running <code>make cls</code> will
produce the simulation for the CLS configuration and finally <code>make finj</code>
will be used for CLS with fault injection. Note that the configuration has
to match the <code>make</code> command used. e.g. configuring the SoC without CLS
while compiling verilator with cLS will result in an error.</li><li>Start the simulation by running <code>./run_sim.sh.</code> If the configuration is
&ldquo;finj&rdquo; the simulation will provide a simple menu for triggering the fault
injection. Stop the simulation by using ctrl+c.</li><li>You can view the waveforms generated from the simulation by running
<code>gtkwave obj_dir/verilated.vcd</code></li></ol></li><li>For uploading the program to the FPGA, follow these steps:<ol><li>Start vivado and select the project found in
<code>vivado/minion_top_arty.xpr</code>.</li><li>Some Xilinx IPs are not included in repository and the user would have
to create them.<ol><li>If the minion SoC configuration has the SD peripheral, you will
need to create the clock wizard. The necessary information for
generating the IP are found in the port section.</li><li>If fault injection with the vio parameter is used, the VIO module
should be created with the following parameters: <code>name: vio0</code> and one
output port with 1 bit width.</li></ol></li><li>Select the software (<code>minimal</code> vs <code>minimal_cls</code> you want to run on the
SoC by changing the <code>code.v</code> and <code>data.v</code> files.</li><li>Select the Generate bitstream command in Vivado. Note that this process
might take a while (~10 minutes in my computer).</li><li>For uploading the bitstream to the Arty you have 2 options: either
upload it through JTAG or store it in the onboard flash memory. For
details on how to do this, see the guide from Digilent
<a href=https://reference.digilentinc.com/learn/programmable-logic/tutorials/arty-programming-guide/start>guide</a>
(after step 2.8).</li></ol></li><li>Enjoy!</li></ol><p>A note for Vivado and Arty: programming the FPGA in the virtual machine was
sometimes unstable. When there was an issue I simply restarted the virtual
machine.</p><iframe src=https://giphy.com/embed/26vIg6cZFMWvi6AbS width=480 height=401 frameborder=0 class=giphy-embed allowfullscreen></iframe><h2 id=minion-soc-1:77614929e15065dd7aa41233ec798d25>Minion SoC</h2><p>This section contains information for understanding the minion SoC. An
<a href=https://www.lowrisc.org/docs/minion-v0.4/overview/>overview</a> on how the
minion connects with the rocket core and some complementary
<a href=https://www.lowrisc.org/docs/minion-v0.4/minion/>information</a> about the SoC
can be found in the lowRISC documentation.</p><h3 id=project-structure:77614929e15065dd7aa41233ec798d25>Project structure</h3><p>The <code>minion_subsystem</code> has the following directory structure: <code>software</code> holds
the software for the minion. The <code>pulpino</code> folder has all the HDL files for
the PULPino core. The <code>verilog</code> folder contains additional verilog code used
from the minion subsystem. The <code>vivado</code> has all the related files that are
used from the Vivado suite. The <code>romgen</code> folder has the code for the rom
generation software. The project uses OCaml and takes the binaries generated
from the C compiler then incorporates them in to verilog files in a form that
can be used from the tools.</p><p>In the <code>software</code> folder, the <code>hello</code> project will output a message through
the UART but unfortunately currently doesn’t generate the <code>code.v</code> and
<code>data.v</code> files for use in a FPGA. The bootstrap project has all the
functionality, used from the Rocket core and the lowRISC SoC.</p><p>One of the most important files is <code>minion_soc.sv</code>. It has all the code for
integrating the core with the RAM/ROM and the peripherals, thus creating the
SoC.</p><p>The CLS code generation branch has some extra folders. The <code>socgen</code> folder is
for the code generation project. The software has the <code>minimal</code> C and
<code>minimal_cls</code> C projects and finally the vsim folder has the all the files for
the verilator.</p><h3 id=core:77614929e15065dd7aa41233ec798d25>Core</h3><p>The core is a modified PULPino core, which might be compared to the ARM
Cortex-M4. The upstream PULPino uses an AXI bus to communicate with the
memories and peripherals as opposed to the minion SoC has a custom tightly
coupled bus. Moreover the minion doesn&rsquo;t support yet a debug interface. For
more information about the core you can check the
<a href=http://pulp-platform.org/>PULP-platform</a> site.</p><p>The core has a separate instruction and data bus, with the only difference
being that the data bus has write functionality. The protocol is very simple.
The bus has the standard clock, address, the incoming read data and the
outgoing write data. The core starts a transaction by setting the appropriate
values in the bus and issues a request. The peripheral responds with a grant
signal when it has accepted the values. When the grant signal is set, the core
can change the signals for the next transaction. When the peripheral has
finished processing the transaction it issues the data valid flag.</p><p><img src=pulp.png style=width:600px>
<em>PULPino data bus transaction (image taken by the PULPino user manual)</em></p><h3 id=coremem:77614929e15065dd7aa41233ec798d25>Coremem</h3><p>The coremem module is used to for handing all interactions between the core
and memories. Since PULPino has 2 buses, the module is used twice, one for the
ROM and one for the RAM and peripherals. The coremem essentially generates the
CE and the WE signal if it is a write operation, when there is a request from
the core and waits for one cycle until it sets the grant and valid signal.</p><p>The coremem design assumes that all peripherals are able to write the data in
one cycle. If a new peripheral needs more cycles to finish the operation, the
coremem should be modified, to introduce the extra cycles.</p><h3 id=bus:77614929e15065dd7aa41233ec798d25>Bus</h3><p>The minion SoC uses a custom tightly coupled bus for communication of the core
with the peripherals and the memories. For the core&rsquo;s instruction bus, the ROM
is directly connected with the <code>coremem_i</code> module that handles the protocol
handshakes.</p><p>The bus addresses are taken from the 4 MSBs of the data bus addresses in one
hot configuration, creating 16 distinct memory regions. Each of the 16 memory
regions are mapped to each peripheral and memories.</p><p>The peripherals and memories use the <code>one_hot_rdata[15:0]</code> array where each
position is related with the equivalent address, to store the preselected
information. That way the peripheral&rsquo;s SFRs (special function registers) are
created. The read operation and bus address creation happens in a
<code>always_comb</code> block The 16 loops in the for loop correspond to the 16 bus
addresses. The address is created when <code>core_lsu_addr[23:20]</code> is equal to the
address number. Finally the correct read data is stored in <code>core_lsu_rdata</code>,
selecting the <code>one_hot_data_addr</code> array element that is equal to the bus
address.</p><p>Writing operations are triggered when the <code>we_d</code> signal is set, along with the
corresponding <code>one_hot_data_addr</code>. The peripheral write operations happens in
the following always block that is triggered in a reset or a positive cycle
edge. If a reset is set, the SFRs take a default value.</p><p><center><table><tr><td>Type</td><td>Memory region</td><td>Bus address</td></tr><tr><td>ROM</td><td>0x000000</td><td>0</td></tr><tr><td>RAM</td><td>0x100000</td><td>1</td></tr><tr><td>UART</td><td>0x200000</td><td>2</td></tr><tr><td>SD</td><td>0x400000</td><td>4</td></tr><tr><td>GPIO (LED, DIP)</td><td>0x700000</td><td>7</td></tr><tr><td>PS2</td><td>0x900000</td><td>9</td></tr><tr><td>VGA</td><td>0xA00000</td><td>10</td></tr></table></center></p><p>In order to modify the bus and add more memory regions, the user should change
the width of the <code>one_hot_data_addr</code> keeping it equal to <code>one_hot_rdata</code>,
adding more MSBs of <code>core_lsu_addr</code> to the <code>one_hot_data_addr</code> address
generation, and modify the for loop generation. All changes should happen in
multiples of 2. Since the RAM and ROM locations are hardwired to the C linker
scripts, extra care should be taken that the RAM and ROM hold the same memory
region. Of course any modification in the memory locations should be reflected
in the software and the SFRs addresses.</p><h3 id=memories:77614929e15065dd7aa41233ec798d25>Memories</h3><p>The SoC uses one RAM to hold variables and a ROM to hold the program running.
The implementation lies in <code>code.v</code> and <code>data.v</code> and it&rsquo;s generated by the
compiled program, using the romgen software. The implementation is based on
Xilinx block ram specific modules.</p><h3 id=peripherals:77614929e15065dd7aa41233ec798d25>Peripherals</h3><p>The minion SoC has the following peripherals integrated:</p><ol><li>UART.</li><li>PS2.</li><li>SD card controller.</li><li>VGA.</li><li>GPIO (LED, DIP switches).</li></ol><p>All the peripherals are used from the rocket core. In my project there wasn&rsquo;t
a need to use the peripherals besides the UART and LEDs.</p><p>The GPIO operation is pretty straightforward. There is a SFR that you can
write the LED values and there is a SFR that reads the DIP values.</p><p>There are 3 SFRs for the UART.</p><ol><li>A status SFR that has information about the state of the UART, plus the
value of an incoming byte.</li><li>A SFR that holds the value for baud rate generation.</li><li>The Tx byte SFR.</li></ol><p>A Tx operation happens when the Tx value is sent to Tx SFR and if the UART is
not currently transmitting. For a Rx operation, the UART has a FIFO connected
to the Rx line. The read operation is triggered by making a write operation in
the status SFR. When that happens the FIFO stores the value in the 8 LSBs of
the status SFR.</p><p>The baud rate calculation uses the following equation: <code>SFR value = clock
frequency/ (baud rate * 4)</code>. For the arty project there is a 25MHz frequency
and a 9600 baud rate, so the equation is <code>SFR value = 25.000.000 / (9600 * 4)
= 651</code>.</p><h2 id=modifications:77614929e15065dd7aa41233ec798d25>Modifications</h2><p>During the designing phase of the CLS configuration, I identified some
improvements that could be made to minion SoC.</p><h3 id=coremem-1:77614929e15065dd7aa41233ec798d25>Coremem</h3><p>While examining the coremem module, I saw that the code had unreached states
(<code>WRITE_DATA</code>, <code>WRITE_ADDR</code>) because of constant assignment of the
<code>aw_ready_i</code>, <code>ar_ready_i</code>, and <code>w_ready_i</code> signals. The states could be
further reduced from the <code>READ_WAIT</code> and <code>WRITE_WAIT</code> states to just <code>WAIT</code>
but I left it that way because I think code is more readable. Removing the
unnecessary code simplified the module, which was then reduced to a simple one
cycle delay.</p><p>Moreover it was found in multiple places in the <code>minion_soc</code>, that the
<code>core_lsu_req</code> and <code>core_lsu_we</code> signals were used to access a peripheral in
the case of a data bus write. That functionality was identical with the use of
the <code>coremem_d</code>&rsquo;s signal <code>we_d</code>. So all the signals were replaced with the
<code>we_d</code> signal. That modification gives a clearer code, with the write of
peripherals trigged only from one place.</p><h3 id=uart-status:77614929e15065dd7aa41233ec798d25>UART status</h3><p>The UART status SFR (memory location 0x300000) has a lot of information about
the state of the UART. This included the <code>uart_wrcount</code> variable that shows
the number of the incoming bytes stored in FIFO. In my opinion the number of
available bytes in the FIFO is much more important information. The
<code>uart_rdcount</code> shows the number of bytes that are read from the software. I
replaced <code>uart_wrcount</code> with <code>uart_rdata_avail</code> which holds the available
bytes in the FIFO. The information is taken by subtracting <code>uart_wrcount</code> and
<code>uart_rdcount</code>.</p><h3 id=peripheral-modularisation:77614929e15065dd7aa41233ec798d25>Peripheral modularisation.</h3><p>The SoC uses a custom tightly coupled bus for the connection not based on AXI.
<code>minion_soc.sv</code> holds the bus implementation and code to connect the core with
the RAM, ROM and the peripherals used. This makes the code less clear and more
difficult add new peripherals. I made an attempt to separate the bus logic and
the peripherals from the minion SoC, so the code is more clear and for me to
better understand the bus logic. This attempt provided useful information that
was eventually used in the code generation. In my opinion this approach lead
to more clear and concise code.</p><p>The peripheral bus has the bus address, <code>bus_write</code> and <code>bus_read</code> array,
which have the same functionality as the original bus signals. The extra
<code>bus_we</code> and <code>bus_ce</code> arrays are added. The variables are used to signal a
read or write operation in the bus. Each peripheral must access the
corresponding <code>bus_we</code> and <code>bus_ce</code> by selecting the correct array member. The
peripherals are then responsible for reading or writing the correct SFR based
on the bus address.</p><p>The memconfig module (the naming could had been better) has all the bus
functionality and is responsible for the core and peripheral interaction. The
module generates the <code>bus_we</code> and <code>bus_ce</code> signals. The module also integrates
<code>coremem_d</code>, the module that handles the core&rsquo;s data bus operations. The
signals are generated in a similar way to the data read signals in the core&rsquo;s
data bus.</p><p>Note that this code was left unfinished so it is possible that it contains
bugs. In the future this work could be merged with the code generation in the
form of templates.</p><h2 id=software:77614929e15065dd7aa41233ec798d25>Software</h2><p>This section describes the software developed to run on the minion SoC.</p><h3 id=minimal-assembly:77614929e15065dd7aa41233ec798d25>Minimal assembly</h3><p>For the first experiments with the platform, I created an assembly program.
The reasons behind using assembly:</p><ol><li>Learning assembly gives you a better understanding of the architecture.</li><li>For easy programs, such as the one I created, the manually written assembly
code is significant less complex than the equivalent produced from a compiler.</li><li>The lack of a JTAG module lead to most of the debugging happening through
the studying of waveforms and hex values. Being familiar with the assembly
program and the assembly structure made debugging a lot easier.</li><li>It was a lot easier to setup the environment for the assembler than the
compiler.</li></ol><p>The first experiment was to examine the inner workings of the SoC and if
everything was ok. For that reason a very simple program was loaded in the
simulator. The program binary was loaded by hand, using the initial function
of verilog, in the <code>mem_tb</code> module. The program did a continuous increment on
the values of the <code>x1</code> register. Using the signals generated from the
simulation, I was able to verify correct operation by looking into the
instruction and data bus signals.</p><pre><code>_start:
  nop
  addi x1, x1, 1
  nop
  nop
  j _start
</code></pre><p>Finally I wanted to see if my understanding of the core and peripherals
connection was correct. For that reason I made a simple program that transmits
a &ldquo;Hello minion&rdquo; message through the UART and then blinks the LEDs. The
program is very simple, it first loads SFR and RAM variables memory addresses
into registers. Those registers will be used later to access the contents of
the SFR&rsquo;s through indirect memory addressing. The <code>_print_str</code> loop transmits
the message, the <code>_loop</code> blinks the LEDs and after that <code>_delay</code> loops for
~100ms. You can find the code
<a href=https://github.com/nchronas/minion_subsystem/blob/01475229ce16e7232b76e183a83fb275c206d63a/software/asm_test/test.asm>here</a>.</p><p>One of the most confusing issues that I had to face was to get used to how the
memory locations were calculated in progmem. The instruction bus address to
progmem ignores the 2 LSB bits (i.e. uses <code>core_instr_addr[15:2]</code>). So any
memory inside the progmem would be stored in an address shifted by 2 in order
to correspond to the address request from the core e.g. The core&rsquo;s boot
address is 0x80 memory location, the instruction hex value had to be stored in
the 0x20 memory location inside the progmem.</p><h3 id=minimal-c:77614929e15065dd7aa41233ec798d25>Minimal C</h3><p>In v0.4 of the minion subsystem there isn&rsquo;t a minimal C program for the users
to base and build their own program. In my case I needed a minimal C program
to use in testing and verification for the changes that I made in the minion
SoC, both in simulation and in the actual hardware. For those reasons I
created a minimal C program. Also the program was designed with the intention
to be easily understood and used from beginners. The bootstrap and hello
software couldn&rsquo;t be used for that purpose because a) bootstrap has a lot of
functionality used from the rocket core b) the hello example doesn&rsquo;t produce
the code and data verilog files that are needed to run the software in the
minion SoC. Also the project contains a lot of files that are not necessary
used from the program and that could be confusing to a beginner.</p><p>The program blinks the Arty LEDs, outputs the &ldquo;hello minion&rdquo; string in the
UART after the reset, echoes a received character in the UART and sends a
message if a button is pressed through the UART. In the Verilator simulation,
a UART test bed was used and the minion SoC module was modified so that it
would output the actions in the simulation terminal.</p><p>The necessary files to compile, link and use the software in the minion SoC
were copied from the <code>hello</code> software. The <code>bootstrap</code> makefile was used as a
template for the project and modified for use with the minimal C files.</p><p>The <code>minimal.c</code> file of the minimal program is very simple. It calls functions
defined in the minion library. The minion library is a very primitive HAL for
the minion SoC. The functions for the LED and the UART operation, were taken
from the <code>minion_lib</code> library, found in the <code>hello</code> program. The functions
were slightly modified by adding a preprocessor definition for the
peripheral&rsquo;s SFRs addresses, so the code is more clear to the user. The
functions are pretty self explanatory: The <code>to_led()</code> function outputs the
data value to the LEDS and <code>from_dip</code> returns the switches value. The blocking
functions <code>uart_recv()</code> and <code>uart_send()</code> receives/sends a byte to the UART.
<code>uart_send_buf</code> outputs the contents of a buffer. The <code>uart_bytes_available()</code>
function returns the available bytes in the Rx FIFO. This function is used in
conjunction with <code>uart_recv</code> only when there is available bytes in the Rx FIFO
so it won&rsquo;t block the main routine waiting for an incoming byte. <code>uart_init()</code>
calls <code>uart_set_baud</code> which sets the UART baud rate to 9600. In this version
the value 651 for setting the baud rate is calculated by hand. Finally
<code>uart_tx_status</code> returns the Tx status of UART. A delay function was added
with a approximate delay of 200ms. The delay is used from the example in order
to make the change in the LEDs visible to the human eye. The <code>utilities.c</code>
file holds empty functions, needed from the linker script.</p><p>A future expansion of the example could use the rest of the available
peripherals in the minion SoC.</p><h3 id=minimal-c-cls-version:77614929e15065dd7aa41233ec798d25>Minimal C CLS version</h3><p>The minimal C CLS version has the same functionality with the minimal C but
with a few modifications for the CLS configuration. The <code>i</code> variable is used
for keeping the LED value even after a CLS triggered reset. During a reset all
variables are initialized to zero. This operation is overridden by defining
the <code>i</code> variable as a pointer and selecting the memory address by hand. The
chosen memory location must be far away from the rest of the variables so it&rsquo;s
not overridden by accident. In a normal reset the variable should be
initialized to 0. The <code>reset_source</code> function returns if the reset triggered
from a CLS fault or from the general reset so it would initialize the
variable. This solution is a bit hacky and in the future the linker script
should be modified in order to incorporate this functionality.</p><h2 id=ports:77614929e15065dd7aa41233ec798d25>Ports</h2><p>The minion subsystem in the minion-v0.4 version didn&rsquo;t supported the Arty FPGA
board or any support for a simulator. In order to run the code I needed to
port them myself.</p><h3 id=verilator-1:77614929e15065dd7aa41233ec798d25>Verilator</h3><p>There were 2 main options for a simulator, the integrated simulator in the
Vivado suite and verilator. While the Vivado simulator would have been the
easier choice to use, the Vivado suite itself requires many CPU resources that
made the use in a virtual machine difficult. The other reason to use verilator
is for consistency with Rocket, which also uses verilator for simulation. The
use of verilator could enable a future integration of the minion SoC in the
rocket core simulation. In v0.4 of the lowRISC SoC, the minion SoC behaviour
in the simulation is emulated by test bed files. Also verilator uses C++ that
I&rsquo;m familiar with.</p><p>The rocket core verilator project was used as a template for porting into the
minion SoC. The <code>Makefile</code> was modified in order to select the verilog files
used from the minion SoC. Most of the work was to identify which files were
actually used in the pulpino core.</p><p>The minion SoC uses some modules that are Xilinx specific. The <code>FIFO18E1.v</code>
file had the simulation implementation of the FIFO modules used. The file was
taken from the Vivado installation. The <code>progmem</code> and <code>datamem</code> modules were
using Xilinx modules that I couldn&rsquo;t locate. The modules functionality were
identical, also they were simply enough to recreate in a testbed module.
Moreover using Verilog&rsquo;s <code>$readmemh()</code> function I was able to easily load the
minimal C example running in the minion core. For the rest of the modules,
dummy testbed modules were added in to <code>xilinx_tb.v</code>.</p><p>Again the rocket core simulation module was used as a template for the
<code>veri_top.cc</code>. The original file was stripped away so it would have the
minimal needed functionality for the minion SoC. Also the <code>top</code> signals were
modified to reflect the signals used in the minion SoC. The global library
files were directly copied into the project.</p><p>Running <code>make</code> in the <code>vsim</code> folder triggers the verilator program
compilation. If everything is ok, the required files are stored in the
<code>obj_dir</code> folder.</p><p>The <code>run_sim</code> script is used to start a simulation. Every signal is saved in a
VCD file during the simulation. After the simulation is finished, the minion
SoC&rsquo;s behaviour can be studied by viewing the generated waveforms, running
<code>gtkwave obj_dir/verilated.vcd</code>. Moreover the verilog <code>$display()</code> function
was used to display debug messages during the simulation.</p><h3 id=arty-1:77614929e15065dd7aa41233ec798d25>Arty</h3><p>The <code>nexys4ddr</code> project was used as a template for the arty port. A new vivado
project was created for the Arty port of the minion SoC. During The board
files needed for vivado to support Arty, were imported by following the
digilents guide found here. Again as in the verilator port, the most difficult
task was to find which files were actually used from the minion SoC. That
process was found through trial and error.</p><p>The Xilinx clock IP (<code>clk_wiz_arty_0</code>) was added in the design, the wizard
creates the clocks needed for the minion SoC, based on the parameters taken
from <code>nexys4ddr</code>. The <code>pin_plan_arty</code> constraint file was based on one from
Digilent&rsquo;s github and modified so that it has all the information needed to
map the I/O pins of the FPGA to the minion SoC design. Finally The
<code>top_arty.sv</code> file connects the minion SoC with the clocking wizard and only
the I/O pins used from the arty. Using the top arty file enables different
configurations for each board port, without needing to modify the <code>minion_soc</code>
file, thus keeping it identical for all boards.</p><p>The Arty and the Nexys boards have different resources available, so the
mapping is slight different. The 8 LEDs of the Nexys were mapped to the RGB
LEDs of the Arty. The reset is mapped to the reset button of the Arty. The
UART Rx and Tx was mapped to the onboard FTDI USB to serial converter. The
Arty doesn&rsquo;t include onboard a SD card, VGA and PS2 peripheral so the pins are
not mapped in the arty port. Digilent offers those peripherals in the form of
PMOD extension boards, that can be used with the arty. In the future the port
could be easily expanded to include the rest of the peripherals with the
PMODs. The only reason that the PMODS weren&rsquo;t included in the design from the
beginning was that board wouldn&rsquo;t have arrived on time for me to use them.</p><p>The project uses the <code>code.v</code> and <code>data.v</code> files from the minimal C example.
The files are not included in the repository so the user would have to either
compile the project or his own project.</p><p>The SD peripherals clock wizard (<code>clk_wiz_1</code> <code>sd_clk_div</code>) is not included in
the repository, so the user would have to either add it themselves or if the
SD peripheral is not used, remove the IP&rsquo;s code in the minion SoC and directly
assign the minion SoC clock to the SD clock: <code>assign msoc_clock = sd_clk_o</code>.
A slightly more difficult solution, if the user doesn&rsquo;t want to use the SD
peripheral, is to remove all SD functionality in the minion SoC.</p><p><center><table><tr><td align=left>Component name</td><td><code>clk_wiz_1</code></td></tr><tr><td align=left>Input clock frequency</td><td>25 MHz</td></tr><tr><td align=left>Output clock frequency</td><td>5MHz</td></tr><tr><td align=left>Output clock <code>clk_out1</code> name</td><td><code>clk_sdclk</code></td></tr><tr><td align=left>Dynamic reconfig</td><td>enabled</td></tr><tr><td align=left>Dynamic reconfig interface options</td><td>DRP</td></tr></table></center></p><h2 id=core-lock-step:77614929e15065dd7aa41233ec798d25>Core Lock Step</h2><p>In core lock step we use redundant CPU cores, running with the same inputs and
comparing each core output. In case there is a single event upset (SEU) during
operation, its effect would be shown in the affected core&rsquo;s output.</p><h3 id=issues:77614929e15065dd7aa41233ec798d25>Issues</h3><p>The CLS configuration offers protection from SEUs by continuously comparing
the output of each CPU based on common inputs. An SEU could effect a part in
the CPU that doesn&rsquo;t have immediate effect on the output and could manifest
later. For instance:</p><ol><li>The design of the CPU.</li><li>PULPino Performance counters.</li><li>Operations that store values in PULPino registers.</li></ol><p>The lowRISC minion subsystem is still under development and the CPU core could
change in the future, for that reasons the design of the CPU would not be
investigated.</p><p>Since operations that store the result on the CPU registers don&rsquo;t generate an
immediate output, a fault won&rsquo;t be immediately detected. A solution could be
that the registers are exposed and compared by the CLS unit. Another solution
would be to protect the registers by using techniques like TMR and ECC. Both
of that solutions would require modifying the CPU, which is avoided for this
project.</p><p>Registers are often spilled (i.e. written to or read from the stack), meaning
an SEU effect could be seen in relatively few cycles.</p><h3 id=assumptions:77614929e15065dd7aa41233ec798d25>Assumptions</h3><ol><li>The CLS configuration is focused only in the protection from SEUs and from
permanent faults.</li><li>The protection of the peripherals, memories and the CLS assist unit itself
won&rsquo;t be examined during this phase.</li><li>The debug unit is not used during the CLS configuration.</li></ol><h3 id=fault-detection-behaviour:77614929e15065dd7aa41233ec798d25>Fault detection behaviour</h3><p>The first and easiest fault handling is that the CLS unit resets the CPU
cores. Since it doesn&rsquo;t reset the RAM or other peripherals, the program could
be written in a way that assumes operation as quickly as possible.</p><p>Another solution could be that the CLS unit generates an exception, either by
modifying the CPU core in order to add the exception or by assigning an
interrupt. I preferred the interrupt approach because it&rsquo;s simpler and doesn&rsquo;t
need any CPU modification.</p><p>Finally, checkpoints could be used to restore the faulty CPU in the last know
healthy state. The checkpoints could be either introduced automatically or
manually from the developer. The checkpoint functionality should be achieved
with the support of software and hardware:</p><ol><li>Hardware: Adding the mechanism in the CLS unit that stores the state in the
form of the instruction address. This could be done with: a) extending the
instruction set including the checkpoint instruction or b) having a memory
addressable register that stores that state with ordinary store instructions.</li><li>Software: Since it&rsquo;s not easy to store the exact state of the CPU
(registers) the program execution should be altered so when a checkpoint is
used, it is ensured that no previous values in registers are used.</li></ol><p>One of the advantages of triple core lock step is that by having 3 cores using
voting, the core that suffered the fault the issue can be identified. Using a
restore mechanism like checkpoints or exceptions, the faulty core could be
re-synced in a few cycles, thus removing the need to restart the program.</p><h3 id=implementation:77614929e15065dd7aa41233ec798d25>Implementation</h3><p>The core lock step implementation was pretty straightforward after a better
understanding of the minion SoC and the pulpino core was achieved.</p><p>The CLS configuration was placed in the <code>minion_cls.sv</code> module. The module has
identical I/O with the pulpino core and is meant to replace the pulpino core
in <code>minion_soc.sv</code>. The only modification required in order to use the CLS
configuration is to add the <code>_cls</code> extension in the <code>riscv_core</code> from
<code>minion_soc.sv</code>. That way only minimal modification of <code>minion_soc</code> is
required. The module has 3 pulpino core instances, the <code>cls_cmp_unit</code> that
compares the core&rsquo;s output and signals a fault and the <code>cls_handler_unit</code> that
implements the fault recovery.</p><p>The cores are configured with 1 master and 2 slaves. The inputs are connected
directly from the module top. The 3 core&rsquo;s output are connected to the CLS
compare unit but only the master core is connected to the module&rsquo;s output
ports. Extra wires are only required by the slave cores and the naming is
differentiated using the cls1 and cls2 extensions. The cores are separated
into 1 master and 2 slaves by connecting the master’s outputs directly to the
modules output port and not by another module, which leads to less and more
clear code.</p><p>The <code>cls_cmp_unit</code> compares the outputs of all cores and issues a fault when
an issue is detected. The implementation was straightforward, the only
difficulty was in the code design in the comparison of that many signals. The
comparison starts only when a core issues a request signal for the instruction
or data bus. If there is a request in the instruction bus the unit then checks
for the addresses. For the data address there is an extra check in the write
data when a write is performed. It should be noted that the comparison unit
doesn&rsquo;t check for inconsistencies in the signals when a request is not issued
For more concise code the data and instruction request signals from all the
cores were concatenated into a single signal. A single fault signal is used
but if the recovery strategy requires it, the fault signal could be extended
in order to show what triggered the error.</p><p>The <code>cls_handler_unit</code> handles any faults detected from the compare unit.
Since the recovery strategy is to reset all cores, the unit intercepts the
reset signal from the top module to the cores. The unit has 2 tasks: a) to
monitor the top module&rsquo;s reset signal and forward a reset to the cores when
issued from the top module. b) Issue a reset to the cores for 1 clock cycle
when a fault is detected. The functionality of the module could have been
placed in the comparison unit but in my opinion the separation lead to a
better design.</p><p>Besides the <code>minion_cls</code>, the coremem module was modified in order to ensure
fault containment. In the case that a fault happens during a data write
operation, there is a chance that the erroneous operation happens before the
handler unit issues a reset. For that reason the <code>coremem</code> module is modified
in order to introduce one extra cycle delay during write operations. The
module delays setting the <code>ce</code>, <code>we</code> signals to the peripherals and the data
grant signal to the cores.</p><p>A reset source SFR was added, the SFR is 0 if the reset was triggered from a
normal reset and 1 if the reset was triggered by a CLS fault. That way the
software knows the reset source.</p><h3 id=fault-injection:77614929e15065dd7aa41233ec798d25>Fault injection</h3><p>Faults were simulated by injecting errors in the CLS design. These tests were
the only way to ensure that the design was working. The errors are created by
modifying the values in variables during runtime, usually by introducing
multiplexers. To my knowledge there isn&rsquo;t a framework that could make
automated integration of the multiplexers in the CLS design, so the
integration would have to be made manually. Introducing fault injection in
random places in the pulpino core would have been a difficult and cumbersome
task so it was avoided. A more plausible way was to inject errors in the cores
output.</p><p>The <code>fault_injection_assist</code> module was introduced in the <code>minion_cls.sv</code>. The
module overrides the cores outputs and when a fault injection is issued it
toggled the selected signal. The new signals are defined in the <code>minion_cls</code>
module. In order to use the fault injection, a <code>_finj</code> should be added in the
signal name, going to the CLS comparison module. The module&rsquo;s internal
implementation uses the <code>fault_injection_mux</code> module which is a simple
multiplexer. In normal operation, the multiplexer forwarded the incoming
signal value to the output. If a fault injection was requested and the index
matched the multiplexer, it toggled the incoming signal&rsquo;s value. The first
implementations tried to modify the existing signals by XORing to itself but
that created an infinite feedback loop.</p><p>One key issue was finding the best approach for the fault injection timing.
Without a model of the SEU generation in space, the best way was to inject
faults pseudo-randomly in a time range that would make sense. The first
attempt was to use a hardware pseudo random generator but it was quickly
abandoned for a more swift solution, implemented in software. In the beginning
all the output signals were exposed to fault injection but in order to make
testing simpler and reduce the used FPGA resources, only the data and
instruction bus request and address signals were used.</p><p>The first tests were made in verilator. The verilog top module was modified in
order to expose the fault generation and signal index to the verilator C++
program. In verilator test program a simple menu was created, where the user
selected from the terminal if there would be a fault injection and in what
signal. The menu was triggered by C++ pseudo random generator. As it was noted
above in the first implementations of the fault injection unit a XOR was used
in the affected signals. When the implementation was tested in the verilator,
a non convergence error was triggered, that lead to the discovery of the bad
design. Due to the added resources, the running simulation took longer to
evaluate, so the delay running in the main loop of the minion hardware was
reduced.</p><p>After the successful testing in the simulator, the design was tested in the
actual hardware. A Xilinx VIO debug IP was used to trigger and verify the
fault injection. The VIO IP connects the Arty board through JTAG to the Vivado
suite in real time. There the VIO inputs were used to monitor critical signals
in order to verify the correct behaviour of the CLS configuration. A VIO
output was connected to the fault injection unit, and a button in Vivado was
used to trigger a fault. The minion SoC with fault injection unit along with
the VIO IP required more LUTs that there were available in the Arty FPGA, I
had to remove the SD peripheral in order to free resources. Also the fault
injection unit was modified to allow only one signal to be used, in order to
limit resources usage.</p><p><img src=finj.png alt="Fault injection in simulation">
<em>Fault injection in simulation. The fault is injected in the red cursor.</em></p><h3 id=packetcraft:77614929e15065dd7aa41233ec798d25>Packetcraft</h3><p>In order to assess the CLS configuration, a test application was developed.
The application implements the test service, a subset of the command and data
handling protocol, running on UPSat. The test service is the equivalent of
<code>ping</code> in computer networks. The user sends a test service telecommand and the
subsystem, which in our case is the Arty, responds with a telecommand. For
more information about the protocol see the ECSS-E70-41A specification.</p><p><code>packet.py</code> continuously sends a test packet and counts the responses from the
Arty, while it randomly triggers a fault injection. If there is a difference
between the number of packets sent and received, it would mean that something
went wrong due to the fault injection. The fault injection is triggered by an
Arduino connected to the fault injection pin in the Arty.</p><p>The minion SoC runs with a CLS and fault injection configuration
<code>test_packet.c</code> found in software/packetcraft implements the test app on the
minion SoC side. The software is a very simple implementation, it reads the
incoming characters, has a small delay of ~5us that simulates the packet
processing time, check if there is a valid packet and responds. The original
software does multiple checks which weren&rsquo;t necessary to implement in this
case.</p><p>For the test I started to find which Tx period (packets send from
<code>packet.py</code>), is the limit where the SoC starts losing packets without fault
injection. The SoC had 20% packet losses with a Tx period of 0.08 which is
very good as the application is not optimized and the tx packet takes 0.01 sec
to transmit. After that I started to find the fault injection interval that
the SoC starts losing packets. At average of one fault injection per 0.025
sec, the SoC had 1.2% packet losses, at 0.01 sec there was 39.6, while at
0.005 there was 100% packet loss. This is very promising results since the
expected rate of faults induced by radiation is much less than that.</p><p><center><table><tr><td>Tx period (Sec)</td><td>Fault injection average period (Sec)</td><td>Packet losses (%)</td></tr><tr><td>0.08</td><td>0</td><td>20</td></tr><tr><td>0.05</td><td>0</td><td>50</td></tr><tr><td>0.1</td><td>1</td><td>0</td></tr><tr><td>0.1</td><td>0.5</td><td>0</td></tr><tr><td>0.1</td><td>0.05</td><td>0</td></tr><tr><td>0.1</td><td>0.025</td><td>1.2</td></tr><tr><td>0.1</td><td>0.01</td><td>39.6</td></tr><tr><td>0.1</td><td>0.005</td><td>100</td></tr></table></center></p><h2 id=code-generation-1:77614929e15065dd7aa41233ec798d25>Code generation</h2><p>The minion SoC functionality is implemented in the <code>minion_soc.sv</code>. In that
file the PULPino core along with the memories and peripherals are placed
together. In order to make a minion with a different configuration the user
would have to have modify the file, a cumbersome action that would be
intimidating for beginners and users that don’t have a good understanding of
the SoC.</p><p>For that reason I made a generator that takes a JSON configuration file and
produces the minion SoC. The project is still a work in progress and not a
full working project. Using the generator in the future enables users to
easily use the Core Lock Step configuration without writing code.</p><p>The generator is based on python and jinja2 for the templating engine. Other
options that were consider was the use of Chisel, myHDL and pyHDL but a
simpler solution in terms of dependencies and ease of use was preferred. One
design intention was to have minimal verilog code modification for the
template.</p><p>The JSON configuration file holds the configuration parameters of each module.
The usual options are the peripheral&rsquo;s name, the memory region that it uses
and if the module could be used multiple times the module&rsquo;s number. Each
module could have its own specific parameters.</p><p>The CLS configuration in core is enabled by setting the <code>core_lockstep</code>
parameter to true. In the case fault injection is needed, the
<code>fault_injection</code> must be set to true. The fault injection trigger is set by
selecting either a pin, a button or a VIO IP module.</p><p>The templates were derived from the <code>minion_soc.sv</code>. Each template could have:</p><ol><li>a port template that defines the module&rsquo;s I/O ports, if the module has I/O ports.</li><li>an instance template that defines the peripheral, along with any variable
that is needed. This template usually has the read SFRs and the memory region
that it uses. Finally if the peripheral could be used multiple times e.g.
UART, all the names of variables and modules uses a <code>peripheral_number</code>
template variable in order to distinguish itself from each different
peripheral instance.</li><li>an init template that has any register that needs to have a specific value
at reset.</li><li>a bus template that has holds all the write SFRs.</li></ol><p>Any custom peripheral could be added by implementing any of the above
templates.</p><p>The following templates are available:</p><ol><li>the core template has the CPU core.</li><li>the LED template.</li><li>the DIP switches template.</li><li>UART template.</li><li>PS2 template used for connection with a keyboard.</li><li>SD controller template.</li><li>VGA template</li></ol><p>The generator creates the <code>minion_soc.sv</code>, <code>coremem.sv</code>, <code>top_arty.sv</code> and the
<code>minion_cls.sv</code> if CLS is used. All generation is based on their corresponding
templates.</p><p>The peripherals use memory mapped SFRs to exchange information with the core.
The memory location of each SFR is used in the HAL from the software running
in the SoC. One of the key aspects of the code generation is the ability to
quickly modify each peripherals SFR memory region without requiring to rewrite
the HAL by generating the file that holds the memory locations.</p><p>Note that this code is still under development so it is possible that it
contains bugs. Currently the more than 1 UARTs implementation doesn&rsquo;t work.</p><h2 id=cls-power-and-size-differences:77614929e15065dd7aa41233ec798d25>CLS power and size differences</h2><p>One of the key metrics of any protection techniques, is the changes in
resources usage. In this section the resource usage of the CLS configuration
and the original SoC are reported. As we can see in the tables, the CLS has
26.47% overhead in LUTs, 3.51% in flip flops, 6.66% in DSP. The other
resources remain the same (the BUFG are not taken into account).</p><p>The other critical factor for use in CubeSats is the power dissipation. The
added 8mW is not an issue. Also the general power dissipation makes it usable
for 2U cubesat, as In <a href=https://upsat.gr/>UPSat</a> the onboard computer used
0.198W.</p><p><img src=cls_graph.png alt> <img src=cls_util.png alt></p><p><img src=graph.png alt> <img src=util.png alt></p><p><em>Resource utilization with CLS (top) and without (bottom)</em></p><p><img src=cls_pwr.png alt> <img src=cls_pwr_el.png alt></p><p><img src=pwr.png alt> <img src=pwr_graph.png alt></p><p><em>Power usage: with CLS (top) and without (bottom)</em></p><h2 id=thoughts-and-future-work:77614929e15065dd7aa41233ec798d25>Thoughts and future work</h2><p>One of the reasons that I started the GSoC project was get more familiar with
HDL and FPGAs while I contributed to an open source project. Even though the
CLS configuration is experimental and needs more work to be done, I believe
that I made one step towards more open source in Space. Also debugging the
minion SoC in the FPGA without JTAG is bad.</p><p>After GSoC I would like to continue working in the code generation project.
Using the code generation made design and testing simpler. I wish I started
working in the project earlier in the summer.</p><p>Finally I would like to thank my mentor, Alex Bradbury for his help and
patience, Mr Aris Stathakis for lending me his Arty board, and Google for
making GSoC.</p></div></main><footer class=lr-footer><div class=container><div class=row><div class="col-lg-2 d-none d-lg-block"><img src=/img/logo/logo-dualcolor.svg width=150px></div><div class=col><p><small>The text content on this website is licensed under a <a href=https://creativecommons.org/licenses/by/4.0/>Creative Commons Attribution 4.0 International License</a>, except where otherwise noted. No license is granted for logos or other trademarks. Other content &copy; lowRISC Contributors.</small></p><p><small><a href=/privacy-policy>Privacy and cookies policy</a>
&middot; <a href=/usage-licence>Usage licence</a></small></p></div><div class=col-lg-2><p><a href=#>Back to top</a></p></div></div></div></footer><script src=/main.f5831.js></script></body></html>